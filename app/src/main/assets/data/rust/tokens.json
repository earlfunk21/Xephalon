{"lang":"Rust","fullPath":"/tokens","category":"","title":"tokens.html","url":"https://doc.rust-lang.org/stable/reference/tokens.html","markdown":"# [Tokens](#tokens)\n\nTokens are primitive productions in the grammar defined by regular (non-recursive) languages. Rust source input can be broken down into the following kinds of tokens:\n\n* [Keywords](keywords.html)\n* [Identifiers](identifiers.html)\n* [Literals](#literals)\n* [Lifetimes](#lifetimes-and-loop-labels)\n* [Punctuation](#punctuation)\n* [Delimiters](#delimiters)\n\nWithin this documentation's grammar, \"simple\" tokens are given in [string table production](notation.html#string-table-productions) form, and appear in `monospace` font.\n\n## [Literals](#literals)\n\nLiterals are tokens used in [literal expressions](expressions/literal-expr.html).\n\n### [Examples](#examples)\n\n#### [Characters and strings](#characters-and-strings)\n\n| Example                                      | # sets\\*    | Characters | Escapes     |                                                                                 |\n| -------------------------------------------- | ----------- | ---------- | ----------- | ------------------------------------------------------------------------------- |\n| [Character](#character-literals)             | 'H'         | 0          | All Unicode | [Quote](#quote-escapes) & [ASCII](#ascii-escapes) & [Unicode](#unicode-escapes) |\n| [String](#string-literals)                   | \"hello\"     | 0          | All Unicode | [Quote](#quote-escapes) & [ASCII](#ascii-escapes) & [Unicode](#unicode-escapes) |\n| [Raw string](#raw-string-literals)           | r#\"hello\"#  | <256       | All Unicode | N/A                                                                             |\n| [Byte](#byte-literals)                       | b'H'        | 0          | All ASCII   | [Quote](#quote-escapes) & [Byte](#byte-escapes)                                 |\n| [Byte string](#byte-string-literals)         | b\"hello\"    | 0          | All ASCII   | [Quote](#quote-escapes) & [Byte](#byte-escapes)                                 |\n| [Raw byte string](#raw-byte-string-literals) | br#\"hello\"# | <256       | All ASCII   | N/A                                                                             |\n\n\\* The number of `#`s on each side of the same literal must be equivalent.\n\n#### [ASCII escapes](#ascii-escapes)\n\n| Name  |                                                     |\n| ----- | --------------------------------------------------- |\n| \\\\x41 | 7-bit character code (exactly 2 digits, up to 0x7F) |\n| \\\\n   | Newline                                             |\n| \\\\r   | Carriage return                                     |\n| \\\\t   | Tab                                                 |\n| \\\\\\\\  | Backslash                                           |\n| \\\\0   | Null                                                |\n\n#### [Byte escapes](#byte-escapes)\n\n| Name  |                                         |\n| ----- | --------------------------------------- |\n| \\\\x7F | 8-bit character code (exactly 2 digits) |\n| \\\\n   | Newline                                 |\n| \\\\r   | Carriage return                         |\n| \\\\t   | Tab                                     |\n| \\\\\\\\  | Backslash                               |\n| \\\\0   | Null                                    |\n\n#### [Unicode escapes](#unicode-escapes)\n\n| Name      |                                                |\n| --------- | ---------------------------------------------- |\n| \\\\u{7FFF} | 24-bit Unicode character code (up to 6 digits) |\n\n#### [Quote escapes](#quote-escapes)\n\n| Name |              |\n| ---- | ------------ |\n| \\\\'  | Single quote |\n| \\\\\"  | Double quote |\n\n#### [Numbers](#numbers)\n\n| [Number literals](#number-literals)\\* | Example      | Exponentiation |\n| ------------------------------------- | ------------ | -------------- |\n| Decimal integer                       | 98\\_222      | N/A            |\n| Hex integer                           | 0xff         | N/A            |\n| Octal integer                         | 0o77         | N/A            |\n| Binary integer                        | 0b1111\\_0000 | N/A            |\n| Floating-point                        | 123.0E+77    | Optional       |\n\n`*` All number literals allow `_` as a visual separator: `1_234.0E+18f64`\n\n#### [Suffixes](#suffixes)\n\nA suffix is a sequence of characters following the primary part of a literal (without intervening whitespace), of the same form as a non-raw identifier or keyword.\n\n> **Lexer**  \n> SUFFIX : IDENTIFIER\\_OR\\_KEYWORD  \n> SUFFIX\\_NO\\_E : SUFFIX _not beginning with `e` or `E`_\n\nAny kind of literal (string, integer, etc) with any suffix is valid as a token.\n\nA literal token with any suffix can be passed to a macro without producing an error. The macro itself will decide how to interpret such a token and whether to produce an error or not. In particular, the `literal` fragment specifier for by-example macros matches literal tokens with arbitrary suffixes.\n\n```rust\n#![allow(unused)]\nfn main() {\nmacro_rules! blackhole { ($tt:tt) => () }\nmacro_rules! blackhole_lit { ($l:literal) => () }\n\nblackhole!(\"string\"suffix); // OK\nblackhole_lit!(1suffix); // OK\n}\n```\n\nHowever, suffixes on literal tokens which are interpreted as literal expressions or patterns are restricted. Any suffixes are rejected on non-numeric literal tokens, and numeric literal tokens are accepted only with suffixes from the list below.\n\n| Integer                                                        | Floating-point |\n| -------------------------------------------------------------- | -------------- |\n| u8, i8, u16, i16, u32, i32, u64, i64, u128, i128, usize, isize | f32, f64       |\n\n### [Character and string literals](#character-and-string-literals)\n\n#### [Character literals](#character-literals)\n\n> **Lexer**  \n> CHAR\\_LITERAL :  \n> `'` ( \\~\\[`'` `\\` \\\\n \\\\r \\\\t\\] | QUOTE\\_ESCAPE | ASCII\\_ESCAPE | UNICODE\\_ESCAPE ) `'` SUFFIX?\n> \n> QUOTE\\_ESCAPE :  \n> `\\'` | `\\\"`\n> \n> ASCII\\_ESCAPE :  \n> `\\x` OCT\\_DIGIT HEX\\_DIGIT  \n> | `\\n` | `\\r` | `\\t` | `\\\\` | `\\0`\n> \n> UNICODE\\_ESCAPE :  \n> `\\u{` ( HEX\\_DIGIT `_`\\* )1..6 `}`\n\nA _character literal_ is a single Unicode character enclosed within two`U+0027` (single-quote) characters, with the exception of `U+0027` itself, which must be _escaped_ by a preceding `U+005C` character (`\\`).\n\n#### [String literals](#string-literals)\n\n> **Lexer**  \n> STRING\\_LITERAL :  \n> `\"` (  \n> \\~\\[`\"` `\\` _IsolatedCR_\\]  \n> | QUOTE\\_ESCAPE  \n> | ASCII\\_ESCAPE  \n> | UNICODE\\_ESCAPE  \n> | STRING\\_CONTINUE  \n> )\\* `\"` SUFFIX?\n> \n> STRING\\_CONTINUE :  \n> `\\` _followed by_ \\\\n\n\nA _string literal_ is a sequence of any Unicode characters enclosed within two`U+0022` (double-quote) characters, with the exception of `U+0022` itself, which must be _escaped_ by a preceding `U+005C` character (`\\`).\n\nLine-breaks are allowed in string literals. A line-break is either a newline (`U+000A`) or a pair of carriage return and newline (`U+000D`, `U+000A`). Both byte sequences are normally translated to `U+000A`, but as a special exception, when an unescaped `U+005C` character (`\\`) occurs immediately before a line break, then the line break character(s), and all immediately following` ` (`U+0020`), `\\t` (`U+0009`), `\\n` (`U+000A`) and `\\r` (`U+0000D`) characters are ignored. Thus `a`, `b` and `c` are equal:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet a = \"foobar\";\nlet b = \"foo\\\n         bar\";\nlet c = \"foo\\\n\n     bar\";\n\nassert_eq!(a, b);\nassert_eq!(b, c);\n}\n```\n\n> Note: Rust skipping additional newlines (like in example `c`) is potentially confusing and unexpected. This behavior may be adjusted in the future. Until a decision is made, it is recommended to avoid relying on this, i.e. skipping multiple newlines with line continuations. See [this issue](https://github.com/rust-lang/reference/pull/1042) for more information.\n\n#### [Character escapes](#character-escapes)\n\nSome additional _escapes_ are available in either character or non-raw string literals. An escape starts with a `U+005C` (`\\`) and continues with one of the following forms:\n\n* A _7-bit code point escape_ starts with `U+0078` (`x`) and is followed by exactly two _hex digits_ with value up to `0x7F`. It denotes the ASCII character with value equal to the provided hex value. Higher values are not permitted because it is ambiguous whether they mean Unicode code points or byte values.\n* A _24-bit code point escape_ starts with `U+0075` (`u`) and is followed by up to six _hex digits_ surrounded by braces `U+007B` (`{`) and `U+007D`(`}`). It denotes the Unicode code point equal to the provided hex value.\n* A _whitespace escape_ is one of the characters `U+006E` (`n`), `U+0072`(`r`), or `U+0074` (`t`), denoting the Unicode values `U+000A` (LF),`U+000D` (CR) or `U+0009` (HT) respectively.\n* The _null escape_ is the character `U+0030` (`0`) and denotes the Unicode value `U+0000` (NUL).\n* The _backslash escape_ is the character `U+005C` (`\\`) which must be escaped in order to denote itself.\n\n#### [Raw string literals](#raw-string-literals)\n\n> **Lexer**  \n> RAW\\_STRING\\_LITERAL :  \n> `r` RAW\\_STRING\\_CONTENT SUFFIX?\n> \n> RAW\\_STRING\\_CONTENT :  \n> `\"` ( \\~ _IsolatedCR_ )\\* (non-greedy) `\"`  \n> | `#` RAW\\_STRING\\_CONTENT `#`\n\nRaw string literals do not process any escapes. They start with the character`U+0072` (`r`), followed by fewer than 256 of the character `U+0023` (`#`) and a`U+0022` (double-quote) character. The _raw string body_ can contain any sequence of Unicode characters and is terminated only by another `U+0022` (double-quote) character, followed by the same number of `U+0023` (`#`) characters that preceded the opening `U+0022` (double-quote) character.\n\nAll Unicode characters contained in the raw string body represent themselves, the characters `U+0022` (double-quote) (except when followed by at least as many `U+0023` (`#`) characters as were used to start the raw string literal) or`U+005C` (`\\`) do not have any special meaning.\n\nExamples for string literals:\n\n```rust\n#![allow(unused)]\nfn main() {\n\"foo\"; r\"foo\";                     // foo\n\"\\\"foo\\\"\"; r#\"\"foo\"\"#;             // \"foo\"\n\n\"foo #\\\"# bar\";\nr##\"foo #\"# bar\"##;                // foo #\"# bar\n\n\"\\x52\"; \"R\"; r\"R\";                 // R\n\"\\\\x52\"; r\"\\x52\";                  // \\x52\n}\n```\n\n### [Byte and byte string literals](#byte-and-byte-string-literals)\n\n#### [Byte literals](#byte-literals)\n\n> **Lexer**  \n> BYTE\\_LITERAL :  \n> `b'` ( ASCII\\_FOR\\_CHAR | BYTE\\_ESCAPE ) `'` SUFFIX?\n> \n> ASCII\\_FOR\\_CHAR :  \n> _any ASCII (i.e. 0x00 to 0x7F), except_ `'`, `\\`, \\\\n, \\\\r or \\\\t\n> \n> BYTE\\_ESCAPE :  \n> `\\x` HEX\\_DIGIT HEX\\_DIGIT  \n> | `\\n` | `\\r` | `\\t` | `\\\\` | `\\0` | `\\'` | `\\\"`\n\nA _byte literal_ is a single ASCII character (in the `U+0000` to `U+007F`range) or a single _escape_ preceded by the characters `U+0062` (`b`) and`U+0027` (single-quote), and followed by the character `U+0027`. If the character`U+0027` is present within the literal, it must be _escaped_ by a preceding`U+005C` (`\\`) character. It is equivalent to a `u8` unsigned 8-bit integer_number literal_.\n\n#### [Byte string literals](#byte-string-literals)\n\n> **Lexer**  \n> BYTE\\_STRING\\_LITERAL :  \n> `b\"` ( ASCII\\_FOR\\_STRING | BYTE\\_ESCAPE | STRING\\_CONTINUE )\\* `\"` SUFFIX?\n> \n> ASCII\\_FOR\\_STRING :  \n> _any ASCII (i.e 0x00 to 0x7F), except_ `\"`, `\\` _and IsolatedCR_\n\nA non-raw _byte string literal_ is a sequence of ASCII characters and _escapes_, preceded by the characters `U+0062` (`b`) and `U+0022` (double-quote), and followed by the character `U+0022`. If the character `U+0022` is present within the literal, it must be _escaped_ by a preceding `U+005C` (`\\`) character. Alternatively, a byte string literal can be a _raw byte string literal_, defined below. The type of a byte string literal of length `n` is `&'static [u8; n]`.\n\nSome additional _escapes_ are available in either byte or non-raw byte string literals. An escape starts with a `U+005C` (`\\`) and continues with one of the following forms:\n\n* A _byte escape_ escape starts with `U+0078` (`x`) and is followed by exactly two _hex digits_. It denotes the byte equal to the provided hex value.\n* A _whitespace escape_ is one of the characters `U+006E` (`n`), `U+0072`(`r`), or `U+0074` (`t`), denoting the bytes values `0x0A` (ASCII LF),`0x0D` (ASCII CR) or `0x09` (ASCII HT) respectively.\n* The _null escape_ is the character `U+0030` (`0`) and denotes the byte value `0x00` (ASCII NUL).\n* The _backslash escape_ is the character `U+005C` (`\\`) which must be escaped in order to denote its ASCII encoding `0x5C`.\n\n#### [Raw byte string literals](#raw-byte-string-literals)\n\n> **Lexer**  \n> RAW\\_BYTE\\_STRING\\_LITERAL :  \n> `br` RAW\\_BYTE\\_STRING\\_CONTENT SUFFIX?\n> \n> RAW\\_BYTE\\_STRING\\_CONTENT :  \n> `\"` ASCII\\* (non-greedy) `\"`  \n> | `#` RAW\\_BYTE\\_STRING\\_CONTENT `#`\n> \n> ASCII :  \n> _any ASCII (i.e. 0x00 to 0x7F)_\n\nRaw byte string literals do not process any escapes. They start with the character `U+0062` (`b`), followed by `U+0072` (`r`), followed by fewer than 256 of the character `U+0023` (`#`), and a `U+0022` (double-quote) character. The_raw string body_ can contain any sequence of ASCII characters and is terminated only by another `U+0022` (double-quote) character, followed by the same number of`U+0023` (`#`) characters that preceded the opening `U+0022` (double-quote) character. A raw byte string literal can not contain any non-ASCII byte.\n\nAll characters contained in the raw string body represent their ASCII encoding, the characters `U+0022` (double-quote) (except when followed by at least as many `U+0023` (`#`) characters as were used to start the raw string literal) or`U+005C` (`\\`) do not have any special meaning.\n\nExamples for byte string literals:\n\n```rust\n#![allow(unused)]\nfn main() {\nb\"foo\"; br\"foo\";                     // foo\nb\"\\\"foo\\\"\"; br#\"\"foo\"\"#;             // \"foo\"\n\nb\"foo #\\\"# bar\";\nbr##\"foo #\"# bar\"##;                 // foo #\"# bar\n\nb\"\\x52\"; b\"R\"; br\"R\";                // R\nb\"\\\\x52\"; br\"\\x52\";                  // \\x52\n}\n```\n\n### [Number literals](#number-literals)\n\nA _number literal_ is either an _integer literal_ or a _floating-point literal_. The grammar for recognizing the two kinds of literals is mixed.\n\n#### [Integer literals](#integer-literals)\n\n> **Lexer**  \n> INTEGER\\_LITERAL :  \n> ( DEC\\_LITERAL | BIN\\_LITERAL | OCT\\_LITERAL | HEX\\_LITERAL ) SUFFIX\\_NO\\_E?\n> \n> DEC\\_LITERAL :  \n> DEC\\_DIGIT (DEC\\_DIGIT|`_`)\\*\n> \n> BIN\\_LITERAL :  \n> `0b` (BIN\\_DIGIT|`_`)\\* BIN\\_DIGIT (BIN\\_DIGIT|`_`)\\*\n> \n> OCT\\_LITERAL :  \n> `0o` (OCT\\_DIGIT|`_`)\\* OCT\\_DIGIT (OCT\\_DIGIT|`_`)\\*\n> \n> HEX\\_LITERAL :  \n> `0x` (HEX\\_DIGIT|`_`)\\* HEX\\_DIGIT (HEX\\_DIGIT|`_`)\\*\n> \n> BIN\\_DIGIT : \\[`0`\\-`1`\\]\n> \n> OCT\\_DIGIT : \\[`0`\\-`7`\\]\n> \n> DEC\\_DIGIT : \\[`0`\\-`9`\\]\n> \n> HEX\\_DIGIT : \\[`0`\\-`9` `a`\\-`f` `A`\\-`F`\\]\n\nAn _integer literal_ has one of four forms:\n\n* A _decimal literal_ starts with a _decimal digit_ and continues with any mixture of _decimal digits_ and _underscores_.\n* A _hex literal_ starts with the character sequence `U+0030` `U+0078`(`0x`) and continues as any mixture (with at least one digit) of hex digits and underscores.\n* An _octal literal_ starts with the character sequence `U+0030` `U+006F`(`0o`) and continues as any mixture (with at least one digit) of octal digits and underscores.\n* A _binary literal_ starts with the character sequence `U+0030` `U+0062`(`0b`) and continues as any mixture (with at least one digit) of binary digits and underscores.\n\nLike any literal, an integer literal may be followed (immediately, without any spaces) by a suffix as described above. The suffix may not begin with `e` or `E`, as that would be interpreted as the exponent of a floating-point literal. See [literal expressions](expressions/literal-expr.html) for the effect of these suffixes.\n\nExamples of integer literals which are accepted as literal expressions:\n\n```rust\n#![allow(unused)]\nfn main() {\n#![allow(overflowing_literals)]\n123;\n123i32;\n123u32;\n123_u32;\n\n0xff;\n0xff_u8;\n0x01_f32; // integer 7986, not floating-point 1.0\n0x01_e3;  // integer 483, not floating-point 1000.0\n\n0o70;\n0o70_i16;\n\n0b1111_1111_1001_0000;\n0b1111_1111_1001_0000i64;\n0b________1;\n\n0usize;\n\n// These are too big for their type, but are accepted as literal expressions.\n128_i8;\n256_u8;\n\n// This is an integer literal, accepted as a floating-point literal expression.\n5f32;\n}\n```\n\nNote that `-1i8`, for example, is analyzed as two tokens: `-` followed by `1i8`.\n\nExamples of integer literals which are not accepted as literal expressions:\n\n```rust\n#![allow(unused)]\nfn main() {\n#[cfg(FALSE)] {\n0invalidSuffix;\n123AFB43;\n0b010a;\n0xAB_CD_EF_GH;\n0b1111_f32;\n}\n}\n```\n\n#### [Tuple index](#tuple-index)\n\n> **Lexer**  \n> TUPLE\\_INDEX:   \n> INTEGER\\_LITERAL\n\nA tuple index is used to refer to the fields of [tuples](types/tuple.html), [tuple structs](items/structs.html), and[tuple variants](items/enumerations.html).\n\nTuple indices are compared with the literal token directly. Tuple indices start with `0` and each successive index increments the value by `1` as a decimal value. Thus, only decimal values will match, and the value must not have any extra `0` prefix characters.\n\n```rust\n#![allow(unused)]\nfn main() {\nlet example = (\"dog\", \"cat\", \"horse\");\nlet dog = example.0;\nlet cat = example.1;\n// The following examples are invalid.\nlet cat = example.01;  // ERROR no field named `01`\nlet horse = example.0b10;  // ERROR no field named `0b10`\n}\n```\n\n> **Note**: Tuple indices may include certain suffixes, but this is not intended to be valid, and may be removed in a future version. See <https://github.com/rust-lang/rust/issues/60210> for more information.\n\n#### [Floating-point literals](#floating-point-literals)\n\n> **Lexer**  \n> FLOAT\\_LITERAL :  \n> DEC\\_LITERAL `.` _(not immediately followed by `.`, `` or an XID\\_Start character)_  \n> | DEC\\_LITERAL `.` DEC\\_LITERAL SUFFIX\\_NO\\_E?  \n> | DEC\\_LITERAL (`.` DEC\\_LITERAL)? FLOAT\\_EXPONENT SUFFIX?\n> \n> FLOAT\\_EXPONENT :  \n> (`e`|`E`) (`+`|`-`)?(DEC\\_DIGIT|`_`)\\* DEC\\_DIGIT (DEC\\_DIGIT|`_`)\\*\n\nA _floating-point literal_ has one of two forms:\n\n* A _decimal literal_ followed by a period character `U+002E` (`.`). This is optionally followed by another decimal literal, with an optional _exponent_.\n* A single _decimal literal_ followed by an _exponent_.\n\nLike integer literals, a floating-point literal may be followed by a suffix, so long as the pre-suffix part does not end with `U+002E` (`.`). The suffix may not begin with `e` or `E` if the literal does not include an exponent. See [literal expressions](expressions/literal-expr.html) for the effect of these suffixes.\n\nExamples of floating-point literals which are accepted as literal expressions:\n\n```rust\n#![allow(unused)]\nfn main() {\n123.0f64;\n0.1f64;\n0.1f32;\n12E+99_f64;\nlet x: f64 = 2.;\n}\n```\n\nThis last example is different because it is not possible to use the suffix syntax with a floating point literal ending in a period. `2.f64` would attempt to call a method named `f64` on `2`.\n\nNote that `-1.0`, for example, is analyzed as two tokens: `-` followed by `1.0`.\n\nExamples of floating-point literals which are not accepted as literal expressions:\n\n```rust\n#![allow(unused)]\nfn main() {\n#[cfg(FALSE)] {\n2.0f80;\n2e5f80;\n2e5e6;\n2.0e5e6;\n1.3e10u64;\n}\n}\n```\n\n#### [Reserved forms similar to number literals](#reserved-forms-similar-to-number-literals)\n\n> **Lexer**  \n> RESERVED\\_NUMBER :  \n> BIN\\_LITERAL \\[`2`\\-`9`​\\]  \n> | OCT\\_LITERAL \\[`8`\\-`9`​\\]  \n> | ( BIN\\_LITERAL | OCT\\_LITERAL | HEX\\_LITERAL ) `.`   \n> _(not immediately followed by `.`, `` or an XID\\_Start character)_  \n> | ( BIN\\_LITERAL | OCT\\_LITERAL ) (`e`|`E`)  \n> | `0b` `_`\\* _end of input or not BIN\\_DIGIT_  \n> | `0o` `_`\\* _end of input or not OCT\\_DIGIT_  \n> | `0x` `_`\\* _end of input or not HEX\\_DIGIT_  \n> | DEC\\_LITERAL ( . DEC\\_LITERAL)? (`e`|`E`) (`+`|`-`)? _end of input or not DEC\\_DIGIT_\n\nThe following lexical forms similar to number literals are _reserved forms_. Due to the possible ambiguity these raise, they are rejected by the tokenizer instead of being interpreted as separate tokens.\n\n* An unsuffixed binary or octal literal followed, without intervening whitespace, by a decimal digit out of the range for its radix.\n* An unsuffixed binary, octal, or hexadecimal literal followed, without intervening whitespace, by a period character (with the same restrictions on what follows the period as for floating-point literals).\n* An unsuffixed binary or octal literal followed, without intervening whitespace, by the character `e` or `E`.\n* Input which begins with one of the radix prefixes but is not a valid binary, octal, or hexadecimal literal (because it contains no digits).\n* Input which has the form of a floating-point literal with no digits in the exponent.\n\nExamples of reserved forms:\n\n```rust\n#![allow(unused)]\nfn main() {\n0b0102;  // this is not `0b010` followed by `2`\n0o1279;  // this is not `0o127` followed by `9`\n0x80.0;  // this is not `0x80` followed by `.` and `0`\n0b101e;  // this is not a suffixed literal, or `0b101` followed by `e`\n0b;      // this is not an integer literal, or `0` followed by `b`\n0b_;     // this is not an integer literal, or `0` followed by `b_`\n2e;      // this is not a floating-point literal, or `2` followed by `e`\n2.0e;    // this is not a floating-point literal, or `2.0` followed by `e`\n2em;     // this is not a suffixed literal, or `2` followed by `em`\n2.0em;   // this is not a suffixed literal, or `2.0` followed by `em`\n}\n```\n\n## [Lifetimes and loop labels](#lifetimes-and-loop-labels)\n\n> **Lexer**  \n> LIFETIME\\_TOKEN :  \n> `'` [IDENTIFIER\\_OR\\_KEYWORD](identifiers.html)  \n> | `'_`\n> \n> LIFETIME\\_OR\\_LABEL :  \n> `'` [NON\\_KEYWORD\\_IDENTIFIER](identifiers.html)\n\nLifetime parameters and [loop labels](expressions/loop-expr.html) use LIFETIME\\_OR\\_LABEL tokens. Any LIFETIME\\_TOKEN will be accepted by the lexer, and for example, can be used in macros.\n\n## [Punctuation](#punctuation)\n\nPunctuation symbol tokens are listed here for completeness. Their individual usages and meanings are defined in the linked pages.\n\n| Symbol | Name       | Usage                                                                                                                                                                                                                                                                                                                         |\n| ------ | ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| +      | Plus       | [Addition](expressions/operator-expr.html#arithmetic-and-logical-binary-operators), [Trait Bounds](trait-bounds.html), [Macro Kleene Matcher](macros-by-example.html)                                                                                                                                                         |\n| \\-     | Minus      | [Subtraction](expressions/operator-expr.html#arithmetic-and-logical-binary-operators), [Negation](expressions/operator-expr.html#negation-operators)                                                                                                                                                                          |\n| \\*     | Star       | [Multiplication](expressions/operator-expr.html#arithmetic-and-logical-binary-operators), [Dereference](expressions/operator-expr.html#the-dereference-operator), [Raw Pointers](types/pointer.html#raw-pointers-const-and-mut), [Macro Kleene Matcher](macros-by-example.html), [Use wildcards](items/use-declarations.html) |\n| /      | Slash      | [Division](expressions/operator-expr.html#arithmetic-and-logical-binary-operators)                                                                                                                                                                                                                                            |\n| %      | Percent    | [Remainder](expressions/operator-expr.html#arithmetic-and-logical-binary-operators)                                                                                                                                                                                                                                           |\n| ^      | Caret      | [Bitwise and Logical XOR](expressions/operator-expr.html#arithmetic-and-logical-binary-operators)                                                                                                                                                                                                                             |\n| !      | Not        | [Bitwise and Logical NOT](expressions/operator-expr.html#negation-operators), [Macro Calls](macros-by-example.html), [Inner Attributes](attributes.html), [Never Type](types/never.html), [Negative impls](items/implementations.html)                                                                                        |\n| &      | And        | [Bitwise and Logical AND](expressions/operator-expr.html#arithmetic-and-logical-binary-operators), [Borrow](expressions/operator-expr.html#borrow-operators), [References](types/pointer.html), [Reference patterns](patterns.html#reference-patterns)                                                                        |\n| \\|     | Or         | [Bitwise and Logical OR](expressions/operator-expr.html#arithmetic-and-logical-binary-operators), [Closures](expressions/closure-expr.html), Patterns in [match](expressions/match-expr.html), [if let](expressions/if-expr.html#if-let-expressions), and [while let](expressions/loop-expr.html#predicate-pattern-loops)     |\n| &&     | AndAnd     | [Lazy AND](expressions/operator-expr.html#lazy-boolean-operators), [Borrow](expressions/operator-expr.html#borrow-operators), [References](types/pointer.html), [Reference patterns](patterns.html#reference-patterns)                                                                                                        |\n| \\||    | OrOr       | [Lazy OR](expressions/operator-expr.html#lazy-boolean-operators), [Closures](expressions/closure-expr.html)                                                                                                                                                                                                                   |\n| <<     | Shl        | [Shift Left](expressions/operator-expr.html#arithmetic-and-logical-binary-operators), [Nested Generics](items/generics.html)                                                                                                                                                                                                  |\n| \\>>    | Shr        | [Shift Right](expressions/operator-expr.html#arithmetic-and-logical-binary-operators), [Nested Generics](items/generics.html)                                                                                                                                                                                                 |\n| +=     | PlusEq     | [Addition assignment](expressions/operator-expr.html#compound-assignment-expressions)                                                                                                                                                                                                                                         |\n| \\-=    | MinusEq    | [Subtraction assignment](expressions/operator-expr.html#compound-assignment-expressions)                                                                                                                                                                                                                                      |\n| \\*=    | StarEq     | [Multiplication assignment](expressions/operator-expr.html#compound-assignment-expressions)                                                                                                                                                                                                                                   |\n| /=     | SlashEq    | [Division assignment](expressions/operator-expr.html#compound-assignment-expressions)                                                                                                                                                                                                                                         |\n| %=     | PercentEq  | [Remainder assignment](expressions/operator-expr.html#compound-assignment-expressions)                                                                                                                                                                                                                                        |\n| ^=     | CaretEq    | [Bitwise XOR assignment](expressions/operator-expr.html#compound-assignment-expressions)                                                                                                                                                                                                                                      |\n| &=     | AndEq      | [Bitwise And assignment](expressions/operator-expr.html#compound-assignment-expressions)                                                                                                                                                                                                                                      |\n| \\|=    | OrEq       | [Bitwise Or assignment](expressions/operator-expr.html#compound-assignment-expressions)                                                                                                                                                                                                                                       |\n| <<=    | ShlEq      | [Shift Left assignment](expressions/operator-expr.html#compound-assignment-expressions)                                                                                                                                                                                                                                       |\n| \\>>=   | ShrEq      | [Shift Right assignment](expressions/operator-expr.html#compound-assignment-expressions), [Nested Generics](items/generics.html)                                                                                                                                                                                              |\n| \\=     | Eq         | [Assignment](expressions/operator-expr.html#assignment-expressions), [Attributes](attributes.html), Various type definitions                                                                                                                                                                                                  |\n| \\==    | EqEq       | [Equal](expressions/operator-expr.html#comparison-operators)                                                                                                                                                                                                                                                                  |\n| !=     | Ne         | [Not Equal](expressions/operator-expr.html#comparison-operators)                                                                                                                                                                                                                                                              |\n| \\>     | Gt         | [Greater than](expressions/operator-expr.html#comparison-operators), [Generics](items/generics.html), [Paths](paths.html)                                                                                                                                                                                                     |\n| <      | Lt         | [Less than](expressions/operator-expr.html#comparison-operators), [Generics](items/generics.html), [Paths](paths.html)                                                                                                                                                                                                        |\n| \\>=    | Ge         | [Greater than or equal to](expressions/operator-expr.html#comparison-operators), [Generics](items/generics.html)                                                                                                                                                                                                              |\n| <=     | Le         | [Less than or equal to](expressions/operator-expr.html#comparison-operators)                                                                                                                                                                                                                                                  |\n| @      | At         | [Subpattern binding](patterns.html#identifier-patterns)                                                                                                                                                                                                                                                                       |\n| \\_     | Underscore | [Wildcard patterns](patterns.html#wildcard-pattern), [Inferred types](types/inferred.html), Unnamed items in [constants](items/constant-items.html), [extern crates](items/extern-crates.html), [use declarations](items/use-declarations.html), and [destructuring assignment](expressions/underscore-expr.html)             |\n| .      | Dot        | [Field access](expressions/field-expr.html), [Tuple index](expressions/tuple-expr.html#tuple-indexing-expressions)                                                                                                                                                                                                            |\n| ..     | DotDot     | [Range](expressions/range-expr.html), [Struct expressions](expressions/struct-expr.html), [Patterns](patterns.html), [Range Patterns](patterns.html#range-patterns)                                                                                                                                                           |\n| ...    | DotDotDot  | [Variadic functions](items/external-blocks.html), [Range patterns](patterns.html#range-patterns)                                                                                                                                                                                                                              |\n| ..=    | DotDotEq   | [Inclusive Range](expressions/range-expr.html), [Range patterns](patterns.html#range-patterns)                                                                                                                                                                                                                                |\n| ,      | Comma      | Various separators                                                                                                                                                                                                                                                                                                            |\n| ;      | Semi       | Terminator for various items and statements, [Array types](types/array.html)                                                                                                                                                                                                                                                  |\n| :      | Colon      | Various separators                                                                                                                                                                                                                                                                                                            |\n| ::     | PathSep    | [Path separator](paths.html)                                                                                                                                                                                                                                                                                                  |\n| \\->    | RArrow     | [Function return type](items/functions.html), [Closure return type](expressions/closure-expr.html), [Function pointer type](types/function-pointer.html)                                                                                                                                                                      |\n| \\=>    | FatArrow   | [Match arms](expressions/match-expr.html), [Macros](macros-by-example.html)                                                                                                                                                                                                                                                   |\n| #      | Pound      | [Attributes](attributes.html)                                                                                                                                                                                                                                                                                                 |\n| $      | Dollar     | [Macros](macros-by-example.html)                                                                                                                                                                                                                                                                                              |\n| ?      | Question   | [Question mark operator](expressions/operator-expr.html#the-question-mark-operator), [Questionably sized](trait-bounds.html#sized), [Macro Kleene Matcher](macros-by-example.html)                                                                                                                                            |\n| \\~     | Tilde      | The tilde operator has been unused since before Rust 1.0, but its token may still be used                                                                                                                                                                                                                                     |\n\n## [Delimiters](#delimiters)\n\nBracket punctuation is used in various parts of the grammar. An open bracket must always be paired with a close bracket. Brackets and the tokens within them are referred to as \"token trees\" in [macros](macros-by-example.html). The three types of brackets are:\n\n| Bracket | Type            |\n| ------- | --------------- |\n| { }     | Curly braces    |\n| \\[ \\]   | Square brackets |\n| ( )     | Parentheses     |\n\n## [Reserved prefixes](#reserved-prefixes)\n\n> **Lexer 2021+**  \n> RESERVED\\_TOKEN\\_DOUBLE\\_QUOTE : ( IDENTIFIER\\_OR\\_KEYWORD _Except `b` or `r` or `br`_ | `_` ) `\"`  \n> RESERVED\\_TOKEN\\_SINGLE\\_QUOTE : ( IDENTIFIER\\_OR\\_KEYWORD _Except `b`_ | `_` ) `'`  \n> RESERVED\\_TOKEN\\_POUND : ( IDENTIFIER\\_OR\\_KEYWORD _Except `r` or `br`_ | `_` ) `#`\n\nSome lexical forms known as _reserved prefixes_ are reserved for future use.\n\nSource input which would otherwise be lexically interpreted as a non-raw identifier (or a keyword or `_`) which is immediately followed by a `#`, `'`, or `\"` character (without intervening whitespace) is identified as a reserved prefix.\n\nNote that raw identifiers, raw string literals, and raw byte string literals may contain a `#` character but are not interpreted as containing a reserved prefix.\n\nSimilarly the `r`, `b`, and `br` prefixes used in raw string literals, byte literals, byte string literals, and raw byte string literals are not interpreted as reserved prefixes.\n\n> **Edition Differences**: Starting with the 2021 edition, reserved prefixes are reported as an error by the lexer (in particular, they cannot be passed to macros).\n> \n> Before the 2021 edition, reserved prefixes are accepted by the lexer and interpreted as multiple tokens (for example, one token for the identifier or keyword, followed by a `#` token).\n> \n> Examples accepted in all editions:\n> \n> ```rust\n> #![allow(unused)]\n> fn main() {\n> macro_rules! lexes {($($_:tt)*) => {}}\n> lexes!{a #foo}\n> lexes!{continue 'foo}\n> lexes!{match \"...\" {}}\n> lexes!{r#let#foo}         // three tokens: r#let # foo\n> }\n> ```\n> \n> Examples accepted before the 2021 edition but rejected later:\n> \n> ```rust\n> #![allow(unused)]\n> fn main() {\n> macro_rules! lexes {($($_:tt)*) => {}}\n> lexes!{a#foo}\n> lexes!{continue'foo}\n> lexes!{match\"...\" {}}\n> }\n> ```\n\n[ ](whitespace.html \"Previous chapter\") [ ](macros.html \"Next chapter\") "}