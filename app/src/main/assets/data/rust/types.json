{"lang":"Rust","fullPath":"/types","category":"","title":"types.html","url":"https://doc.rust-lang.org/stable/reference/types.html","markdown":"# [Types](#types)\n\nEvery variable, item, and value in a Rust program has a type. The _type_ of a_value_ defines the interpretation of the memory holding it and the operations that may be performed on the value.\n\nBuilt-in types are tightly integrated into the language, in nontrivial ways that are not possible to emulate in user-defined types. User-defined types have limited capabilities.\n\nThe list of types is:\n\n* Primitive types:  \n   * [Boolean](types/boolean.html) — `bool`  \n   * [Numeric](types/numeric.html) — integer and float  \n   * [Textual](types/textual.html) — `char` and `str`  \n   * [Never](types/never.html) — `!` — a type with no values\n* Sequence types:  \n   * [Tuple](types/tuple.html)  \n   * [Array](types/array.html)  \n   * [Slice](types/slice.html)\n* User-defined types:  \n   * [Struct](types/struct.html)  \n   * [Enum](types/enum.html)  \n   * [Union](types/union.html)\n* Function types:  \n   * [Functions](types/function-item.html)  \n   * [Closures](types/closure.html)\n* Pointer types:  \n   * [References](types/pointer.html#shared-references-)  \n   * [Raw pointers](types/pointer.html#raw-pointers-const-and-mut)  \n   * [Function pointers](types/function-pointer.html)\n* Trait types:  \n   * [Trait objects](types/trait-object.html)  \n   * [Impl trait](types/impl-trait.html)\n\n## [Type expressions](#type-expressions)\n\n> **Syntax**  \n> _Type_ :  \n> _TypeNoBounds_  \n> | [_ImplTraitType_](types/impl-trait.html)  \n> | [_TraitObjectType_](types/trait-object.html)\n> \n> _TypeNoBounds_ :  \n> [_ParenthesizedType_](types.html#parenthesized-types)  \n> | [_ImplTraitTypeOneBound_](types/impl-trait.html)  \n> | [_TraitObjectTypeOneBound_](types/trait-object.html)  \n> | [_TypePath_](paths.html#paths-in-types)  \n> | [_TupleType_](types/tuple.html#tuple-types)  \n> | [_NeverType_](types/never.html)  \n> | [_RawPointerType_](types/pointer.html#raw-pointers-const-and-mut)  \n> | [_ReferenceType_](types/pointer.html#shared-references-)  \n> | [_ArrayType_](types/array.html)  \n> | [_SliceType_](types/slice.html)  \n> | [_InferredType_](types/inferred.html)  \n> | [_QualifiedPathInType_](paths.html#qualified-paths)  \n> | [_BareFunctionType_](types/function-pointer.html)  \n> | [_MacroInvocation_](macros.html#macro-invocation)\n\nA _type expression_ as defined in the _Type_ grammar rule above is the syntax for referring to a type. It may refer to:\n\n* Sequence types ([tuple](types/tuple.html), [array](types/array.html), [slice](types/slice.html)).\n* [Type paths](paths.html#paths-in-types) which can reference:  \n   * Primitive types ([boolean](types/boolean.html), [numeric](types/numeric.html), [textual](types/textual.html)).  \n   * Paths to an [item](items.html) ([struct](types/struct.html), [enum](types/enum.html), [union](types/union.html), [type alias](items/type-aliases.html), [trait](types/trait-object.html)).  \n   * [Self path](paths.html#self-1) where `Self` is the implementing type.  \n   * Generic [type parameters](types/parameters.html).\n* Pointer types ([reference](types/pointer.html#shared-references-), [raw pointer](types/pointer.html#raw-pointers-const-and-mut), [function pointer](types/function-pointer.html)).\n* The [inferred type](types/inferred.html) which asks the compiler to determine the type.\n* [Parentheses](#parenthesized-types) which are used for disambiguation.\n* Trait types: [Trait objects](types/trait-object.html) and [impl trait](types/impl-trait.html).\n* The [never](types/never.html) type.\n* [Macros](macros.html) which expand to a type expression.\n\n### [Parenthesized types](#parenthesized-types)\n\n> _ParenthesizedType_ :  \n> `(` [_Type_](types.html#type-expressions) `)`\n\nIn some situations the combination of types may be ambiguous. Use parentheses around a type to avoid ambiguity. For example, the `+` operator for [type boundaries](trait-bounds.html) within a [reference type](types/pointer.html#shared-references-) is unclear where the boundary applies, so the use of parentheses is required. Grammar rules that require this disambiguation use the [_TypeNoBounds_](types.html#type-expressions) rule instead of[_Type_](types.html#type-expressions).\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::any::Any;\ntype T<'a> = &'a (dyn Any + Send);\n}\n```\n\n## [Recursive types](#recursive-types)\n\nNominal types — [structs](types/struct.html), [enumerations](types/enum.html), and [unions](types/union.html) — may be recursive. That is, each `enum` variant or `struct` or `union` field may refer, directly or indirectly, to the enclosing `enum` or `struct` type itself. Such recursion has restrictions:\n\n* Recursive types must include a nominal type in the recursion (not mere [type aliases](items/type-aliases.html), or other structural types such as [arrays](types/array.html) or [tuples](types/tuple.html)). So `type Rec = &'static [Rec]` is not allowed.\n* The size of a recursive type must be finite; in other words the recursive fields of the type must be [pointer types](types/pointer.html).\n\nAn example of a _recursive_ type and its use:\n\n```rust\n#![allow(unused)]\nfn main() {\nenum List<T> {\n    Nil,\n    Cons(T, Box<List<T>>)\n}\n\nlet a: List<i32> = List::Cons(7, Box::new(List::Cons(13, Box::new(List::Nil))));\n}\n```\n\n[ ](type-system.html \"Previous chapter\") [ ](types/boolean.html \"Next chapter\") "}