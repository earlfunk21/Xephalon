{"lang":"Rust","fullPath":"/dynamically-sized-types","category":"","title":"dynamically-sized-types.html","url":"https://doc.rust-lang.org/stable/reference/dynamically-sized-types.html","markdown":"# [Dynamically Sized Types](#dynamically-sized-types)\n\nMost types have a fixed size that is known at compile time and implement the trait [Sized](special-types-and-traits.html#sized). A type with a size that is known only at run-time is called a _dynamically sized type_ (_DST_) or, informally, an unsized type.[Slices](types/slice.html) and [trait objects](types/trait-object.html) are two examples of DSTs. Such types can only be used in certain cases:\n\n* [Pointer types](types/pointer.html) to DSTs are sized but have twice the size of pointers to sized types  \n   * Pointers to slices also store the number of elements of the slice.  \n   * Pointers to trait objects also store a pointer to a vtable.\n* DSTs can be provided as type arguments to generic type parameters having the special `?Sized` bound. They can also be used for associated type definitions when the corresponding associated type declaration has a `?Sized` bound. By default, any type parameter or associated type has a `Sized` bound, unless it is relaxed using `?Sized`.\n* Traits may be implemented for DSTs. Unlike with generic type parameters, `Self: ?Sized` is the default in trait definitions.\n* Structs may contain a DST as the last field; this makes the struct itself aDST.\n\n> **Note**: [variables](variables.html), function parameters, [const](items/constant-items.html) items, and [static](items/static-items.html) items must be`Sized`.\n\n[ ](types/inferred.html \"Previous chapter\") [ ](type-layout.html \"Next chapter\") "}