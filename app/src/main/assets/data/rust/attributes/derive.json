{"lang":"Rust","fullPath":"/attributes/derive","category":"attributes","title":"derive","url":"https://doc.rust-lang.org/stable/reference/attributes/derive.html","markdown":"# [Derive](#derive)\n\nThe _`derive` attribute_ allows new [items](../items.html) to be automatically generated for data structures. It uses the [_MetaListPaths_](../attributes.html#meta-item-attribute-syntax) syntax to specify a list of traits to implement or paths to [derive macros](../procedural-macros.html#derive-macros) to process.\n\nFor example, the following will create an [impl item](../items/implementations.html) for the[PartialEq](../../std/cmp/trait.PartialEq.html) and [Clone](../../std/clone/trait.Clone.html) traits for `Foo`, and the type parameter `T` will be given the `PartialEq` or `Clone` constraints for the appropriate `impl`:\n\n```rust\n#![allow(unused)]\nfn main() {\n#[derive(PartialEq, Clone)]\nstruct Foo<T> {\n    a: i32,\n    b: T,\n}\n}\n```\n\nThe generated `impl` for `PartialEq` is equivalent to\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct Foo<T> { a: i32, b: T }\nimpl<T: PartialEq> PartialEq for Foo<T> {\n    fn eq(&self, other: &Foo<T>) -> bool {\n        self.a == other.a && self.b == other.b\n    }\n}\n}\n```\n\nYou can implement `derive` for your own traits through [procedural macros](../procedural-macros.html#derive-macros).\n\n## [The automatically\\_derived attribute](#the-automatically%5Fderived-attribute)\n\nThe _`automaticallyderived` attribute_ is automatically added to[implementations](../items/implementations.html) created by the `derive` attribute for built-in traits. It has no direct effect, but it may be used by tools and diagnostic lints to detect these automatically generated implementations.\n\n[ ](../attributes/testing.html \"Previous chapter\") [ ](../attributes/diagnostics.html \"Next chapter\") "}