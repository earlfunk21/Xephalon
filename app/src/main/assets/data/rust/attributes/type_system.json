{"lang":"Rust","fullPath":"/attributes/type_system","category":"attributes","title":"type_system","url":"https://doc.rust-lang.org/stable/reference/attributes/type_system.html","markdown":"# [Type system attributes](#type-system-attributes)\n\nThe following [attributes](../attributes.html) are used for changing how a type can be used.\n\n## [The non\\_exhaustive attribute](#the-non%5Fexhaustive-attribute)\n\nThe _`nonexhaustive` attribute_ indicates that a type or variant may have more fields or variants added in the future. It can be applied to[structs](../items/structs.html), [enums](../items/enumerations.html), and `enum` variants.\n\nThe `non_exhaustive` attribute uses the [_MetaWord_](../attributes.html#meta-item-attribute-syntax) syntax and thus does not take any inputs.\n\nWithin the defining crate, `non_exhaustive` has no effect.\n\n```rust\n#![allow(unused)]\nfn main() {\n#[non_exhaustive]\npub struct Config {\n    pub window_width: u16,\n    pub window_height: u16,\n}\n\n#[non_exhaustive]\npub enum Error {\n    Message(String),\n    Other,\n}\n\npub enum Message {\n    #[non_exhaustive] Send { from: u32, to: u32, contents: String },\n    #[non_exhaustive] Reaction(u32),\n    #[non_exhaustive] Quit,\n}\n\n// Non-exhaustive structs can be constructed as normal within the defining crate.\nlet config = Config { window_width: 640, window_height: 480 };\n\n// Non-exhaustive structs can be matched on exhaustively within the defining crate.\nif let Config { window_width, window_height } = config {\n    // ...\n}\n\nlet error = Error::Other;\nlet message = Message::Reaction(3);\n\n// Non-exhaustive enums can be matched on exhaustively within the defining crate.\nmatch error {\n    Error::Message(ref s) => { },\n    Error::Other => { },\n}\n\nmatch message {\n    // Non-exhaustive variants can be matched on exhaustively within the defining crate.\n    Message::Send { from, to, contents } => { },\n    Message::Reaction(id) => { },\n    Message::Quit => { },\n}\n}\n```\n\nOutside of the defining crate, types annotated with `non_exhaustive` have limitations that preserve backwards compatibility when new fields or variants are added.\n\nNon-exhaustive types cannot be constructed outside of the defining crate:\n\n* Non-exhaustive variants ([struct](../items/structs.html) or [enum variant](../items/enumerations.html)) cannot be constructed with a [_StructExpression_](../expressions/struct-expr.html) (including with [functional update syntax](../expressions/struct-expr.html#functional-update-syntax)).\n* [enum](../items/enumerations.html) instances can be constructed.\n\n```rust\n// `Config`, `Error`, and `Message` are types defined in an upstream crate that have been\n// annotated as `#[non_exhaustive]`.\nuse upstream::{Config, Error, Message};\n\n// Cannot construct an instance of `Config`, if new fields were added in\n// a new version of `upstream` then this would fail to compile, so it is\n// disallowed.\nlet config = Config { window_width: 640, window_height: 480 };\n\n// Can construct an instance of `Error`, new variants being introduced would\n// not result in this failing to compile.\nlet error = Error::Message(\"foo\".to_string());\n\n// Cannot construct an instance of `Message::Send` or `Message::Reaction`,\n// if new fields were added in a new version of `upstream` then this would\n// fail to compile, so it is disallowed.\nlet message = Message::Send { from: 0, to: 1, contents: \"foo\".to_string(), };\nlet message = Message::Reaction(0);\n\n// Cannot construct an instance of `Message::Quit`, if this were converted to\n// a tuple-variant `upstream` then this would fail to compile.\nlet message = Message::Quit;\n```\n\nThere are limitations when matching on non-exhaustive types outside of the defining crate:\n\n* When pattern matching on a non-exhaustive variant ([struct](../items/structs.html) or [enum variant](../items/enumerations.html)), a [_StructPattern_](../patterns.html#struct-patterns) must be used which must include a `..`. Tuple variant constructor visibility is lowered to `min($vis, pub(crate))`.\n* When pattern matching on a non-exhaustive [enum](../items/enumerations.html), matching on a variant does not contribute towards the exhaustiveness of the arms.\n\n```rust\n// `Config`, `Error`, and `Message` are types defined in an upstream crate that have been\n// annotated as `#[non_exhaustive]`.\nuse upstream::{Config, Error, Message};\n\n// Cannot match on a non-exhaustive enum without including a wildcard arm.\nmatch error {\n  Error::Message(ref s) => { },\n  Error::Other => { },\n  // would compile with: `_ => {},`\n}\n\n// Cannot match on a non-exhaustive struct without a wildcard.\nif let Ok(Config { window_width, window_height }) = config {\n    // would compile with: `..`\n}\n\nmatch message {\n  // Cannot match on a non-exhaustive struct enum variant without including a wildcard.\n  Message::Send { from, to, contents } => { },\n  // Cannot match on a non-exhaustive tuple or unit enum variant.\n  Message::Reaction(type) => { },\n  Message::Quit => { },\n}\n```\n\nIt's also not allowed to cast non-exhaustive types from foreign crates.\n\n```rust\nuse othercrate::NonExhaustiveEnum;\n\n// Cannot cast a non-exhaustive enum outside of its defining crate.\nlet _ = NonExhaustiveEnum::default() as u8;\n```\n\nNon-exhaustive types are always considered inhabited in downstream crates.\n\n[ ](../attributes/limits.html \"Previous chapter\") [ ](../statements-and-expressions.html \"Next chapter\") "}