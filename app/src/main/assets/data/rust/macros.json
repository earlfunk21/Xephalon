{"lang":"Rust","fullPath":"/macros","category":"","title":"macros.html","url":"https://doc.rust-lang.org/stable/reference/macros.html","markdown":"# [Macros](#macros)\n\nThe functionality and syntax of Rust can be extended with custom definitions called macros. They are given names, and invoked through a consistent syntax: `some_extension!(...)`.\n\nThere are two ways to define new macros:\n\n* [Macros by Example](macros-by-example.html) define new syntax in a higher-level, declarative way.\n* [Procedural Macros](procedural-macros.html) define function-like macros, custom derives, and custom attributes using functions that operate on input tokens.\n\n## [Macro Invocation](#macro-invocation)\n\n> **Syntax**  \n> _MacroInvocation_ :  \n> [_SimplePath_](paths.html#simple-paths) `!` _DelimTokenTree_\n> \n> _DelimTokenTree_ :  \n> `(` _TokenTree_\\* `)`  \n> | `[` _TokenTree_\\* `]`  \n> | `{` _TokenTree_\\* `}`\n> \n> _TokenTree_ :  \n> [_Token_](tokens.html)_except [delimiters](tokens.html#delimiters)_ | _DelimTokenTree_\n> \n> _MacroInvocationSemi_ :  \n> [_SimplePath_](paths.html#simple-paths) `!` `(` _TokenTree_\\* `)` `;`  \n> | [_SimplePath_](paths.html#simple-paths) `!` `[` _TokenTree_\\* `]` `;`  \n> | [_SimplePath_](paths.html#simple-paths) `!` `{` _TokenTree_\\* `}`\n\nA macro invocation expands a macro at compile time and replaces the invocation with the result of the macro. Macros may be invoked in the following situations:\n\n* [Expressions](expressions.html) and [statements](statements.html)\n* [Patterns](patterns.html)\n* [Types](types.html)\n* [Items](items.html) including [associated items](items/associated-items.html)\n* [macro\\_rules](macros-by-example.html) transcribers\n* [External blocks](items/external-blocks.html)\n\nWhen used as an item or a statement, the _MacroInvocationSemi_ form is used where a semicolon is required at the end when not using curly braces.[Visibility qualifiers](visibility-and-privacy.html) are never allowed before a macro invocation or[macro\\_rules](macros-by-example.html) definition.\n\n```rust\n#![allow(unused)]\nfn main() {\n// Used as an expression.\nlet x = vec![1,2,3];\n\n// Used as a statement.\nprintln!(\"Hello!\");\n\n// Used in a pattern.\nmacro_rules! pat {\n    ($i:ident) => (Some($i))\n}\n\nif let pat!(x) = Some(1) {\n    assert_eq!(x, 1);\n}\n\n// Used in a type.\nmacro_rules! Tuple {\n    { $A:ty, $B:ty } => { ($A, $B) };\n}\n\ntype N2 = Tuple!(i32, i32);\n\n// Used as an item.\nuse std::cell::RefCell;\nthread_local!(static FOO: RefCell<u32> = RefCell::new(1));\n\n// Used as an associated item.\nmacro_rules! const_maker {\n    ($t:ty, $v:tt) => { const CONST: $t = $v; };\n}\ntrait T {\n    const_maker!{i32, 7}\n}\n\n// Macro calls within macros.\nmacro_rules! example {\n    () => { println!(\"Macro call in a macro!\") };\n}\n// Outer macro `example` is expanded, then inner macro `println` is expanded.\nexample!();\n}\n```\n\n[ ](tokens.html \"Previous chapter\") [ ](macros-by-example.html \"Next chapter\") "}