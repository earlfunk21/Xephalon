{"lang":"Rust","fullPath":"/behavior-not-considered-unsafe","category":"","title":"behavior-not-considered-unsafe.html","url":"https://doc.rust-lang.org/stable/reference/behavior-not-considered-unsafe.html","markdown":"## [Behavior not considered unsafe](#behavior-not-considered-unsafe)\n\nThe Rust compiler does not consider the following behaviors _unsafe_, though a programmer may (should) find them undesirable, unexpected, or erroneous.\n\n##### [Deadlocks](#deadlocks)\n\n##### [Leaks of memory and other resources](#leaks-of-memory-and-other-resources)\n\n##### [Exiting without calling destructors](#exiting-without-calling-destructors)\n\n##### [Exposing randomized base addresses through pointer leaks](#exposing-randomized-base-addresses-through-pointer-leaks)\n\n##### [Integer overflow](#integer-overflow)\n\nIf a program contains arithmetic overflow, the programmer has made an error. In the following discussion, we maintain a distinction between arithmetic overflow and wrapping arithmetic. The first is erroneous, while the second is intentional.\n\nWhen the programmer has enabled `debug_assert!` assertions (for example, by enabling a non-optimized build), implementations must insert dynamic checks that `panic` on overflow. Other kinds of builds may result in `panics` or silently wrapped values on overflow, at the implementation's discretion.\n\nIn the case of implicitly-wrapped overflow, implementations must provide well-defined (even if still considered erroneous) results by using two's complement overflow conventions.\n\nThe integral types provide inherent methods to allow programmers explicitly to perform wrapping arithmetic. For example,`i32::wrapping_add` provides two's complement, wrapping addition.\n\nThe standard library also provides a `Wrapping<T>` newtype which ensures all standard arithmetic operations for `T` have wrapping semantics.\n\nSee [RFC 560](https://github.com/rust-lang/rfcs/blob/master/text/0560-integer-overflow.md) for error conditions, rationale, and more details about integer overflow.\n\n##### [Logic errors](#logic-errors)\n\nSafe code may impose extra logical constraints that can be checked at neither compile-time nor runtime. If a program breaks such a constraint, the behavior may be unspecified but will not result in undefined behavior. This could include panics, incorrect results, aborts, and non-termination. The behavior may also differ between runs, builds, or kinds of build.\n\nFor example, implementing both `Hash` and `Eq` requires that values considered equal have equal hashes. Another example are data structures like `BinaryHeap`, `BTreeMap`, `BTreeSet`, `HashMap` and `HashSet`which describe constraints on the modification of their keys while they are in the data structure. Violating such constraints is not considered unsafe, yet the program is considered erroneous and its behavior unpredictable.\n\n[ ](behavior-considered-undefined.html \"Previous chapter\") [ ](const%5Feval.html \"Next chapter\") "}