{"lang":"Rust","fullPath":"/items/external-blocks","category":"items","title":"external-blocks","url":"https://doc.rust-lang.org/stable/reference/items/external-blocks.html","markdown":"# [External blocks](#external-blocks)\n\n> **Syntax**  \n> _ExternBlock_ :  \n> `unsafe`? `extern` [_Abi_](functions.html)? `{`  \n> [_InnerAttribute_](../attributes.html)\\*  \n> _ExternalItem_\\*  \n> `}`\n> \n> _ExternalItem_ :  \n> [_OuterAttribute_](../attributes.html)\\* (  \n> [_MacroInvocationSemi_](../macros.html#macro-invocation)  \n> | ( [_Visibility_](../visibility-and-privacy.html)? ( [_StaticItem_](static-items.html) | [_Function_](functions.html) ) )  \n> )\n\nExternal blocks provide _declarations_ of items that are not _defined_ in the current crate and are the basis of Rust's foreign function interface. These are akin to unchecked imports.\n\nTwo kinds of item _declarations_ are allowed in external blocks: [functions](functions.html) and[statics](static-items.html). Calling functions or accessing statics that are declared in external blocks is only allowed in an `unsafe` context.\n\nThe `unsafe` keyword is syntactically allowed to appear before the `extern`keyword, but it is rejected at a semantic level. This allows macros to consume the syntax and make use of the `unsafe` keyword, before removing it from the token stream.\n\n## [Functions](#functions)\n\nFunctions within external blocks are declared in the same way as other Rust functions, with the exception that they must not have a body and are instead terminated by a semicolon. Patterns are not allowed in parameters, only[IDENTIFIER](../identifiers.html) or `_` may be used. Function qualifiers (`const`, `async`,`unsafe`, and `extern`) are not allowed.\n\nFunctions within external blocks may be called by Rust code, just like functions defined in Rust. The Rust compiler automatically translates between the Rust ABI and the foreign ABI.\n\nA function declared in an extern block is implicitly `unsafe`. When coerced to a function pointer, a function declared in an extern block has type `unsafe extern \"abi\" for<'l1, ..., 'lm> fn(A1, ..., An) -> R`, where `'l1`, ... `'lm`are its lifetime parameters, `A1`, ..., `An` are the declared types of its parameters and `R` is the declared return type.\n\n## [Statics](#statics)\n\nStatics within external blocks are declared in the same way as [statics](static-items.html) outside of external blocks, except that they do not have an expression initializing their value. It is `unsafe` to access a static item declared in an extern block, whether or not it's mutable, because there is nothing guaranteeing that the bit pattern at the static's memory is valid for the type it is declared with, since some arbitrary (e.g. C) code is in charge of initializing the static.\n\nExtern statics can be either immutable or mutable just like [statics](static-items.html) outside of external blocks. An immutable static _must_ be initialized before any Rust code is executed. It is not enough for the static to be initialized before Rust code reads from it.\n\n## [ABI](#abi)\n\nBy default external blocks assume that the library they are calling uses the standard C ABI on the specific platform. Other ABIs may be specified using an`abi` string, as shown here:\n\n```rust\n#![allow(unused)]\nfn main() {\n// Interface to the Windows API\nextern \"stdcall\" { }\n}\n```\n\nThere are three ABI strings which are cross-platform, and which all compilers are guaranteed to support:\n\n* `extern \"Rust\"` \\-- The default ABI when you write a normal `fn foo()` in any Rust code.\n* `extern \"C\"` \\-- This is the same as `extern fn foo()`; whatever the default your C compiler supports.\n* `extern \"system\"` \\-- Usually the same as `extern \"C\"`, except on Win32, in which case it's `\"stdcall\"`, or what you should use to link to the Windows API itself\n\nThere are also some platform-specific ABI strings:\n\n* `extern \"cdecl\"` \\-- The default for x86\\_32 C code.\n* `extern \"stdcall\"` \\-- The default for the Win32 API on x86\\_32.\n* `extern \"win64\"` \\-- The default for C code on x86\\_64 Windows.\n* `extern \"sysv64\"` \\-- The default for C code on non-Windows x86\\_64.\n* `extern \"aapcs\"` \\-- The default for ARM.\n* `extern \"fastcall\"` \\-- The `fastcall` ABI -- corresponds to MSVC's`__fastcall` and GCC and clang's `__attribute__((fastcall))`\n* `extern \"vectorcall\"` \\-- The `vectorcall` ABI -- corresponds to MSVC's`__vectorcall` and clang's `__attribute__((vectorcall))`\n* `extern \"efiapi\"` \\-- The ABI used for [UEFI](https://uefi.org/specifications) functions.\n\n## [Variadic functions](#variadic-functions)\n\nFunctions within external blocks may be variadic by specifying `...` as the last argument. There must be at least one parameter before the variadic parameter. The variadic parameter may optionally be specified with an identifier.\n\n```rust\n#![allow(unused)]\nfn main() {\nextern \"C\" {\n    fn foo(x: i32, ...);\n    fn with_name(format: *const u8, args: ...);\n}\n}\n```\n\n## [Attributes on extern blocks](#attributes-on-extern-blocks)\n\nThe following [attributes](../attributes.html) control the behavior of external blocks.\n\n### [The link attribute](#the-link-attribute)\n\nThe _`link` attribute_ specifies the name of a native library that the compiler should link with for the items within an `extern` block. It uses the[_MetaListNameValueStr_](../attributes.html#meta-item-attribute-syntax) syntax to specify its inputs. The `name` key is the name of the native library to link. The `kind` key is an optional value which specifies the kind of library with the following possible values:\n\n* `dylib` — Indicates a dynamic library. This is the default if `kind` is not specified.\n* `static` — Indicates a static library.\n* `framework` — Indicates a macOS framework. This is only valid for macOS targets.\n* `raw-dylib` — Indicates a dynamic library where the compiler will generate an import library to link against (see [dylib versus raw-dylib](#dylib-versus-raw-dylib) below for details). This is only valid for Windows targets.\n\nThe `name` key must be included if `kind` is specified.\n\nThe optional `modifiers` argument is a way to specify linking modifiers for the library to link. Modifiers are specified as a comma-delimited string with each modifier prefixed with either a `+` or `-` to indicate that the modifier is enabled or disabled, respectively. Specifying multiple `modifiers` arguments in a single `link` attribute, or multiple identical modifiers in the same `modifiers` argument is not currently supported.   \nExample: `#[link(name = \"mylib\", kind = \"static\", modifiers = \"+whole-archive\")`.\n\nThe `wasm_import_module` key may be used to specify the [WebAssembly module](https://webassembly.github.io/spec/core/syntax/modules.html)name for the items within an `extern` block when importing symbols from the host environment. The default module name is `env` if `wasm_import_module` is not specified.\n\n```rust\n#[link(name = \"crypto\")]\nextern {\n    // …\n}\n\n#[link(name = \"CoreFoundation\", kind = \"framework\")]\nextern {\n    // …\n}\n\n#[link(wasm_import_module = \"foo\")]\nextern {\n    // …\n}\n```\n\nIt is valid to add the `link` attribute on an empty extern block. You can use this to satisfy the linking requirements of extern blocks elsewhere in your code (including upstream crates) instead of adding the attribute to each extern block.\n\n#### [Linking modifiers: bundle](#linking-modifiers-bundle)\n\nThis modifier is only compatible with the `static` linking kind. Using any other kind will result in a compiler error.\n\nWhen building a rlib or staticlib `+bundle` means that the native static library will be packed into the rlib or staticlib archive, and then retrieved from there during linking of the final binary.\n\nWhen building a rlib `-bundle` means that the native static library is registered as a dependency of that rlib \"by name\", and object files from it are included only during linking of the final binary, the file search by that name is also performed during final linking.   \nWhen building a staticlib `-bundle` means that the native static library is simply not included into the archive and some higher level build system will need to add it later during linking of the final binary.\n\nThis modifier has no effect when building other targets like executables or dynamic libraries.\n\nThe default for this modifier is `+bundle`.\n\nMore implementation details about this modifier can be found in[bundle documentation for rustc](../../rustc/command-line-arguments.html#linking-modifiers-bundle).\n\n#### [Linking modifiers: whole-archive](#linking-modifiers-whole-archive)\n\nThis modifier is only compatible with the `static` linking kind. Using any other kind will result in a compiler error.\n\n`+whole-archive` means that the static library is linked as a whole archive without throwing any object files away.\n\nThe default for this modifier is `-whole-archive`.\n\nMore implementation details about this modifier can be found in[whole-archive documentation for rustc](../../rustc/command-line-arguments.html#linking-modifiers-whole-archive).\n\n### [Linking modifiers: verbatim](#linking-modifiers-verbatim)\n\nThis modifier is compatible with all linking kinds.\n\n`+verbatim` means that rustc itself won't add any target-specified library prefixes or suffixes (like `lib` or `.a`) to the library name, and will try its best to ask for the same thing from the linker.\n\n`-verbatim` means that rustc will either add a target-specific prefix and suffix to the library name before passing it to linker, or won't prevent linker from implicitly adding it.\n\nThe default for this modifier is `-verbatim`.\n\nMore implementation details about this modifier can be found in[verbatim documentation for rustc](../../rustc/command-line-arguments.html#linking-modifiers-verbatim).\n\n#### [dylib versus raw-dylib](#dylib-versus-raw-dylib)\n\nOn Windows, linking against a dynamic library requires that an import library is provided to the linker: this is a special static library that declares all of the symbols exported by the dynamic library in such a way that the linker knows that they have to be dynamically loaded at runtime.\n\nSpecifying `kind = \"dylib\"` instructs the Rust compiler to link an import library based on the `name` key. The linker will then use its normal library resolution logic to find that import library. Alternatively, specifying`kind = \"raw-dylib\"` instructs the compiler to generate an import library during compilation and provide that to the linker instead.\n\n`raw-dylib` is only supported on Windows and not supported on 32-bit x86 (`target_arch=\"x86\"`). Using it when targeting other platforms or x86 on Windows will result in a compiler error.\n\n### [The link\\_name attribute](#the-link%5Fname-attribute)\n\nThe _`linkname` attribute_ may be specified on declarations inside an `extern`block to indicate the symbol to import for the given function or static. It uses the [_MetaNameValueStr_](../attributes.html#meta-item-attribute-syntax) syntax to specify the name of the symbol.\n\n```rust\n#![allow(unused)]\nfn main() {\nextern {\n    #[link_name = \"actual_symbol_name\"]\n    fn name_in_rust();\n}\n}\n```\n\nUsing this attribute with the `link_ordinal` attribute will result in a compiler error.\n\n### [The link\\_ordinal attribute](#the-link%5Fordinal-attribute)\n\nThe _`linkordinal` attribute_ can be applied on declarations inside an `extern`block to indicate the numeric ordinal to use when generating the import library to link against. An ordinal is a unique number per symbol exported by a dynamic library on Windows and can be used when the library is being loaded to find that symbol rather than having to look it up by name.\n\nWarning: `link_ordinal` should only be used in cases where the ordinal of the symbol is known to be stable: if the ordinal of a symbol is not explicitly set when its containing binary is built then one will be automatically assigned to it, and that assigned ordinal may change between builds of the binary.\n\n```rust\n#[link(name = \"exporter\", kind = \"raw-dylib\")]\nextern \"stdcall\" {\n    #[link_ordinal(15)]\n    fn imported_function_stdcall(i: i32);\n}\n```\n\nThis attribute is only used with the `raw-dylib` linking kind. Using any other kind will result in a compiler error.\n\nUsing this attribute with the `link_name` attribute will result in a compiler error.\n\n### [Attributes on function parameters](#attributes-on-function-parameters)\n\nAttributes on extern function parameters follow the same rules and restrictions as [regular function parameters](functions.html#attributes-on-function-parameters).\n\n[ ](../items/implementations.html \"Previous chapter\") [ ](../items/generics.html \"Next chapter\") "}