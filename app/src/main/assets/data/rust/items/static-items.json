{"lang":"Rust","fullPath":"/items/static-items","category":"items","title":"static-items","url":"https://doc.rust-lang.org/stable/reference/items/static-items.html","markdown":"# [Static items](#static-items)\n\n> **Syntax**  \n> _StaticItem_ :  \n> `static` `mut`? [IDENTIFIER](../identifiers.html) `:` [_Type_](../types.html#type-expressions)( `=` [_Expression_](../expressions.html) )? `;`\n\nA _static item_ is similar to a [constant](constant-items.html), except that it represents a precise memory location in the program. All references to the static refer to the same memory location. Static items have the `static` lifetime, which outlives all other lifetimes in a Rust program. Static items do not call [drop](../destructors.html) at the end of the program.\n\nThe static initializer is a [constant expression](../const%5Feval.html#constant-expressions) evaluated at compile time. Static initializers may refer to other statics.\n\nNon-`mut` static items that contain a type that is not [interior mutable](../interior-mutability.html) may be placed in read-only memory.\n\nAll access to a static is safe, but there are a number of restrictions on statics:\n\n* The type must have the `Sync` trait bound to allow thread-safe access.\n* Constants cannot refer to statics.\n\nThe initializer expression must be omitted in an [external block](external-blocks.html), and must be provided for free static items.\n\n## [Statics & generics](#statics--generics)\n\nA static item defined in a generic scope (for example in a blanket or default implementation) will result in exactly one static item being defined, as if the static definition was pulled out of the current scope into the module. There will _not_ be one item per monomorphization.\n\nThis code:\n\n```rust\nuse std::sync::atomic::{AtomicUsize, Ordering};\n\ntrait Tr {\n    fn default_impl() {\n        static COUNTER: AtomicUsize = AtomicUsize::new(0);\n        println!(\"default_impl: counter was {}\", COUNTER.fetch_add(1, Ordering::Relaxed));\n    }\n\n    fn blanket_impl();\n}\n\nstruct Ty1 {}\nstruct Ty2 {}\n\nimpl<T> Tr for T {\n    fn blanket_impl() {\n        static COUNTER: AtomicUsize = AtomicUsize::new(0);\n        println!(\"blanket_impl: counter was {}\", COUNTER.fetch_add(1, Ordering::Relaxed));\n    }\n}\n\nfn main() {\n    <Ty1 as Tr>::default_impl();\n    <Ty2 as Tr>::default_impl();\n    <Ty1 as Tr>::blanket_impl();\n    <Ty2 as Tr>::blanket_impl();\n}\n```\n\nprints\n\n```text\ndefault_impl: counter was 0\ndefault_impl: counter was 1\nblanket_impl: counter was 0\nblanket_impl: counter was 1\n\n```\n\n## [Mutable statics](#mutable-statics)\n\nIf a static item is declared with the `mut` keyword, then it is allowed to be modified by the program. One of Rust's goals is to make concurrency bugs hard to run into, and this is obviously a very large source of race conditions or other bugs. For this reason, an `unsafe` block is required when either reading or writing a mutable static variable. Care should be taken to ensure that modifications to a mutable static are safe with respect to other threads running in the same process.\n\nMutable statics are still very useful, however. They can be used with C libraries and can also be bound from C libraries in an `extern` block.\n\n```rust\n#![allow(unused)]\nfn main() {\nfn atomic_add(_: &mut u32, _: u32) -> u32 { 2 }\n\nstatic mut LEVELS: u32 = 0;\n\n// This violates the idea of no shared state, and this doesn't internally\n// protect against races, so this function is `unsafe`\nunsafe fn bump_levels_unsafe1() -> u32 {\n    let ret = LEVELS;\n    LEVELS += 1;\n    return ret;\n}\n\n// Assuming that we have an atomic_add function which returns the old value,\n// this function is \"safe\" but the meaning of the return value may not be what\n// callers expect, so it's still marked as `unsafe`\nunsafe fn bump_levels_unsafe2() -> u32 {\n    return atomic_add(&mut LEVELS, 1);\n}\n}\n```\n\nMutable statics have the same restrictions as normal statics, except that the type does not have to implement the `Sync` trait.\n\n## [Using Statics or Consts](#using-statics-or-consts)\n\nIt can be confusing whether or not you should use a constant item or a static item. Constants should, in general, be preferred over statics unless one of the following are true:\n\n* Large amounts of data are being stored\n* The single-address property of statics is required.\n* Interior mutability is required.\n\n[ ](../items/constant-items.html \"Previous chapter\") [ ](../items/traits.html \"Next chapter\") "}