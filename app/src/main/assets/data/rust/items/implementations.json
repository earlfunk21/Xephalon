{"lang":"Rust","fullPath":"/items/implementations","category":"items","title":"implementations","url":"https://doc.rust-lang.org/stable/reference/items/implementations.html","markdown":"# [Implementations](#implementations)\n\n> **Syntax**  \n> _Implementation_ :  \n> _InherentImpl_ | _TraitImpl_\n> \n> _InherentImpl_ :  \n> `impl` [_GenericParams_](generics.html)? [_Type_](../types.html#type-expressions) [_WhereClause_](generics.html#where-clauses)? `{`  \n> [_InnerAttribute_](../attributes.html)\\*  \n> [_AssociatedItem_](associated-items.html)\\*  \n> `}`\n> \n> _TraitImpl_ :  \n> `unsafe`? `impl` [_GenericParams_](generics.html)? `!`? [_TypePath_](../paths.html#paths-in-types) `for` [_Type_](../types.html#type-expressions)  \n> [_WhereClause_](generics.html#where-clauses)?  \n> `{`  \n> [_InnerAttribute_](../attributes.html)\\*  \n> [_AssociatedItem_](associated-items.html)\\*  \n> `}`\n\nAn _implementation_ is an item that associates items with an _implementing type_. Implementations are defined with the keyword `impl` and contain functions that belong to an instance of the type that is being implemented or to the type statically.\n\nThere are two types of implementations:\n\n* inherent implementations\n* [trait](traits.html) implementations\n\n## [Inherent Implementations](#inherent-implementations)\n\nAn inherent implementation is defined as the sequence of the `impl` keyword, generic type declarations, a path to a nominal type, a where clause, and a bracketed set of associable items.\n\nThe nominal type is called the _implementing type_ and the associable items are the _associated items_ to the implementing type.\n\nInherent implementations associate the contained items to the implementing type. Inherent implementations can contain [associated functions](associated-items.html#associated-functions-and-methods) (including [methods](associated-items.html#methods)) and [associated constants](associated-items.html#associated-constants). They cannot contain associated type aliases.\n\nThe [path](../paths.html) to an associated item is any path to the implementing type, followed by the associated item's identifier as the final path component.\n\nA type can also have multiple inherent implementations. An implementing type must be defined within the same crate as the original type definition.\n\n```rust\npub mod color {\n    pub struct Color(pub u8, pub u8, pub u8);\n\n    impl Color {\n        pub const WHITE: Color = Color(255, 255, 255);\n    }\n}\n\nmod values {\n    use super::color::Color;\n    impl Color {\n        pub fn red() -> Color {\n            Color(255, 0, 0)\n        }\n    }\n}\n\npub use self::color::Color;\nfn main() {\n    // Actual path to the implementing type and impl in the same module.\n    color::Color::WHITE;\n\n    // Impl blocks in different modules are still accessed through a path to the type.\n    color::Color::red();\n\n    // Re-exported paths to the implementing type also work.\n    Color::red();\n\n    // Does not work, because use in `values` is not pub.\n    // values::Color::red();\n}\n```\n\n## [Trait Implementations](#trait-implementations)\n\nA _trait implementation_ is defined like an inherent implementation except that the optional generic type declarations are followed by a [trait](traits.html), followed by the keyword `for`, followed by a path to a nominal type.\n\nThe trait is known as the _implemented trait_. The implementing type implements the implemented trait.\n\nA trait implementation must define all non-default associated items declared by the implemented trait, may redefine default associated items defined by the implemented trait, and cannot define any other items.\n\nThe path to the associated items is `<` followed by a path to the implementing type followed by `as` followed by a path to the trait followed by `>` as a path component followed by the associated item's path component.\n\n[Unsafe traits](traits.html#unsafe-traits) require the trait implementation to begin with the `unsafe`keyword.\n\n```rust\n#![allow(unused)]\nfn main() {\n#[derive(Copy, Clone)]\nstruct Point {x: f64, y: f64};\ntype Surface = i32;\nstruct BoundingBox {x: f64, y: f64, width: f64, height: f64};\ntrait Shape { fn draw(&self, s: Surface); fn bounding_box(&self) -> BoundingBox; }\nfn do_draw_circle(s: Surface, c: Circle) { }\nstruct Circle {\n    radius: f64,\n    center: Point,\n}\n\nimpl Copy for Circle {}\n\nimpl Clone for Circle {\n    fn clone(&self) -> Circle { *self }\n}\n\nimpl Shape for Circle {\n    fn draw(&self, s: Surface) { do_draw_circle(s, *self); }\n    fn bounding_box(&self) -> BoundingBox {\n        let r = self.radius;\n        BoundingBox {\n            x: self.center.x - r,\n            y: self.center.y - r,\n            width: 2.0 * r,\n            height: 2.0 * r,\n        }\n    }\n}\n}\n```\n\n### [Trait Implementation Coherence](#trait-implementation-coherence)\n\nA trait implementation is considered incoherent if either the orphan rules check fails or there are overlapping implementation instances.\n\nTwo trait implementations overlap when there is a non-empty intersection of the traits the implementation is for, the implementations can be instantiated with the same type. \n\n#### [Orphan rules](#orphan-rules)\n\nGiven `impl<P1..=Pn> Trait<T1..=Tn> for T0`, an `impl` is valid only if at least one of the following is true:\n\n* `Trait` is a [local trait](../glossary.html#local-trait)\n* All of  \n   * At least one of the types `T0..=Tn` must be a [local type](../glossary.html#local-type). Let `Ti` be the first such type.  \n   * No [uncovered type](../glossary.html#uncovered-type) parameters `P1..=Pn` may appear in `T0..Ti` (excluding`Ti`)\n\nOnly the appearance of _uncovered_ type parameters is restricted. Note that for the purposes of coherence, [fundamental types](../glossary.html#fundamental-type-constructors) are special. The `T` in `Box<T>` is not considered covered, and `Box<LocalType>`is considered local.\n\n## [Generic Implementations](#generic-implementations)\n\nAn implementation can take [generic parameters](generics.html), which can be used in the rest of the implementation. Implementation parameters are written directly after the`impl` keyword.\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait Seq<T> { fn dummy(&self, _: T) { } }\nimpl<T> Seq<T> for Vec<T> {\n    /* ... */\n}\nimpl Seq<bool> for u32 {\n    /* Treat the integer as a sequence of bits */\n}\n}\n```\n\nGeneric parameters _constrain_ an implementation if the parameter appears at least once in one of:\n\n* The implemented trait, if it has one\n* The implementing type\n* As an [associated type](associated-items.html#associated-types) in the [bounds](../trait-bounds.html) of a type that contains another parameter that constrains the implementation\n\nType and const parameters must always constrain the implementation. Lifetimes must constrain the implementation if the lifetime is used in an associated type.\n\nExamples of constraining situations:\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait Trait{}\ntrait GenericTrait<T> {}\ntrait HasAssocType { type Ty; }\nstruct Struct;\nstruct GenericStruct<T>(T);\nstruct ConstGenericStruct<const N: usize>([(); N]);\n// T constrains by being an argument to GenericTrait.\nimpl<T> GenericTrait<T> for i32 { /* ... */ }\n\n// T constrains by being an arguement to GenericStruct\nimpl<T> Trait for GenericStruct<T> { /* ... */ }\n\n// Likewise, N constrains by being an argument to ConstGenericStruct\nimpl<const N: usize> Trait for ConstGenericStruct<N> { /* ... */ }\n\n// T constrains by being in an associated type in a bound for type `U` which is\n// itself a generic parameter constraining the trait.\nimpl<T, U> GenericTrait<U> for u32 where U: HasAssocType<Ty = T> { /* ... */ }\n\n// Like previous, except the type is `(U, isize)`. `U` appears inside the type\n// that includes `T`, and is not the type itself.\nimpl<T, U> GenericStruct<U> where (U, isize): HasAssocType<Ty = T> { /* ... */ }\n}\n```\n\nExamples of non-constraining situations:\n\n```rust\n#![allow(unused)]\nfn main() {\n// The rest of these are errors, since they have type or const parameters that\n// do not constrain.\n\n// T does not constrain since it does not appear at all.\nimpl<T> Struct { /* ... */ }\n\n// N does not constrain for the same reason.\nimpl<const N: usize> Struct { /* ... */ }\n\n// Usage of T inside the implementation does not constrain the impl.\nimpl<T> Struct {\n    fn uses_t(t: &T) { /* ... */ }\n}\n\n// T is used as an associated type in the bounds for U, but U does not constrain.\nimpl<T, U> Struct where U: HasAssocType<Ty = T> { /* ... */ }\n\n// T is used in the bounds, but not as an associated type, so it does not constrain.\nimpl<T, U> GenericTrait<U> for u32 where U: GenericTrait<T> {}\n}\n```\n\nExample of an allowed unconstraining lifetime parameter:\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct Struct;\nimpl<'a> Struct {}\n}\n```\n\nExample of a disallowed unconstraining lifetime parameter:\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct Struct;\ntrait HasAssocType { type Ty; }\nimpl<'a> HasAssocType for Struct {\n    type Ty = &'a Struct;\n}\n}\n```\n\n## [Attributes on Implementations](#attributes-on-implementations)\n\nImplementations may contain outer [attributes](../attributes.html) before the `impl` keyword and inner [attributes](../attributes.html) inside the brackets that contain the associated items. Inner attributes must come before any associated items. The attributes that have meaning here are [cfg](../conditional-compilation.html), [deprecated](../attributes/diagnostics.html#the-deprecated-attribute), [doc](../../rustdoc/the-doc-attribute.html), and [the lint check attributes](../attributes/diagnostics.html#lint-check-attributes).\n\n[ ](../items/traits.html \"Previous chapter\") [ ](../items/external-blocks.html \"Next chapter\") "}