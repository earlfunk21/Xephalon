{"lang":"Rust","fullPath":"/items/use-declarations","category":"items","title":"use-declarations","url":"https://doc.rust-lang.org/stable/reference/items/use-declarations.html","markdown":"# [Use declarations](#use-declarations)\n\n> **Syntax:**  \n> _UseDeclaration_ :  \n> `use` _UseTree_ `;`\n> \n> _UseTree_ :  \n> ([_SimplePath_](../paths.html#simple-paths)? `::`)? `*`  \n> | ([_SimplePath_](../paths.html#simple-paths)? `::`)? `{` (_UseTree_ ( `,` _UseTree_ )\\* `,`?)? `}`  \n> | [_SimplePath_](../paths.html#simple-paths) ( `as` ( [IDENTIFIER](../identifiers.html) | `_` ) )?\n\nA _use declaration_ creates one or more local name bindings synonymous with some other [path](../paths.html). Usually a `use` declaration is used to shorten the path required to refer to a module item. These declarations may appear in [modules](modules.html)and [blocks](../expressions/block-expr.html), usually at the top.\n\nUse declarations support a number of convenient shortcuts:\n\n* Simultaneously binding a list of paths with a common prefix, using the glob-like brace syntax `use a::b::{c, d, e::f, g::h::i};`\n* Simultaneously binding a list of paths with a common prefix and their common parent module, using the `self` keyword, such as `use a::b::{self, c, d::e};`\n* Rebinding the target name as a new local name, using the syntax `use p::q::r as x;`. This can also be used with the last two features:`use a::b::{self as ab, c as abc}`.\n* Binding all paths matching a given prefix, using the asterisk wildcard syntax`use a::b::*;`.\n* Nesting groups of the previous features multiple times, such as`use a::b::{self as ab, c, d::{*, e::f}};`\n\nAn example of `use` declarations:\n\n```rust\nuse std::collections::hash_map::{self, HashMap};\n\nfn foo<T>(_: T){}\nfn bar(map1: HashMap<String, usize>, map2: hash_map::HashMap<String, usize>){}\n\nfn main() {\n    // use declarations can also exist inside of functions\n    use std::option::Option::{Some, None};\n\n    // Equivalent to 'foo(vec![std::option::Option::Some(1.0f64),\n    // std::option::Option::None]);'\n    foo(vec![Some(1.0f64), None]);\n\n    // Both `hash_map` and `HashMap` are in scope.\n    let map1 = HashMap::new();\n    let map2 = hash_map::HashMap::new();\n    bar(map1, map2);\n}\n```\n\n## [use Visibility](#use-visibility)\n\nLike items, `use` declarations are private to the containing module, by default. Also like items, a `use` declaration can be public, if qualified by the `pub` keyword. Such a `use` declaration serves to _re-export_ a name. A public `use` declaration can therefore _redirect_ some public name to a different target definition: even a definition with a private canonical path, inside a different module. If a sequence of such redirections form a cycle or cannot be resolved unambiguously, they represent a compile-time error.\n\nAn example of re-exporting:\n\n```rust\nmod quux {\n    pub use self::foo::{bar, baz};\n    pub mod foo {\n        pub fn bar() {}\n        pub fn baz() {}\n    }\n}\n\nfn main() {\n    quux::bar();\n    quux::baz();\n}\n```\n\nIn this example, the module `quux` re-exports two public names defined in`foo`.\n\n## [use Paths](#use-paths)\n\n> **Note**: This section is incomplete.\n\nSome examples of what will and will not work for `use` items:\n\n```rust\n#![allow(unused_imports)]\nuse std::path::{self, Path, PathBuf};  // good: std is a crate name\nuse crate::foo::baz::foobaz;    // good: foo is at the root of the crate\n\nmod foo {\n\n    pub mod example {\n        pub mod iter {}\n    }\n\n    use crate::foo::example::iter; // good: foo is at crate root\n//  use example::iter;      // bad in 2015 edition: relative paths are not allowed without `self`; good in 2018 edition\n    use self::baz::foobaz;  // good: self refers to module 'foo'\n    use crate::foo::bar::foobar;   // good: foo is at crate root\n\n    pub mod bar {\n        pub fn foobar() { }\n    }\n\n    pub mod baz {\n        use super::bar::foobar; // good: super refers to module 'foo'\n        pub fn foobaz() { }\n    }\n}\n\nfn main() {}\n```\n\n> **Edition Differences**: In the 2015 edition, `use` paths also allow accessing items in the crate root. Using the example above, the following`use` paths work in 2015 but not 2018:\n> \n> ```rust\n> mod foo {\n>    pub mod example { pub mod iter {} }\n>    pub mod baz { pub fn foobaz() {} }\n> }\n> use foo::example::iter;\n> use ::foo::baz::foobaz;\n> fn main() {}\n> ```\n> \n> The 2015 edition does not allow use declarations to reference the [extern prelude](../names/preludes.html#extern-prelude). Thus [extern crate](extern-crates.html) declarations are still required in 2015 to reference an external crate in a use declaration. Beginning with the 2018 edition, use declarations can specify an external crate dependency the same way `extern crate` can.\n> \n> In the 2018 edition, if an in-scope item has the same name as an external crate, then `use` of that crate name requires a leading `::` to unambiguously select the crate name. This is to retain compatibility with potential future changes. \n> \n> ```rust\n> // use std::fs; // Error, this is ambiguous.\n> use ::std::fs;  // Imports from the `std` crate, not the module below.\n> use self::std::fs as self_fs;  // Imports the module below.\n> \n> mod std {\n>    pub mod fs {}\n> }\n> fn main() {}\n> ```\n\n## [Underscore Imports](#underscore-imports)\n\nItems can be imported without binding to a name by using an underscore with the form `use path as _`. This is particularly useful to import a trait so that its methods may be used without importing the trait's symbol, for example if the trait's symbol may conflict with another symbol. Another example is to link an external crate without importing its name.\n\nAsterisk glob imports will import items imported with `_` in their unnameable form.\n\n```rust\nmod foo {\n    pub trait Zoo {\n        fn zoo(&self) {}\n    }\n\n    impl<T> Zoo for T {}\n}\n\nuse self::foo::Zoo as _;\nstruct Zoo;  // Underscore import avoids name conflict with this item.\n\nfn main() {\n    let z = Zoo;\n    z.zoo();\n}\n```\n\nThe unique, unnameable symbols are created after macro expansion so that macros may safely emit multiple references to `_` imports. For example, the following should not produce an error:\n\n```rust\n#![allow(unused)]\nfn main() {\nmacro_rules! m {\n    ($item: item) => { $item $item }\n}\n\nm!(use std as _;);\n// This expands to:\n// use std as _;\n// use std as _;\n}\n```\n\n[ ](../items/extern-crates.html \"Previous chapter\") [ ](../items/functions.html \"Next chapter\") "}