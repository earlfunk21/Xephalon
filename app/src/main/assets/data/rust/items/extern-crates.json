{"lang":"Rust","fullPath":"/items/extern-crates","category":"items","title":"extern-crates","url":"https://doc.rust-lang.org/stable/reference/items/extern-crates.html","markdown":"# [Extern crate declarations](#extern-crate-declarations)\n\n> **Syntax:**  \n> _ExternCrate_ :  \n> `extern` `crate` _CrateRef_ _AsClause_? `;`\n> \n> _CrateRef_ :  \n> [IDENTIFIER](../identifiers.html) | `self`\n> \n> _AsClause_ :  \n> `as` ( [IDENTIFIER](../identifiers.html) | `_` )\n\nAn _`extern crate` declaration_ specifies a dependency on an external crate. The external crate is then bound into the declaring scope as the [identifier](../identifiers.html)provided in the `extern crate` declaration. Additionally, if the `extern crate` appears in the crate root, then the crate name is also added to the[extern prelude](../names/preludes.html#extern-prelude), making it automatically in scope in all modules. The `as`clause can be used to bind the imported crate to a different name.\n\nThe external crate is resolved to a specific `soname` at compile time, and a runtime linkage requirement to that `soname` is passed to the linker for loading at runtime. The `soname` is resolved at compile time by scanning the compiler's library path and matching the optional `crate_name` provided against the [crate\\_name attributes](../crates-and-source-files.html#the-crate%5Fname-attribute) that were declared on the external crate when it was compiled. If no `crate_name` is provided, a default `name` attribute is assumed, equal to the [identifier](../identifiers.html) given in the `extern crate` declaration.\n\nThe `self` crate may be imported which creates a binding to the current crate. In this case the `as` clause must be used to specify the name to bind it to.\n\nThree examples of `extern crate` declarations:\n\n```rust\nextern crate pcre;\n\nextern crate std; // equivalent to: extern crate std as std;\n\nextern crate std as ruststd; // linking to 'std' under another name\n```\n\nWhen naming Rust crates, hyphens are disallowed. However, Cargo packages may make use of them. In such case, when `Cargo.toml` doesn't specify a crate name, Cargo will transparently replace `-` with `_` (Refer to [RFC 940](https://github.com/rust-lang/rfcs/blob/master/text/0940-hyphens-considered-harmful.md) for more details).\n\nHere is an example:\n\n```rust\n// Importing the Cargo package hello-world\nextern crate hello_world; // hyphen replaced with an underscore\n```\n\n## [Extern Prelude](#extern-prelude)\n\nThis section has been moved to [Preludes â€” Extern Prelude](../names/preludes.html#extern-prelude).\n\n## [Underscore Imports](#underscore-imports)\n\nAn external crate dependency can be declared without binding its name in scope by using an underscore with the form `extern crate foo as _`. This may be useful for crates that only need to be linked, but are never referenced, and will avoid being reported as unused.\n\nThe [macro\\_use attribute](../macros-by-example.html#the-macro%5Fuse-attribute) works as usual and imports the macro names into the [macro\\_use prelude](../names/preludes.html#macro%5Fuse-prelude).\n\n## [The no\\_link attribute](#the-no%5Flink-attribute)\n\nThe _`nolink` attribute_ may be specified on an `extern crate` item to prevent linking the crate into the output. This is commonly used to load a crate to access only its macros.\n\n[ ](../items/modules.html \"Previous chapter\") [ ](../items/use-declarations.html \"Next chapter\") "}