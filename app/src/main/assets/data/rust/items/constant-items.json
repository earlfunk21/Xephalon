{"lang":"Rust","fullPath":"/items/constant-items","category":"items","title":"constant-items","url":"https://doc.rust-lang.org/stable/reference/items/constant-items.html","markdown":"# [Constant items](#constant-items)\n\n> **Syntax**  \n> _ConstantItem_ :  \n> `const` ( [IDENTIFIER](../identifiers.html) | `_` ) `:` [_Type_](../types.html#type-expressions) ( `=` [_Expression_](../expressions.html) )? `;`\n\nA _constant item_ is an optionally named _[constant value](../const%5Feval.html#constant-expressions)_ which is not associated with a specific memory location in the program. Constants are essentially inlined wherever they are used, meaning that they are copied directly into the relevant context when used. This includes usage of constants from external crates, and non-[Copy](../special-types-and-traits.html#copy) types. References to the same constant are not necessarily guaranteed to refer to the same memory address.\n\nConstants must be explicitly typed. The type must have a `'static` lifetime: any references in the initializer must have `'static` lifetimes.\n\nConstants may refer to the address of other constants, in which case the address will have elided lifetimes where applicable, otherwise – in most cases – defaulting to the `static` lifetime. (See [static lifetime elision](../lifetime-elision.html#static-lifetime-elision).) The compiler is, however, still at liberty to translate the constant many times, so the address referred to may not be stable.\n\n```rust\n#![allow(unused)]\nfn main() {\nconst BIT1: u32 = 1 << 0;\nconst BIT2: u32 = 1 << 1;\n\nconst BITS: [u32; 2] = [BIT1, BIT2];\nconst STRING: &'static str = \"bitstring\";\n\nstruct BitsNStrings<'a> {\n    mybits: [u32; 2],\n    mystring: &'a str,\n}\n\nconst BITS_N_STRINGS: BitsNStrings<'static> = BitsNStrings {\n    mybits: BITS,\n    mystring: STRING,\n};\n}\n```\n\nThe constant expression may only be omitted in a [trait definition](traits.html).\n\n## [Constants with Destructors](#constants-with-destructors)\n\nConstants can contain destructors. Destructors are run when the value goes out of scope.\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct TypeWithDestructor(i32);\n\nimpl Drop for TypeWithDestructor {\n    fn drop(&mut self) {\n        println!(\"Dropped. Held {}.\", self.0);\n    }\n}\n\nconst ZERO_WITH_DESTRUCTOR: TypeWithDestructor = TypeWithDestructor(0);\n\nfn create_and_drop_zero_with_destructor() {\n    let x = ZERO_WITH_DESTRUCTOR;\n    // x gets dropped at end of function, calling drop.\n    // prints \"Dropped. Held 0.\".\n}\n}\n```\n\n## [Unnamed constant](#unnamed-constant)\n\nUnlike an [associated constant](../items/associated-items.html#associated-constants), a [free](../glossary.html#free-item) constant may be unnamed by using an underscore instead of the name. For example:\n\n```rust\n#![allow(unused)]\nfn main() {\nconst _: () =  { struct _SameNameTwice; };\n\n// OK although it is the same name as above:\nconst _: () =  { struct _SameNameTwice; };\n}\n```\n\nAs with [underscore imports](use-declarations.html#underscore-imports), macros may safely emit the same unnamed constant in the same scope more than once. For example, the following should not produce an error:\n\n```rust\n#![allow(unused)]\nfn main() {\nmacro_rules! m {\n    ($item: item) => { $item $item }\n}\n\nm!(const _: () = (););\n// This expands to:\n// const _: () = ();\n// const _: () = ();\n}\n```\n\n[ ](../items/unions.html \"Previous chapter\") [ ](../items/static-items.html \"Next chapter\") "}