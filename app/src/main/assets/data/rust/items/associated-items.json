{"lang":"Rust","fullPath":"/items/associated-items","category":"items","title":"associated-items","url":"https://doc.rust-lang.org/stable/reference/items/associated-items.html","markdown":"# [Associated Items](#associated-items)\n\n> **Syntax**  \n> _AssociatedItem_ :  \n> [_OuterAttribute_](../attributes.html)\\* (  \n> [_MacroInvocationSemi_](../macros.html#macro-invocation)  \n> | ( [_Visibility_](../visibility-and-privacy.html)? ( [_TypeAlias_](type-aliases.html) | [_ConstantItem_](constant-items.html) | [_Function_](functions.html) ) )  \n> )\n\n_Associated Items_ are the items declared in [traits](traits.html) or defined in[implementations](implementations.html). They are called this because they are defined on an associate type â€” the type in the implementation. They are a subset of the kinds of items you can declare in a module. Specifically, there are [associated functions](#associated-functions-and-methods) (including methods), [associated types](#associated-types), and [associated constants](#associated-constants).\n\nAssociated items are useful when the associated item logically is related to the associating item. For example, the `is_some` method on `Option` is intrinsically related to Options, so should be associated.\n\nEvery associated item kind comes in two varieties: definitions that contain the actual implementation and declarations that declare signatures for definitions.\n\nIt is the declarations that make up the contract of traits and what is available on generic types.\n\n## [Associated functions and methods](#associated-functions-and-methods)\n\n_Associated functions_ are [functions](functions.html) associated with a type.\n\nAn _associated function declaration_ declares a signature for an associated function definition. It is written as a function item, except the function body is replaced with a `;`.\n\nThe identifier is the name of the function. The generics, parameter list, return type, and where clause of the associated function must be the same as the associated function declarations's.\n\nAn _associated function definition_ defines a function associated with another type. It is written the same as a [function item](../types/function-item.html).\n\nAn example of a common associated function is a `new` function that returns a value of the type the associated function is associated with.\n\n```rust\nstruct Struct {\n    field: i32\n}\n\nimpl Struct {\n    fn new() -> Struct {\n        Struct {\n            field: 0i32\n        }\n    }\n}\n\nfn main () {\n    let _struct = Struct::new();\n}\n```\n\nWhen the associated function is declared on a trait, the function can also be called with a [path](../paths.html) that is a path to the trait appended by the name of the trait. When this happens, it is substituted for `<_ as Trait>::function_name`.\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait Num {\n    fn from_i32(n: i32) -> Self;\n}\n\nimpl Num for f64 {\n    fn from_i32(n: i32) -> f64 { n as f64 }\n}\n\n// These 4 are all equivalent in this case.\nlet _: f64 = Num::from_i32(42);\nlet _: f64 = <_ as Num>::from_i32(42);\nlet _: f64 = <f64 as Num>::from_i32(42);\nlet _: f64 = f64::from_i32(42);\n}\n```\n\n### [Methods](#methods)\n\nAssociated functions whose first parameter is named `self` are called _methods_and may be invoked using the [method call operator](../expressions/method-call-expr.html), for example, `x.foo()`, as well as the usual function call notation.\n\nIf the type of the `self` parameter is specified, it is limited to types resolving to one generated by the following grammar (where `'lt` denotes some arbitrary lifetime):\n\n```text\nP = &'lt S | &'lt mut S | Box<S> | Rc<S> | Arc<S> | Pin<P>\nS = Self | P\n\n```\n\nThe `Self` terminal in this grammar denotes a type resolving to the implementing type. This can also include the contextual type alias `Self`, other type aliases, or associated type projections resolving to the implementing type.\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::rc::Rc;\nuse std::sync::Arc;\nuse std::pin::Pin;\n// Examples of methods implemented on struct `Example`.\nstruct Example;\ntype Alias = Example;\ntrait Trait { type Output; }\nimpl Trait for Example { type Output = Example; }\nimpl Example {\n    fn by_value(self: Self) {}\n    fn by_ref(self: &Self) {}\n    fn by_ref_mut(self: &mut Self) {}\n    fn by_box(self: Box<Self>) {}\n    fn by_rc(self: Rc<Self>) {}\n    fn by_arc(self: Arc<Self>) {}\n    fn by_pin(self: Pin<&Self>) {}\n    fn explicit_type(self: Arc<Example>) {}\n    fn with_lifetime<'a>(self: &'a Self) {}\n    fn nested<'a>(self: &mut &'a Arc<Rc<Box<Alias>>>) {}\n    fn via_projection(self: <Example as Trait>::Output) {}\n}\n}\n```\n\nShorthand syntax can be used without specifying a type, which have the following equivalents:\n\n| Shorthand           | Equivalent                |\n| ------------------- | ------------------------- |\n| self                | self: Self                |\n| &'lifetime self     | self: &'lifetime Self     |\n| &'lifetime mut self | self: &'lifetime mut Self |\n\n> **Note**: Lifetimes can be, and usually are, elided with this shorthand.\n\nIf the `self` parameter is prefixed with `mut`, it becomes a mutable variable, similar to regular parameters using a `mut` [identifier pattern](../patterns.html#identifier-patterns). For example:\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait Changer: Sized {\n    fn change(mut self) {}\n    fn modify(mut self: Box<Self>) {}\n}\n}\n```\n\nAs an example of methods on a trait, consider the following:\n\n```rust\n#![allow(unused)]\nfn main() {\ntype Surface = i32;\ntype BoundingBox = i32;\ntrait Shape {\n    fn draw(&self, surface: Surface);\n    fn bounding_box(&self) -> BoundingBox;\n}\n}\n```\n\nThis defines a trait with two methods. All values that have [implementations](implementations.html)of this trait while the trait is in scope can have their `draw` and`bounding_box` methods called.\n\n```rust\n#![allow(unused)]\nfn main() {\ntype Surface = i32;\ntype BoundingBox = i32;\ntrait Shape {\n    fn draw(&self, surface: Surface);\n    fn bounding_box(&self) -> BoundingBox;\n}\n\nstruct Circle {\n    // ...\n}\n\nimpl Shape for Circle {\n    // ...\n  fn draw(&self, _: Surface) {}\n  fn bounding_box(&self) -> BoundingBox { 0i32 }\n}\n\nimpl Circle {\n    fn new() -> Circle { Circle{} }\n}\n\nlet circle_shape = Circle::new();\nlet bounding_box = circle_shape.bounding_box();\n}\n```\n\n> **Edition Differences**: In the 2015 edition, it is possible to declare trait methods with anonymous parameters (e.g. `fn foo(u8)`). This is deprecated and an error as of the 2018 edition. All parameters must have an argument name.\n\n#### [Attributes on method parameters](#attributes-on-method-parameters)\n\nAttributes on method parameters follow the same rules and restrictions as[regular function parameters](functions.html#attributes-on-function-parameters).\n\n## [Associated Types](#associated-types)\n\n_Associated types_ are [type aliases](type-aliases.html) associated with another type. Associated types cannot be defined in [inherent implementations](implementations.html#inherent-implementations) nor can they be given a default implementation in traits.\n\nAn _associated type declaration_ declares a signature for associated type definitions. It is written in one of the following forms, where `Assoc` is the name of the associated type, `Params` is a comma-separated list of type, lifetime or const parameters, `Bounds` is a plus-separated list of trait bounds that the associated type must meet, and `WhereBounds` is a comma-separated list of bounds that the parameters must meet:\n\n```rust\ntype Assoc;\ntype Assoc: Bounds;\ntype Assoc<Params>;\ntype Assoc<Params>: Bounds;\ntype Assoc<Params> where WhereBounds;\ntype Assoc<Params>: Bounds where WhereBounds;\n```\n\nThe identifier is the name of the declared type alias. The optional trait bounds must be fulfilled by the implementations of the type alias. There is an implicit [Sized](../special-types-and-traits.html#sized) bound on associated types that can be relaxed using the special `?Sized` bound.\n\nAn _associated type definition_ defines a type alias for the implementation of a trait on a type. They are written similarly to an _associated type declaration_, but cannot contain `Bounds`, but instead must contain a `Type`:\n\n```rust\ntype Assoc = Type;\ntype Assoc<Params> = Type; // the type `Type` here may reference `Params`\ntype Assoc<Params> = Type where WhereBounds;\ntype Assoc<Params> where WhereBounds = Type; // deprecated, prefer the form above\n```\n\nIf a type `Item` has an associated type `Assoc` from a trait `Trait`, then`<Item as Trait>::Assoc` is a type that is an alias of the type specified in the associated type definition. Furthermore, if `Item` is a type parameter, then`Item::Assoc` can be used in type parameters.\n\nAssociated types may include [generic parameters](generics.html) and [where clauses](generics.html#where-clauses); these are often referred to as _generic associated types_, or _GATs_. If the type `Thing`has an associated type `Item` from a trait `Trait` with the generics `<'a>` , the type can be named like `<Thing as Trait>::Item<'x>`, where `'x` is some lifetime in scope. In this case, `'x` will be used wherever `'a` appears in the associated type definitions on impls.\n\n```rust\ntrait AssociatedType {\n    // Associated type declaration\n    type Assoc;\n}\n\nstruct Struct;\n\nstruct OtherStruct;\n\nimpl AssociatedType for Struct {\n    // Associated type definition\n    type Assoc = OtherStruct;\n}\n\nimpl OtherStruct {\n    fn new() -> OtherStruct {\n        OtherStruct\n    }\n}\n\nfn main() {\n    // Usage of the associated type to refer to OtherStruct as <Struct as AssociatedType>::Assoc\n    let _other_struct: OtherStruct = <Struct as AssociatedType>::Assoc::new();\n}\n```\n\nAn example of associated types with generics and where clauses:\n\n```rust\nstruct ArrayLender<'a, T>(&'a mut [T; 16]);\n\ntrait Lend {\n    // Generic associated type declaration\n    type Lender<'a> where Self: 'a;\n    fn lend<'a>(&'a mut self) -> Self::Lender<'a>;\n}\n\nimpl<T> Lend for [T; 16] {\n    // Generic associated type definition\n    type Lender<'a> = ArrayLender<'a, T> where Self: 'a;\n\n    fn lend<'a>(&'a mut self) -> Self::Lender<'a> {\n        ArrayLender(self)\n    }\n}\n\nfn borrow<'a, T: Lend>(array: &'a mut T) -> <T as Lend>::Lender<'a> {\n    array.lend()\n}\n\n\nfn main() {\n    let mut array = [0usize; 16];\n    let lender = borrow(&mut array);\n}\n```\n\n### [Associated Types Container Example](#associated-types-container-example)\n\nConsider the following example of a `Container` trait. Notice that the type is available for use in the method signatures:\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait Container {\n    type E;\n    fn empty() -> Self;\n    fn insert(&mut self, elem: Self::E);\n}\n}\n```\n\nIn order for a type to implement this trait, it must not only provide implementations for every method, but it must specify the type `E`. Here's an implementation of `Container` for the standard library type `Vec`:\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait Container {\n    type E;\n    fn empty() -> Self;\n    fn insert(&mut self, elem: Self::E);\n}\nimpl<T> Container for Vec<T> {\n    type E = T;\n    fn empty() -> Vec<T> { Vec::new() }\n    fn insert(&mut self, x: T) { self.push(x); }\n}\n}\n```\n\n### [Relationship between Bounds and WhereBounds](#relationship-between-bounds-and-wherebounds)\n\nIn this example:\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::fmt::Debug;\ntrait Example {\n    type Output<T>: Ord where T: Debug;\n}\n}\n```\n\nGiven a reference to the associated type like `<X as Example>::Output<Y>`, the associated type itself must be `Ord`, and the type `Y` must be `Debug`.\n\n### [Required where clauses on generic associated types](#required-where-clauses-on-generic-associated-types)\n\nGeneric associated type declarations on traits currently may require a list of where clauses, dependent on functions in the trait and how the GAT is used. These rules may be loosened in the future; updates can be found [on the generic associated types initiative repository](https://rust-lang.github.io/generic-associated-types-initiative/explainer/required%5Fbounds.html).\n\nIn a few words, these where clauses are required in order to maximize the allowed definitions of the associated type in impls. To do this, any clauses that _can be proven to hold_ on functions (using the parameters of the function or trait) where a GAT appears as an input or output must also be written on the GAT itself.\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait LendingIterator {\n    type Item<'x> where Self: 'x;\n    fn next<'a>(&'a mut self) -> Self::Item<'a>;\n}\n}\n```\n\nIn the above, on the `next` function, we can prove that `Self: 'a`, because of the implied bounds from `&'a mut self`; therefore, we must write the equivalent bound on the GAT itself: `where Self: 'x`.\n\nWhen there are multiple functions in a trait that use the GAT, then the_intersection_ of the bounds from the different functions are used, rather than the union.\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait Check<T> {\n    type Checker<'x>;\n    fn create_checker<'a>(item: &'a T) -> Self::Checker<'a>;\n    fn do_check(checker: Self::Checker<'_>);\n}\n}\n```\n\nIn this example, no bounds are required on the `type Checker<'a>;`. While we know that `T: 'a` on `create_checker`, we do not know that on `do_check`. However, if `do_check` was commented out, then the `where T: 'x` bound would be required on `Checker`.\n\nThe bounds on associated types also propagate required where clauses.\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait Iterable {\n    type Item<'a> where Self: 'a;\n    type Iterator<'a>: Iterator<Item = Self::Item<'a>> where Self: 'a;\n    fn iter<'a>(&'a self) -> Self::Iterator<'a>;\n}\n}\n```\n\nHere, `where Self: 'a` is required on `Item` because of `iter`. However, `Item`is used in the bounds of `Iterator`, the `where Self: 'a` clause is also required there.\n\nFinally, any explicit uses of `'static` on GATs in the trait do not count towards the required bounds.\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait StaticReturn {\n    type Y<'a>;\n    fn foo(&self) -> Self::Y<'static>;\n}\n}\n```\n\n## [Associated Constants](#associated-constants)\n\n_Associated constants_ are [constants](constant-items.html) associated with a type.\n\nAn _associated constant declaration_ declares a signature for associated constant definitions. It is written as `const`, then an identifier, then `:`, then a type, finished by a `;`.\n\nThe identifier is the name of the constant used in the path. The type is the type that the definition has to implement.\n\nAn _associated constant definition_ defines a constant associated with a type. It is written the same as a [constant item](constant-items.html).\n\nAssociated constant definitions undergo [constant evaluation](../const%5Feval.html) only when referenced. Further, definitions that include [generic parameters](generics.html) are evaluated after monomorphization.\n\n```rust\nstruct Struct;\nstruct GenericStruct<const ID: i32>;\n\nimpl Struct {\n    // Definition not immediately evaluated\n    const PANIC: () = panic!(\"compile-time panic\");\n}\n\nimpl<const ID: i32> GenericStruct<ID> {\n    // Definition not immediately evaluated\n    const NON_ZERO: () = if ID == 0 {\n        panic!(\"contradiction\")\n    };\n}\n\nfn main() {\n    // Referencing Struct::PANIC causes compilation error\n    let _ = Struct::PANIC;\n\n    // Fine, ID is not 0\n    let _ = GenericStruct::<1>::NON_ZERO;\n\n    // Compilation error from evaluating NON_ZERO with ID=0\n    let _ = GenericStruct::<0>::NON_ZERO;\n}\n```\n\n### [Associated Constants Examples](#associated-constants-examples)\n\nA basic example:\n\n```rust\ntrait ConstantId {\n    const ID: i32;\n}\n\nstruct Struct;\n\nimpl ConstantId for Struct {\n    const ID: i32 = 1;\n}\n\nfn main() {\n    assert_eq!(1, Struct::ID);\n}\n```\n\nUsing default values:\n\n```rust\ntrait ConstantIdDefault {\n    const ID: i32 = 1;\n}\n\nstruct Struct;\nstruct OtherStruct;\n\nimpl ConstantIdDefault for Struct {}\n\nimpl ConstantIdDefault for OtherStruct {\n    const ID: i32 = 5;\n}\n\nfn main() {\n    assert_eq!(1, Struct::ID);\n    assert_eq!(5, OtherStruct::ID);\n}\n```\n\n[ ](../items/generics.html \"Previous chapter\") [ ](../attributes.html \"Next chapter\") "}