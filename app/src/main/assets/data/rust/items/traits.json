{"lang":"Rust","fullPath":"/items/traits","category":"items","title":"traits","url":"https://doc.rust-lang.org/stable/reference/items/traits.html","markdown":"# [Traits](#traits)\n\n> **Syntax**  \n> _Trait_ :  \n> `unsafe`? `trait` [IDENTIFIER](../identifiers.html) [_GenericParams_](generics.html)?( `:` [_TypeParamBounds_](../trait-bounds.html)? )? [_WhereClause_](generics.html#where-clauses)? `{`  \n> [_InnerAttribute_](../attributes.html)\\*  \n> [_AssociatedItem_](associated-items.html)\\*  \n> `}`\n\nA _trait_ describes an abstract interface that types can implement. This interface consists of [associated items](associated-items.html), which come in three varieties:\n\n* [functions](associated-items.html#associated-functions-and-methods)\n* [types](associated-items.html#associated-types)\n* [constants](associated-items.html#associated-constants)\n\nAll traits define an implicit type parameter `Self` that refers to \"the type that is implementing this interface\". Traits may also contain additional type parameters. These type parameters, including `Self`, may be constrained by other traits and so forth [as usual](generics.html).\n\nTraits are implemented for specific types through separate [implementations](implementations.html).\n\nTrait functions may omit the function body by replacing it with a semicolon. This indicates that the implementation must define the function. If the trait function defines a body, this definition acts as a default for any implementation which does not override it. Similarly, associated constants may omit the equals sign and expression to indicate implementations must define the constant value. Associated types must never define the type, the type may only be specified in an implementation.\n\n```rust\n#![allow(unused)]\nfn main() {\n// Examples of associated trait items with and without definitions.\ntrait Example {\n    const CONST_NO_DEFAULT: i32;\n    const CONST_WITH_DEFAULT: i32 = 99;\n    type TypeNoDefault;\n    fn method_without_default(&self);\n    fn method_with_default(&self) {}\n}\n}\n```\n\nTrait functions are not allowed to be [async](functions.html#async-functions) or [const](functions.html#const-functions).\n\n## [Trait bounds](#trait-bounds)\n\nGeneric items may use traits as [bounds](../trait-bounds.html) on their type parameters.\n\n## [Generic Traits](#generic-traits)\n\nType parameters can be specified for a trait to make it generic. These appear after the trait name, using the same syntax used in [generic functions](functions.html#generic-functions).\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait Seq<T> {\n    fn len(&self) -> u32;\n    fn elt_at(&self, n: u32) -> T;\n    fn iter<F>(&self, f: F) where F: Fn(T);\n}\n}\n```\n\n## [Object Safety](#object-safety)\n\nObject safe traits can be the base trait of a [trait object](../types/trait-object.html). A trait is_object safe_ if it has the following qualities (defined in [RFC 255](https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md)):\n\n* All [supertraits](#supertraits) must also be object safe.\n* `Sized` must not be a [supertrait](#supertraits). In other words, it must not require `Self: Sized`.\n* It must not have any associated constants.\n* It must not have any associated types with generics.\n* All associated functions must either be dispatchable from a trait object or be explicitly non-dispatchable:  \n   * Dispatchable functions require:  \n         * Not have any type parameters (although lifetime parameters are allowed),  \n         * Be a [method](associated-items.html#methods) that does not use `Self` except in the type of the receiver.  \n         * Have a receiver with one of the following types:  \n                  * `&Self` (i.e. `&self`)  \n                  * `&mut Self` (i.e `&mut self`)  \n                  * [Box<Self>](../special-types-and-traits.html#boxt)  \n                  * [Rc<Self>](../special-types-and-traits.html#rct)  \n                  * [Arc<Self>](../special-types-and-traits.html#arct)  \n                  * [Pin<P>](../special-types-and-traits.html#pinp) where `P` is one of the types above  \n         * Does not have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self`) implies this).  \n   * Explicitly non-dispatchable functions require:  \n         * Have a `where Self: Sized` bound (receiver type of `Self` (i.e. `self`) implies this).\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::rc::Rc;\nuse std::sync::Arc;\nuse std::pin::Pin;\n// Examples of object safe methods.\ntrait TraitMethods {\n    fn by_ref(self: &Self) {}\n    fn by_ref_mut(self: &mut Self) {}\n    fn by_box(self: Box<Self>) {}\n    fn by_rc(self: Rc<Self>) {}\n    fn by_arc(self: Arc<Self>) {}\n    fn by_pin(self: Pin<&Self>) {}\n    fn with_lifetime<'a>(self: &'a Self) {}\n    fn nested_pin(self: Pin<Arc<Self>>) {}\n}\nstruct S;\nimpl TraitMethods for S {}\nlet t: Box<dyn TraitMethods> = Box::new(S);\n}\n```\n\n```rust\n#![allow(unused)]\nfn main() {\n// This trait is object-safe, but these methods cannot be dispatched on a trait object.\ntrait NonDispatchable {\n    // Non-methods cannot be dispatched.\n    fn foo() where Self: Sized {}\n    // Self type isn't known until runtime.\n    fn returns(&self) -> Self where Self: Sized;\n    // `other` may be a different concrete type of the receiver.\n    fn param(&self, other: Self) where Self: Sized {}\n    // Generics are not compatible with vtables.\n    fn typed<T>(&self, x: T) where Self: Sized {}\n}\n\nstruct S;\nimpl NonDispatchable for S {\n    fn returns(&self) -> Self where Self: Sized { S }\n}\nlet obj: Box<dyn NonDispatchable> = Box::new(S);\nobj.returns(); // ERROR: cannot call with Self return\nobj.param(S);  // ERROR: cannot call with Self parameter\nobj.typed(1);  // ERROR: cannot call with generic type\n}\n```\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::rc::Rc;\n// Examples of non-object safe traits.\ntrait NotObjectSafe {\n    const CONST: i32 = 1;  // ERROR: cannot have associated const\n\n    fn foo() {}  // ERROR: associated function without Sized\n    fn returns(&self) -> Self; // ERROR: Self in return type\n    fn typed<T>(&self, x: T) {} // ERROR: has generic type parameters\n    fn nested(self: Rc<Box<Self>>) {} // ERROR: nested receiver not yet supported\n}\n\nstruct S;\nimpl NotObjectSafe for S {\n    fn returns(&self) -> Self { S }\n}\nlet obj: Box<dyn NotObjectSafe> = Box::new(S); // ERROR\n}\n```\n\n```rust\n#![allow(unused)]\nfn main() {\n// Self: Sized traits are not object-safe.\ntrait TraitWithSize where Self: Sized {}\n\nstruct S;\nimpl TraitWithSize for S {}\nlet obj: Box<dyn TraitWithSize> = Box::new(S); // ERROR\n}\n```\n\n```rust\n#![allow(unused)]\nfn main() {\n// Not object safe if `Self` is a type argument.\ntrait Super<A> {}\ntrait WithSelf: Super<Self> where Self: Sized {}\n\nstruct S;\nimpl<A> Super<A> for S {}\nimpl WithSelf for S {}\nlet obj: Box<dyn WithSelf> = Box::new(S); // ERROR: cannot use `Self` type parameter\n}\n```\n\n## [Supertraits](#supertraits)\n\n**Supertraits** are traits that are required to be implemented for a type to implement a specific trait. Furthermore, anywhere a [generic](generics.html) or [trait object](../types/trait-object.html)is bounded by a trait, it has access to the associated items of its supertraits.\n\nSupertraits are declared by trait bounds on the `Self` type of a trait and transitively the supertraits of the traits declared in those trait bounds. It is an error for a trait to be its own supertrait.\n\nThe trait with a supertrait is called a **subtrait** of its supertrait.\n\nThe following is an example of declaring `Shape` to be a supertrait of `Circle`.\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait Shape { fn area(&self) -> f64; }\ntrait Circle : Shape { fn radius(&self) -> f64; }\n}\n```\n\nAnd the following is the same example, except using [where clauses](generics.html#where-clauses).\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait Shape { fn area(&self) -> f64; }\ntrait Circle where Self: Shape { fn radius(&self) -> f64; }\n}\n```\n\nThis next example gives `radius` a default implementation using the `area`function from `Shape`.\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait Shape { fn area(&self) -> f64; }\ntrait Circle where Self: Shape {\n    fn radius(&self) -> f64 {\n        // A = pi * r^2\n        // so algebraically,\n        // r = sqrt(A / pi)\n        (self.area() /std::f64::consts::PI).sqrt()\n    }\n}\n}\n```\n\nThis next example calls a supertrait method on a generic parameter.\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait Shape { fn area(&self) -> f64; }\ntrait Circle : Shape { fn radius(&self) -> f64; }\nfn print_area_and_radius<C: Circle>(c: C) {\n    // Here we call the area method from the supertrait `Shape` of `Circle`.\n    println!(\"Area: {}\", c.area());\n    println!(\"Radius: {}\", c.radius());\n}\n}\n```\n\nSimilarly, here is an example of calling supertrait methods on trait objects.\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait Shape { fn area(&self) -> f64; }\ntrait Circle : Shape { fn radius(&self) -> f64; }\nstruct UnitCircle;\nimpl Shape for UnitCircle { fn area(&self) -> f64 { std::f64::consts::PI } }\nimpl Circle for UnitCircle { fn radius(&self) -> f64 { 1.0 } }\nlet circle = UnitCircle;\nlet circle = Box::new(circle) as Box<dyn Circle>;\nlet nonsense = circle.radius() * circle.area();\n}\n```\n\n## [Unsafe traits](#unsafe-traits)\n\nTraits items that begin with the `unsafe` keyword indicate that _implementing_ the trait may be [unsafe](../unsafety.html). It is safe to use a correctly implemented unsafe trait. The [trait implementation](implementations.html#trait-implementations) must also begin with the `unsafe` keyword.\n\n[Sync](../special-types-and-traits.html#sync) and [Send](../special-types-and-traits.html#send) are examples of unsafe traits.\n\n## [Parameter patterns](#parameter-patterns)\n\nFunction or method declarations without a body only allow [IDENTIFIER](../identifiers.html) or`_` [wild card](../patterns.html#wildcard-pattern) patterns. `mut` [IDENTIFIER](../identifiers.html) is currently allowed, but it is deprecated and will become a hard error in the future.\n\nIn the 2015 edition, the pattern for a trait function or method parameter is optional:\n\n```rust\n#![allow(unused)]\nfn main() {\n// 2015 Edition\ntrait T {\n    fn f(i32);  // Parameter identifiers are not required.\n}\n}\n```\n\nThe kinds of patterns for parameters is limited to one of the following:\n\n* [IDENTIFIER](../identifiers.html)\n* `mut` [IDENTIFIER](../identifiers.html)\n* [\\_](../patterns.html#wildcard-pattern)\n* `&` [IDENTIFIER](../identifiers.html)\n* `&&` [IDENTIFIER](../identifiers.html)\n\nBeginning in the 2018 edition, function or method parameter patterns are no longer optional. Also, all irrefutable patterns are allowed as long as there is a body. Without a body, the limitations listed above are still in effect.\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait T {\n    fn f1((a, b): (i32, i32)) {}\n    fn f2(_: (i32, i32));  // Cannot use tuple pattern without a body.\n}\n}\n```\n\n## [Item visibility](#item-visibility)\n\nTrait items syntactically allow a [_Visibility_](../visibility-and-privacy.html) annotation, but this is rejected when the trait is validated. This allows items to be parsed with a unified syntax across different contexts where they are used. As an example, an empty `vis` macro fragment specifier can be used for trait items, where the macro rule may be used in other situations where visibility is allowed.\n\n```rust\nmacro_rules! create_method {\n    ($vis:vis $name:ident) => {\n        $vis fn $name(&self) {}\n    };\n}\n\ntrait T1 {\n    // Empty `vis` is allowed.\n    create_method! { method_of_t1 }\n}\n\nstruct S;\n\nimpl S {\n    // Visibility is allowed here.\n    create_method! { pub method_of_s }\n}\n\nimpl T1 for S {}\n\nfn main() {\n    let s = S;\n    s.method_of_t1();\n    s.method_of_s();\n}\n```\n\n[ ](../items/static-items.html \"Previous chapter\") [ ](../items/implementations.html \"Next chapter\") "}