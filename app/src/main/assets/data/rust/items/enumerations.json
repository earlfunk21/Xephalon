{"lang":"Rust","fullPath":"/items/enumerations","category":"items","title":"enumerations","url":"https://doc.rust-lang.org/stable/reference/items/enumerations.html","markdown":"# [Enumerations](#enumerations)\n\n> **Syntax**  \n> _Enumeration_ :  \n> `enum` [IDENTIFIER](../identifiers.html) [_GenericParams_](generics.html)? [_WhereClause_](generics.html#where-clauses)? `{` _EnumItems_? `}`\n> \n> _EnumItems_ :  \n> _EnumItem_ ( `,` _EnumItem_ )\\* `,`?\n> \n> _EnumItem_ :  \n> _OuterAttribute_\\* [_Visibility_](../visibility-and-privacy.html)?  \n> [IDENTIFIER](../identifiers.html) ( _EnumItemTuple_ | _EnumItemStruct_ )? _EnumItemDiscriminant_?\n> \n> _EnumItemTuple_ :  \n> `(` [_TupleFields_](structs.html)? `)`\n> \n> _EnumItemStruct_ :  \n> `{` [_StructFields_](structs.html)? `}`\n> \n> _EnumItemDiscriminant_ :  \n> `=` [_Expression_](../expressions.html)\n\nAn _enumeration_, also referred to as an _enum_, is a simultaneous definition of a nominal [enumerated type](../types/enum.html) as well as a set of _constructors_, that can be used to create or pattern-match values of the corresponding enumerated type.\n\nEnumerations are declared with the keyword `enum`.\n\nAn example of an `enum` item and its use:\n\n```rust\n#![allow(unused)]\nfn main() {\nenum Animal {\n    Dog,\n    Cat,\n}\n\nlet mut a: Animal = Animal::Dog;\na = Animal::Cat;\n}\n```\n\nEnum constructors can have either named or unnamed fields:\n\n```rust\n#![allow(unused)]\nfn main() {\nenum Animal {\n    Dog(String, f64),\n    Cat { name: String, weight: f64 },\n}\n\nlet mut a: Animal = Animal::Dog(\"Cocoa\".to_string(), 37.2);\na = Animal::Cat { name: \"Spotty\".to_string(), weight: 2.7 };\n}\n```\n\nIn this example, `Cat` is a _struct-like enum variant_, whereas `Dog` is simply called an enum variant.\n\nAn enum where no constructors contain fields are called a_field-less enum_. For example, this is a fieldless enum:\n\n```rust\n#![allow(unused)]\nfn main() {\nenum Fieldless {\n    Tuple(),\n    Struct{},\n    Unit,\n}\n}\n```\n\nIf a field-less enum only contains unit variants, the enum is called an_unit-only enum_. For example:\n\n```rust\n#![allow(unused)]\nfn main() {\nenum Enum {\n    Foo = 3,\n    Bar = 2,\n    Baz = 1,\n}\n}\n```\n\n## [Discriminants](#discriminants)\n\nEach enum instance has a _discriminant_: an integer logically associated to it that is used to determine which variant it holds.\n\nUnder the [default representation](../type-layout.html#the-default-representation), the discriminant is interpreted as an `isize` value. However, the compiler is allowed to use a smaller type (or another means of distinguishing variants) in its actual memory layout.\n\n### [Assigning discriminant values](#assigning-discriminant-values)\n\n#### [Explicit discriminants](#explicit-discriminants)\n\nIn two circumstances, the discriminant of a variant may be explicitly set by following the variant name with `=` and a [constant expression](../const%5Feval.html#constant-expressions):\n\n1. if the enumeration is \"[unit-only](#unit-only-enum)\".\n2. if a [primitive representation](../type-layout.html#primitive-representations) is used. For example:  \n```rust  \n#![allow(unused)]  \nfn main() {  \n#[repr(u8)]  \nenum Enum {  \n    Unit = 3,  \n    Tuple(u16),  \n    Struct {  \n        a: u8,  \n        b: u16,  \n    } = 1,  \n}  \n}  \n```\n\n#### [Implicit discriminants](#implicit-discriminants)\n\nIf a discriminant for a variant is not specified, then it is set to one higher than the discriminant of the previous variant in the declaration. If the discriminant of the first variant in the declaration is unspecified, then it is set to zero.\n\n```rust\n#![allow(unused)]\nfn main() {\nenum Foo {\n    Bar,            // 0\n    Baz = 123,      // 123\n    Quux,           // 124\n}\n\nlet baz_discriminant = Foo::Baz as u32;\nassert_eq!(baz_discriminant, 123);\n}\n```\n\n#### [Restrictions](#restrictions)\n\nIt is an error when two variants share the same discriminant.\n\n```rust\n#![allow(unused)]\nfn main() {\nenum SharedDiscriminantError {\n    SharedA = 1,\n    SharedB = 1\n}\n\nenum SharedDiscriminantError2 {\n    Zero,       // 0\n    One,        // 1\n    OneToo = 1  // 1 (collision with previous!)\n}\n}\n```\n\nIt is also an error to have an unspecified discriminant where the previous discriminant is the maximum value for the size of the discriminant.\n\n```rust\n#![allow(unused)]\nfn main() {\n#[repr(u8)]\nenum OverflowingDiscriminantError {\n    Max = 255,\n    MaxPlusOne // Would be 256, but that overflows the enum.\n}\n\n#[repr(u8)]\nenum OverflowingDiscriminantError2 {\n    MaxMinusOne = 254, // 254\n    Max,               // 255\n    MaxPlusOne         // Would be 256, but that overflows the enum.\n}\n}\n```\n\n### [Accessing discriminant](#accessing-discriminant)\n\n#### [Via mem::discriminant](#via-memdiscriminant)\n\n[mem::discriminant](../../std/mem/fn.discriminant.html) returns an opaque reference to the discriminant of an enum value which can be compared. This cannot be used to get the value of the discriminant.\n\n#### [Casting](#casting)\n\nIf an enumeration is [unit-only](#unit-only-enum) (with no tuple and struct variants), then its discriminant can be directly accessed with a [numeric cast](../expressions/operator-expr.html#semantics); e.g.:\n\n```rust\n#![allow(unused)]\nfn main() {\nenum Enum {\n    Foo,\n    Bar,\n    Baz,\n}\n\nassert_eq!(0, Enum::Foo as isize);\nassert_eq!(1, Enum::Bar as isize);\nassert_eq!(2, Enum::Baz as isize);\n}\n```\n\n[Field-less enums](#field-less-enum) can be casted if they do not have explicit discriminants, or where only unit variants are explicit.\n\n```rust\n#![allow(unused)]\nfn main() {\nenum Fieldless {\n    Tuple(),\n    Struct{},\n    Unit,\n}\n\nassert_eq!(0, Fieldless::Tuple() as isize);\nassert_eq!(1, Fieldless::Struct{} as isize);\nassert_eq!(2, Fieldless::Unit as isize);\n\n#[repr(u8)]\nenum FieldlessWithDiscrimants {\n    First = 10,\n    Tuple(),\n    Second = 20,\n    Struct{},\n    Unit,\n}\n\nassert_eq!(10, FieldlessWithDiscrimants::First as u8);\nassert_eq!(11, FieldlessWithDiscrimants::Tuple() as u8);\nassert_eq!(20, FieldlessWithDiscrimants::Second as u8);\nassert_eq!(21, FieldlessWithDiscrimants::Struct{} as u8);\nassert_eq!(22, FieldlessWithDiscrimants::Unit as u8);\n}\n```\n\n#### [Pointer casting](#pointer-casting)\n\nIf the enumeration specifies a [primitive representation](../type-layout.html#primitive-representations), then the discriminant may be reliably accessed via unsafe pointer casting:\n\n```rust\n#![allow(unused)]\nfn main() {\n#[repr(u8)]\nenum Enum {\n    Unit,\n    Tuple(bool),\n    Struct{a: bool},\n}\n\nimpl Enum {\n    fn discriminant(&self) -> u8 {\n        unsafe { *(self as *const Self as *const u8) }\n    }\n}\n\nlet unit_like = Enum::Unit;\nlet tuple_like = Enum::Tuple(true);\nlet struct_like = Enum::Struct{a: false};\n\nassert_eq!(0, unit_like.discriminant());\nassert_eq!(1, tuple_like.discriminant());\nassert_eq!(2, struct_like.discriminant());\n}\n```\n\n## [Zero-variant enums](#zero-variant-enums)\n\nEnums with zero variants are known as _zero-variant enums_. As they have no valid values, they cannot be instantiated.\n\n```rust\n#![allow(unused)]\nfn main() {\nenum ZeroVariants {}\n}\n```\n\nZero-variant enums are equivalent to the [never type](../types/never.html), but they cannot be coerced into other types.\n\n```rust\n#![allow(unused)]\nfn main() {\nenum ZeroVariants {}\nlet x: ZeroVariants = panic!();\nlet y: u32 = x; // mismatched type error\n}\n```\n\n## [Variant visibility](#variant-visibility)\n\nEnum variants syntactically allow a [_Visibility_](../visibility-and-privacy.html) annotation, but this is rejected when the enum is validated. This allows items to be parsed with a unified syntax across different contexts where they are used.\n\n```rust\n#![allow(unused)]\nfn main() {\nmacro_rules! mac_variant {\n    ($vis:vis $name:ident) => {\n        enum $name {\n            $vis Unit,\n\n            $vis Tuple(u8, u16),\n\n            $vis Struct { f: u8 },\n        }\n    }\n}\n\n// Empty `vis` is allowed.\nmac_variant! { E }\n\n// This is allowed, since it is removed before being validated.\n#[cfg(FALSE)]\nenum E {\n    pub U,\n    pub(crate) T(u8),\n    pub(super) T { f: String }\n}\n}\n```\n\n[ ](../items/structs.html \"Previous chapter\") [ ](../items/unions.html \"Next chapter\") "}