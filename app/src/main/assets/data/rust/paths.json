{"lang":"Rust","fullPath":"/paths","category":"","title":"paths.html","url":"https://doc.rust-lang.org/stable/reference/paths.html","markdown":"# [Paths](#paths)\n\nA _path_ is a sequence of one or more path segments _logically_ separated by a namespace qualifier (`::`). If a path consists of only one segment, it refers to either an [item](items.html) or a [variable](variables.html) in a local control scope. If a path has multiple segments, it always refers to an item.\n\nTwo examples of simple paths consisting of only identifier segments:\n\n```rust\nx;\nx::y::z;\n```\n\n## [Types of paths](#types-of-paths)\n\n### [Simple Paths](#simple-paths)\n\n> **Syntax**  \n> _SimplePath_ :  \n> `::`? _SimplePathSegment_ (`::` _SimplePathSegment_)\\*\n> \n> _SimplePathSegment_ :  \n> [IDENTIFIER](identifiers.html) | `super` | `self` | `crate` | `$crate`\n\nSimple paths are used in [visibility](visibility-and-privacy.html) markers, [attributes](attributes.html), [macros](macros-by-example.html), and [use](items/use-declarations.html) items. Examples:\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::io::{self, Write};\nmod m {\n    #[clippy::cyclomatic_complexity = \"0\"]\n    pub (in super) fn f1() {}\n}\n}\n```\n\n### [Paths in expressions](#paths-in-expressions)\n\n> **Syntax**  \n> _PathInExpression_ :  \n> `::`? _PathExprSegment_ (`::` _PathExprSegment_)\\*\n> \n> _PathExprSegment_ :  \n> _PathIdentSegment_ (`::` _GenericArgs_)?\n> \n> _PathIdentSegment_ :  \n> [IDENTIFIER](identifiers.html) | `super` | `self` | `Self` | `crate` | `$crate`\n> \n> _GenericArgs_ :  \n> `<` `>`  \n> | `<` ( _GenericArg_ `,` )\\* _GenericArg_ `,`? `>`\n> \n> _GenericArg_ :  \n> [_Lifetime_](trait-bounds.html) | [_Type_](types.html#type-expressions) | _GenericArgsConst_ | _GenericArgsBinding_\n> \n> _GenericArgsConst_ :  \n> [_BlockExpression_](expressions/block-expr.html)  \n> | [_LiteralExpression_](expressions/literal-expr.html)  \n> | `-` [_LiteralExpression_](expressions/literal-expr.html)  \n> | [_SimplePathSegment_](#simple-paths)\n> \n> _GenericArgsBinding_ :  \n> [IDENTIFIER](identifiers.html) `=` [_Type_](types.html#type-expressions)\n\nPaths in expressions allow for paths with generic arguments to be specified. They are used in various places in [expressions](expressions.html) and [patterns](patterns.html).\n\nThe `::` token is required before the opening `<` for generic arguments to avoid ambiguity with the less-than operator. This is colloquially known as \"turbofish\" syntax.\n\n```rust\n#![allow(unused)]\nfn main() {\n(0..10).collect::<Vec<_>>();\nVec::<u8>::with_capacity(1024);\n}\n```\n\nThe order of generic arguments is restricted to lifetime arguments, then type arguments, then const arguments, then equality constraints.\n\nConst arguments must be surrounded by braces unless they are a[literal](expressions/literal-expr.html) or a single segment path.\n\nThe synthetic type parameters corresponding to `impl Trait` types are implicit, and these cannot be explicitly specified.\n\n## [Qualified paths](#qualified-paths)\n\n> **Syntax**  \n> _QualifiedPathInExpression_ :  \n> _QualifiedPathType_ (`::` _PathExprSegment_)+\n> \n> _QualifiedPathType_ :  \n> `<` [_Type_](types.html#type-expressions) (`as` _TypePath_)? `>`\n> \n> _QualifiedPathInType_ :  \n> _QualifiedPathType_ (`::` _TypePathSegment_)+\n\nFully qualified paths allow for disambiguating the path for [trait implementations](items/implementations.html#trait-implementations) and for specifying [canonical paths](#canonical-paths). When used in a type specification, it supports using the type syntax specified below.\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct S;\nimpl S {\n    fn f() { println!(\"S\"); }\n}\ntrait T1 {\n    fn f() { println!(\"T1 f\"); }\n}\nimpl T1 for S {}\ntrait T2 {\n    fn f() { println!(\"T2 f\"); }\n}\nimpl T2 for S {}\nS::f();  // Calls the inherent impl.\n<S as T1>::f();  // Calls the T1 trait function.\n<S as T2>::f();  // Calls the T2 trait function.\n}\n```\n\n### [Paths in types](#paths-in-types)\n\n> **Syntax**  \n> _TypePath_ :  \n> `::`? _TypePathSegment_ (`::` _TypePathSegment_)\\*\n> \n> _TypePathSegment_ :  \n> _PathIdentSegment_ `::`? ([_GenericArgs_](#paths-in-expressions) | _TypePathFn_)?\n> \n> _TypePathFn_ :  \n> `(` _TypePathFnInputs_? `)` (`->` [_Type_](types.html#type-expressions))?\n> \n> _TypePathFnInputs_ :  \n> [_Type_](types.html#type-expressions) (`,` [_Type_](types.html#type-expressions))\\* `,`?\n\nType paths are used within type definitions, trait bounds, type parameter bounds, and qualified paths.\n\nAlthough the `::` token is allowed before the generics arguments, it is not required because there is no ambiguity like there is in _PathInExpression_.\n\n```rust\n#![allow(unused)]\nfn main() {\nmod ops {\n    pub struct Range<T> {f1: T}\n    pub trait Index<T> {}\n    pub struct Example<'a> {f1: &'a i32}\n}\nstruct S;\nimpl ops::Index<ops::Range<usize>> for S { /*...*/ }\nfn i<'a>() -> impl Iterator<Item = ops::Example<'a>> {\n    // ...\n   const EXAMPLE: Vec<ops::Example<'static>> = Vec::new();\n   EXAMPLE.into_iter()\n}\ntype G = std::boxed::Box<dyn std::ops::FnOnce(isize) -> isize>;\n}\n```\n\n## [Path qualifiers](#path-qualifiers)\n\nPaths can be denoted with various leading qualifiers to change the meaning of how it is resolved.\n\n### [::](#)\n\nPaths starting with `::` are considered to be _global paths_ where the segments of the path start being resolved from a place which differs based on edition. Each identifier in the path must resolve to an item.\n\n> **Edition Differences**: In the 2015 Edition, identifiers resolve from the \"crate root\" (`crate::` in the 2018 edition), which contains a variety of different items, including external crates, default crates such as `std` or `core`, and items in the top level of the crate (including `use` imports).\n> \n> Beginning with the 2018 Edition, paths starting with `::` resolve from crates in the [extern prelude](names/preludes.html#extern-prelude). That is, they must be followed by the name of a crate.\n\n```rust\n#![allow(unused)]\nfn main() {\npub fn foo() {\n    // In the 2018 edition, this accesses `std` via the extern prelude.\n    // In the 2015 edition, this accesses `std` via the crate root.\n    let now = ::std::time::Instant::now();\n    println!(\"{:?}\", now);\n}\n}\n```\n\n```rust\n// 2015 Edition\nmod a {\n    pub fn foo() {}\n}\nmod b {\n    pub fn foo() {\n        ::a::foo(); // call `a`'s foo function\n        // In Rust 2018, `::a` would be interpreted as the crate `a`.\n    }\n}\nfn main() {}\n```\n\n### [self](#self)\n\n`self` resolves the path relative to the current module. `self` can only be used as the first segment, without a preceding `::`.\n\n```rust\nfn foo() {}\nfn bar() {\n    self::foo();\n}\nfn main() {}\n```\n\n### [Self](#self-1)\n\n`Self`, with a capital \"S\", is used to refer to the implementing type within[traits](items/traits.html) and [implementations](items/implementations.html).\n\n`Self` can only be used as the first segment, without a preceding `::`.\n\n```rust\n#![allow(unused)]\nfn main() {\ntrait T {\n    type Item;\n    const C: i32;\n    // `Self` will be whatever type that implements `T`.\n    fn new() -> Self;\n    // `Self::Item` will be the type alias in the implementation.\n    fn f(&self) -> Self::Item;\n}\nstruct S;\nimpl T for S {\n    type Item = i32;\n    const C: i32 = 9;\n    fn new() -> Self {           // `Self` is the type `S`.\n        S\n    }\n    fn f(&self) -> Self::Item {  // `Self::Item` is the type `i32`.\n        Self::C                  // `Self::C` is the constant value `9`.\n    }\n}\n}\n```\n\n### [super](#super)\n\n`super` in a path resolves to the parent module. It may only be used in leading segments of the path, possibly after an initial `self` segment.\n\n```rust\nmod a {\n    pub fn foo() {}\n}\nmod b {\n    pub fn foo() {\n        super::a::foo(); // call a's foo function\n    }\n}\nfn main() {}\n```\n\n`super` may be repeated several times after the first `super` or `self` to refer to ancestor modules.\n\n```rust\nmod a {\n    fn foo() {}\n\n    mod b {\n        mod c {\n            fn foo() {\n                super::super::foo(); // call a's foo function\n                self::super::super::foo(); // call a's foo function\n            }\n        }\n    }\n}\nfn main() {}\n```\n\n### [crate](#crate)\n\n`crate` resolves the path relative to the current crate. `crate` can only be used as the first segment, without a preceding `::`.\n\n```rust\nfn foo() {}\nmod a {\n    fn bar() {\n        crate::foo();\n    }\n}\nfn main() {}\n```\n\n### [$crate](#crate-1)\n\n`$crate` is only used within [macro transcribers](macros-by-example.html), and can only be used as the first segment, without a preceding `::`. `$crate` will expand to a path to access items from the top level of the crate where the macro is defined, regardless of which crate the macro is invoked.\n\n```rust\npub fn increment(x: u32) -> u32 {\n    x + 1\n}\n\n#[macro_export]\nmacro_rules! inc {\n    ($x:expr) => ( $crate::increment($x) )\n}\nfn main() { }\n```\n\n## [Canonical paths](#canonical-paths)\n\nItems defined in a module or implementation have a _canonical path_ that corresponds to where within its crate it is defined. All other paths to these items are aliases. The canonical path is defined as a _path prefix_ appended by the path segment the item itself defines.\n\n[Implementations](items/implementations.html) and [use declarations](items/use-declarations.html) do not have canonical paths, although the items that implementations define do have them. Items defined in block expressions do not have canonical paths. Items defined in a module that does not have a canonical path do not have a canonical path. Associated items defined in an implementation that refers to an item without a canonical path, e.g. as the implementing type, the trait being implemented, a type parameter or bound on a type parameter, do not have canonical paths.\n\nThe path prefix for modules is the canonical path to that module. For bare implementations, it is the canonical path of the item being implemented surrounded by angle (`<>`) brackets. For[trait implementations](items/implementations.html#trait-implementations), it is the canonical path of the item being implemented followed by `as` followed by the canonical path to the trait all surrounded inangle (`<>`) brackets.\n\nThe canonical path is only meaningful within a given crate. There is no global namespace across crates; an item's canonical path merely identifies it within the crate.\n\n```rust\n// Comments show the canonical path of the item.\n\nmod a { // crate::a\n    pub struct Struct; // crate::a::Struct\n\n    pub trait Trait { // crate::a::Trait\n        fn f(&self); // crate::a::Trait::f\n    }\n\n    impl Trait for Struct {\n        fn f(&self) {} // <crate::a::Struct as crate::a::Trait>::f\n    }\n\n    impl Struct {\n        fn g(&self) {} // <crate::a::Struct>::g\n    }\n}\n\nmod without { // crate::without\n    fn canonicals() { // crate::without::canonicals\n        struct OtherStruct; // None\n\n        trait OtherTrait { // None\n            fn g(&self); // None\n        }\n\n        impl OtherTrait for OtherStruct {\n            fn g(&self) {} // None\n        }\n\n        impl OtherTrait for crate::a::Struct {\n            fn g(&self) {} // None\n        }\n\n        impl crate::a::Trait for OtherStruct {\n            fn f(&self) {} // None\n        }\n    }\n}\n\nfn main() {}\n```\n\n[ ](names/preludes.html \"Previous chapter\") [ ](names/name-resolution.html \"Next chapter\") "}