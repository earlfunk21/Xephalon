{"lang":"Rust","fullPath":"/trait-bounds","category":"","title":"trait-bounds.html","url":"https://doc.rust-lang.org/stable/reference/trait-bounds.html","markdown":"# [Trait and lifetime bounds](#trait-and-lifetime-bounds)\n\n> **Syntax**  \n> _TypeParamBounds_ :  \n> _TypeParamBound_ ( `+` _TypeParamBound_ )\\* `+`?\n> \n> _TypeParamBound_ :  \n> _Lifetime_ | _TraitBound_\n> \n> _TraitBound_ :  \n> `?`? [_ForLifetimes_](#higher-ranked-trait-bounds)? [_TypePath_](paths.html#paths-in-types)  \n> | `(` `?`? [_ForLifetimes_](#higher-ranked-trait-bounds)? [_TypePath_](paths.html#paths-in-types) `)`\n> \n> _LifetimeBounds_ :  \n> ( _Lifetime_ `+` )\\* _Lifetime_?\n> \n> _Lifetime_ :  \n> [LIFETIME\\_OR\\_LABEL](tokens.html#lifetimes-and-loop-labels)  \n> | `'static`  \n> | `'_`\n\n[Trait](items/traits.html#trait-bounds) and lifetime bounds provide a way for [generic items](items/generics.html) to restrict which types and lifetimes are used as their parameters. Bounds can be provided on any type in a [where clause](items/generics.html#where-clauses). There are also shorter forms for certain common cases:\n\n* Bounds written after declaring a [generic parameter](items/generics.html):`fn f<A: Copy>() {}` is the same as `fn f<A>() where A: Copy {}`.\n* In trait declarations as [supertraits](items/traits.html#supertraits): `trait Circle : Shape {}` is equivalent to `trait Circle where Self : Shape {}`.\n* In trait declarations as bounds on [associated types](items/associated-items.html#associated-types):`trait A { type B: Copy; }` is equivalent to`trait A where Self::B: Copy { type B; }`.\n\nBounds on an item must be satisfied when using the item. When type checking and borrow checking a generic item, the bounds can be used to determine that a trait is implemented for a type. For example, given `Ty: Trait`\n\n* In the body of a generic function, methods from `Trait` can be called on `Ty`values. Likewise associated constants on the `Trait` can be used.\n* Associated types from `Trait` can be used.\n* Generic functions and types with a `T: Trait` bounds can be used with `Ty`being used for `T`.\n\n```rust\n#![allow(unused)]\nfn main() {\ntype Surface = i32;\ntrait Shape {\n    fn draw(&self, surface: Surface);\n    fn name() -> &'static str;\n}\n\nfn draw_twice<T: Shape>(surface: Surface, sh: T) {\n    sh.draw(surface);           // Can call method because T: Shape\n    sh.draw(surface);\n}\n\nfn copy_and_draw_twice<T: Copy>(surface: Surface, sh: T) where T: Shape {\n    let shape_copy = sh;        // doesn't move sh because T: Copy\n    draw_twice(surface, sh);    // Can use generic function because T: Shape\n}\n\nstruct Figure<S: Shape>(S, S);\n\nfn name_figure<U: Shape>(\n    figure: Figure<U>,          // Type Figure<U> is well-formed because U: Shape\n) {\n    println!(\n        \"Figure of two {}\",\n        U::name(),              // Can use associated function\n    );\n}\n}\n```\n\nBounds that don't use the item's parameters or [higher-ranked lifetimes](#higher-ranked-trait-bounds) are checked when the item is defined. It is an error for such a bound to be false.\n\n[Copy](special-types-and-traits.html#copy), [Clone](special-types-and-traits.html#clone), and [Sized](special-types-and-traits.html#sized) bounds are also checked for certain generic types when using the item, even if the use does not provide a concrete type. It is an error to have `Copy` or `Clone` as a bound on a mutable reference, [trait object](types/trait-object.html), or [slice](types/slice.html). It is an error to have `Sized` as a bound on a trait object or slice.\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct A<'a, T>\nwhere\n    i32: Default,           // Allowed, but not useful\n    i32: Iterator,          // Error: `i32` is not an iterator\n    &'a mut T: Copy,        // (at use) Error: the trait bound is not satisfied\n    [T]: Sized,             // (at use) Error: size cannot be known at compilation\n{\n    f: &'a T,\n}\nstruct UsesA<'a, T>(A<'a, T>);\n}\n```\n\nTrait and lifetime bounds are also used to name [trait objects](types/trait-object.html).\n\n## [?Sized](#sized)\n\n`?` is only used to relax the implicit [Sized](special-types-and-traits.html#sized) trait bound for [type parameters](types/parameters.html) or [associated types](items/associated-items.html#associated-types).`?Sized` may not be used as a bound for other types.\n\n## [Lifetime bounds](#lifetime-bounds)\n\nLifetime bounds can be applied to types or to other lifetimes. The bound `'a: 'b` is usually read as `'a` _outlives_ `'b`.`'a: 'b` means that `'a` lasts at least as long as `'b`, so a reference `&'a ()` is valid whenever `&'b ()` is valid.\n\n```rust\n#![allow(unused)]\nfn main() {\nfn f<'a, 'b>(x: &'a i32, mut y: &'b i32) where 'a: 'b {\n    y = x;                      // &'a i32 is a subtype of &'b i32 because 'a: 'b\n    let r: &'b &'a i32 = &&0;   // &'b &'a i32 is well formed because 'a: 'b\n}\n}\n```\n\n`T: 'a` means that all lifetime parameters of `T` outlive `'a`. For example, if `'a` is an unconstrained lifetime parameter, then `i32: 'static` and `&'static str: 'a` are satisfied, but `Vec<&'a ()>: 'static` is not.\n\n## [Higher-ranked trait bounds](#higher-ranked-trait-bounds)\n\n> _ForLifetimes_ :  \n> `for` [_GenericParams_](items/generics.html)\n\nTrait bounds may be _higher ranked_ over lifetimes. These bounds specify a bound that is true _for all_ lifetimes. For example, a bound such as `for<'a> &'a T: PartialEq<i32>` would require an implementation like\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct T;\nimpl<'a> PartialEq<i32> for &'a T {\n    // ...\n   fn eq(&self, other: &i32) -> bool {true}\n}\n}\n```\n\nand could then be used to compare a `&'a T` with any lifetime to an `i32`.\n\nOnly a higher-ranked bound can be used here, because the lifetime of the reference is shorter than any possible lifetime parameter on the function:\n\n```rust\n#![allow(unused)]\nfn main() {\nfn call_on_ref_zero<F>(f: F) where for<'a> F: Fn(&'a i32) {\n    let zero = 0;\n    f(&zero);\n}\n}\n```\n\nHigher-ranked lifetimes may also be specified just before the trait: the only difference is the scope of the lifetime parameter, which extends only to the end of the following trait instead of the whole bound. This function is equivalent to the last one.\n\n```rust\n#![allow(unused)]\nfn main() {\nfn call_on_ref_zero<F>(f: F) where F: for<'a> Fn(&'a i32) {\n    let zero = 0;\n    f(&zero);\n}\n}\n```\n\n[ ](subtyping.html \"Previous chapter\") [ ](type-coercions.html \"Next chapter\") "}