{"lang":"Rust","fullPath":"/interior-mutability","category":"","title":"interior-mutability.html","url":"https://doc.rust-lang.org/stable/reference/interior-mutability.html","markdown":"# [Interior Mutability](#interior-mutability)\n\nSometimes a type needs to be mutated while having multiple aliases. In Rust this is achieved using a pattern called _interior mutability_. A type has interior mutability if its internal state can be changed through a [shared reference](types/pointer.html#shared-references-) to it. This goes against the usual [requirement](behavior-considered-undefined.html) that the value pointed to by a shared reference is not mutated.\n\n[std::cell::UnsafeCell<T>](../std/cell/struct.UnsafeCell.html) type is the only allowed way to disable this requirement. When `UnsafeCell<T>` is immutably aliased, it is still safe to mutate, or obtain a mutable reference to, the `T` it contains. As with all other types, it is undefined behavior to have multiple `&mut UnsafeCell<T>`aliases.\n\nOther types with interior mutability can be created by using `UnsafeCell<T>` as a field. The standard library provides a variety of types that provide safe interior mutability APIs. For example, [std::cell::RefCell<T>](../std/cell/struct.RefCell.html) uses run-time borrow checks to ensure the usual rules around multiple references. The[std::sync::atomic](../std/sync/atomic/index.html) module contains types that wrap a value that is only accessed with atomic operations, allowing the value to be shared and mutated across threads.\n\n[ ](type-layout.html \"Previous chapter\") [ ](subtyping.html \"Next chapter\") "}