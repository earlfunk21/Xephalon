{"lang":"Rust","fullPath":"/subtyping","category":"","title":"subtyping.html","url":"https://doc.rust-lang.org/stable/reference/subtyping.html","markdown":"# [Subtyping and Variance](#subtyping-and-variance)\n\nSubtyping is implicit and can occur at any stage in type checking or inference. Subtyping is restricted to two cases: variance with respect to lifetimes and between types with higher ranked lifetimes. If we were to erase lifetimes from types, then the only subtyping would be due to type equality.\n\nConsider the following example: string literals always have `'static`lifetime. Nevertheless, we can assign `s` to `t`:\n\n```rust\n#![allow(unused)]\nfn main() {\nfn bar<'a>() {\n    let s: &'static str = \"hi\";\n    let t: &'a str = s;\n}\n}\n```\n\nSince `'static` outlives the lifetime parameter `'a`, `&'static str` is a subtype of `&'a str`.\n\n[Higher-ranked](../nomicon/hrtb.html) [function pointers](types/function-pointer.html) and [trait objects](types/trait-object.html) have another subtype relation. They are subtypes of types that are given by substitutions of the higher-ranked lifetimes. Some examples:\n\n```rust\n#![allow(unused)]\nfn main() {\n// Here 'a is substituted for 'static\nlet subtype: &(for<'a> fn(&'a i32) -> &'a i32) = &((|x| x) as fn(&_) -> &_);\nlet supertype: &(fn(&'static i32) -> &'static i32) = subtype;\n\n// This works similarly for trait objects\nlet subtype: &(dyn for<'a> Fn(&'a i32) -> &'a i32) = &|x| x;\nlet supertype: &(dyn Fn(&'static i32) -> &'static i32) = subtype;\n\n// We can also substitute one higher-ranked lifetime for another\nlet subtype: &(for<'a, 'b> fn(&'a i32, &'b i32))= &((|x, y| {}) as fn(&_, &_));\nlet supertype: &for<'c> fn(&'c i32, &'c i32) = subtype;\n}\n```\n\n## [Variance](#variance)\n\nVariance is a property that generic types have with respect to their arguments. A generic type's _variance_ in a parameter is how the subtyping of the parameter affects the subtyping of the type.\n\n* `F<T>` is _covariant_ over `T` if `T` being a subtype of `U` implies that`F<T>` is a subtype of `F<U>` (subtyping \"passes through\")\n* `F<T>` is _contravariant_ over `T` if `T` being a subtype of `U` implies that`F<U>` is a subtype of `F<T>`\n* `F<T>` is _invariant_ over `T` otherwise (no subtyping relation can be derived)\n\nVariance of types is automatically determined as follows\n\n| Type                        | Variance in 'a | Variance in T |\n| --------------------------- | -------------- | ------------- |\n| &'a T                       | covariant      | covariant     |\n| &'a mut T                   | covariant      | invariant     |\n| \\*const T                   | covariant      |               |\n| \\*mut T                     | invariant      |               |\n| \\[T\\] and \\[T; n\\]          | covariant      |               |\n| fn() -> T                   | covariant      |               |\n| fn(T) -> ()                 | contravariant  |               |\n| std::cell::UnsafeCell<T>    | invariant      |               |\n| std::marker::PhantomData<T> | covariant      |               |\n| dyn Trait<T> + 'a           | covariant      | invariant     |\n\nThe variance of other `struct`, `enum`, and `union` types is decided by looking at the variance of the types of their fields. If the parameter is used in positions with different variances then the parameter is invariant. For example the following struct is covariant in `'a` and `T` and invariant in `'b`, `'c`, and `U`.\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::cell::UnsafeCell;\nstruct Variance<'a, 'b, 'c, T, U: 'a> {\n    x: &'a U,               // This makes `Variance` covariant in 'a, and would\n                            // make it covariant in U, but U is used later\n    y: *const T,            // Covariant in T\n    z: UnsafeCell<&'b f64>, // Invariant in 'b\n    w: *mut U,              // Invariant in U, makes the whole struct invariant\n\n    f: fn(&'c ()) -> &'c () // Both co- and contravariant, makes 'c invariant\n                            // in the struct.\n}\n}\n```\n\nWhen used outside of an `struct`, `enum`, or `union`, the variance for parameters is checked at each location separately.\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::cell::UnsafeCell;\nfn generic_tuple<'short, 'long: 'short>(\n    // 'long is used inside of a tuple in both a co- and invariant position.\n    x: (&'long u32, UnsafeCell<&'long u32>),\n) {\n    // As the variance at these positions is computed separately,\n    // we can freely shrink 'long in the covariant position.\n    let _: (&'short u32, UnsafeCell<&'long u32>) = x;\n}\n\nfn takes_fn_ptr<'short, 'middle: 'short>(\n    // 'middle is used in both a co- and contravariant position.\n    f: fn(&'middle ()) -> &'middle (),\n) {\n    // As the variance at these positions is computed separately,\n    // we can freely shrink 'middle in the covariant position\n    // and extend it in the contravariant position.\n    let _: fn(&'static ()) -> &'short () = f;\n}\n}\n```\n\n[ ](interior-mutability.html \"Previous chapter\") [ ](trait-bounds.html \"Next chapter\") "}