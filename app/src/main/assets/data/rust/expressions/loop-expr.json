{"lang":"Rust","fullPath":"/expressions/loop-expr","category":"expressions","title":"loop-expr","url":"https://doc.rust-lang.org/stable/reference/expressions/loop-expr.html","markdown":"# [Loops and other breakable expressions](#loops-and-other-breakable-expressions)\n\n> **Syntax**  \n> _LoopExpression_ :  \n> [_LoopLabel_](#loop-labels)? (  \n> [_InfiniteLoopExpression_](#infinite-loops)  \n> | [_PredicateLoopExpression_](#predicate-loops)  \n> | [_PredicatePatternLoopExpression_](#predicate-pattern-loops)  \n> | [_IteratorLoopExpression_](#iterator-loops)  \n> | [_LabelBlockExpression_](#labelled-block-expressions)  \n> )\n\nRust supports five loop expressions:\n\n* A [loop expression](#infinite-loops) denotes an infinite loop.\n* A [while expression](#predicate-loops) loops until a predicate is false.\n* A [while let expression](#predicate-pattern-loops) tests a pattern.\n* A [for expression](#iterator-loops) extracts values from an iterator, looping until the iterator is empty.\n* A [labelled block expression](#labelled-block-expressions) runs a loop exactly once, but allows exiting the loop early with `break`.\n\nAll five types of loop support [break expressions](#break-expressions), and [labels](#loop-labels). All except labelled block expressions support [continue expressions](#continue-expressions). Only `loop` and labelled block expressions support [evaluation to non-trivial values](#break-and-loop-values).\n\n## [Infinite loops](#infinite-loops)\n\n> **Syntax**  \n> _InfiniteLoopExpression_ :  \n> `loop` [_BlockExpression_](block-expr.html)\n\nA `loop` expression repeats execution of its body continuously:`loop { println!(\"I live.\"); }`.\n\nA `loop` expression without an associated `break` expression is diverging and has type [!](../types/never.html). A `loop` expression containing associated [break expression(s)](#break-expressions) may terminate, and must have type compatible with the value of the `break` expression(s).\n\n## [Predicate loops](#predicate-loops)\n\n> **Syntax**  \n> _PredicateLoopExpression_ :  \n> `while` [_Expression_](../expressions.html)_except struct expression_ [_BlockExpression_](block-expr.html)\n\nA `while` loop begins by evaluating the [boolean](../types/boolean.html) loop conditional operand. If the loop conditional operand evaluates to `true`, the loop body block executes, then control returns to the loop conditional operand. If the loop conditional expression evaluates to `false`, the `while` expression completes.\n\nAn example:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet mut i = 0;\n\nwhile i < 10 {\n    println!(\"hello\");\n    i = i + 1;\n}\n}\n```\n\n## [Predicate pattern loops](#predicate-pattern-loops)\n\n> **Syntax**  \n> [_PredicatePatternLoopExpression_](#predicate-pattern-loops) :  \n> `while` `let` [_Pattern_](../patterns.html) `=` [_Scrutinee_](match-expr.html)_except lazy boolean operator expression_ [_BlockExpression_](block-expr.html)\n\nA `while let` loop is semantically similar to a `while` loop but in place of a condition expression it expects the keyword `let` followed by a pattern, an `=`, a [scrutinee](../glossary.html#scrutinee) expression and a block expression. If the value of the scrutinee matches the pattern, the loop body block executes then control returns to the pattern matching statement. Otherwise, the while expression completes.\n\n```rust\n#![allow(unused)]\nfn main() {\nlet mut x = vec![1, 2, 3];\n\nwhile let Some(y) = x.pop() {\n    println!(\"y = {}\", y);\n}\n\nwhile let _ = 5 {\n    println!(\"Irrefutable patterns are always true\");\n    break;\n}\n}\n```\n\nA `while let` loop is equivalent to a `loop` expression containing a [match expression](match-expr.html) as follows.\n\n```rust\n'label: while let PATS = EXPR {\n    /* loop body */\n}\n```\n\nis equivalent to\n\n```rust\n'label: loop {\n    match EXPR {\n        PATS => { /* loop body */ },\n        _ => break,\n    }\n}\n```\n\nMultiple patterns may be specified with the `|` operator. This has the same semantics as with `|` in `match` expressions:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet mut vals = vec![2, 3, 1, 2, 2];\nwhile let Some(v @ 1) | Some(v @ 2) = vals.pop() {\n    // Prints 2, 2, then 1\n    println!(\"{}\", v);\n}\n}\n```\n\nAs is the case in [if let expressions](if-expr.html#if-let-expressions), the scrutinee cannot be a [lazy boolean operator expression](operator-expr.html#lazy-boolean-operators).\n\n## [Iterator loops](#iterator-loops)\n\n> **Syntax**  \n> _IteratorLoopExpression_ :  \n> `for` [_Pattern_](../patterns.html) `in` [_Expression_](../expressions.html)_except struct expression_ [_BlockExpression_](block-expr.html)\n\nA `for` expression is a syntactic construct for looping over elements provided by an implementation of `std::iter::IntoIterator`. If the iterator yields a value, that value is matched against the irrefutable pattern, the body of the loop is executed, and then control returns to the head of the `for` loop. If the iterator is empty, the `for` expression completes.\n\nAn example of a `for` loop over the contents of an array:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet v = &[\"apples\", \"cake\", \"coffee\"];\n\nfor text in v {\n    println!(\"I like {}.\", text);\n}\n}\n```\n\nAn example of a for loop over a series of integers:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet mut sum = 0;\nfor n in 1..11 {\n    sum += n;\n}\nassert_eq!(sum, 55);\n}\n```\n\nA `for` loop is equivalent to a `loop` expression containing a [match expression](match-expr.html) as follows:\n\n```rust\n'label: for PATTERN in iter_expr {\n    /* loop body */\n}\n```\n\nis equivalent to\n\n```rust\n{\n    let result = match IntoIterator::into_iter(iter_expr) {\n        mut iter => 'label: loop {\n            let mut next;\n            match Iterator::next(&mut iter) {\n                Option::Some(val) => next = val,\n                Option::None => break,\n            };\n            let PATTERN = next;\n            let () = { /* loop body */ };\n        },\n    };\n    result\n}\n```\n\n`IntoIterator`, `Iterator`, and `Option` are always the standard library items here, not whatever those names resolve to in the current scope. The variable names `next`, `iter`, and `val` are for exposition only, they do not actually have names the user can type.\n\n> **Note**: that the outer `match` is used to ensure that any [temporary values](../expressions.html#temporaries) in `iter_expr` don't get dropped before the loop is finished.`next` is declared before being assigned because it results in types being inferred correctly more often.\n\n## [Loop labels](#loop-labels)\n\n> **Syntax**  \n> _LoopLabel_ :  \n> [LIFETIME\\_OR\\_LABEL](../tokens.html#lifetimes-and-loop-labels) `:`\n\nA loop expression may optionally have a _label_. The label is written as a lifetime preceding the loop expression, as in `'foo: loop { break 'foo; }`, `'bar: while false {}`, `'humbug: for _ in 0..0 {}`. If a label is present, then labeled `break` and `continue` expressions nested within this loop may exit out of this loop or return control to its head. See [break expressions](#break-expressions) and [continue expressions](#continue-expressions).\n\nLabels follow the hygiene and shadowing rules of local variables. For example, this code will print \"outer loop\":\n\n```rust\n#![allow(unused)]\nfn main() {\n'a: loop {\n    'a: loop {\n        break 'a;\n    }\n    print!(\"outer loop\");\n    break 'a;\n}\n}\n```\n\n## [break expressions](#break-expressions)\n\n> **Syntax**  \n> _BreakExpression_ :  \n> `break` [LIFETIME\\_OR\\_LABEL](../tokens.html#lifetimes-and-loop-labels)? [_Expression_](../expressions.html)?\n\nWhen `break` is encountered, execution of the associated loop body is immediately terminated, for example:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet mut last = 0;\nfor x in 1..100 {\n    if x > 12 {\n        break;\n    }\n    last = x;\n}\nassert_eq!(last, 12);\n}\n```\n\nA `break` expression is normally associated with the innermost `loop`, `for` or `while` loop enclosing the `break` expression, but a [label](#loop-labels) can be used to specify which enclosing loop is affected. Example:\n\n```rust\n#![allow(unused)]\nfn main() {\n'outer: loop {\n    while true {\n        break 'outer;\n    }\n}\n}\n```\n\nA `break` expression is only permitted in the body of a loop, and has one of the forms `break`, `break 'label` or ([see below](#break-and-loop-values)) `break EXPR` or `break 'label EXPR`.\n\n## [Labelled block expressions](#labelled-block-expressions)\n\n> **Syntax**  \n> _LabelBlockExpression_ :  \n> [_BlockExpression_](block-expr.html)\n\nLabelled block expressions are exactly like block expressions, except that they allow using `break` expressions within the block. Unlike other loops, `break` expressions within a label expression _must_ have a label (i.e. the label is not optional). Unlike other loops, labelled block expressions _must_ begin with a label.\n\n## [continue expressions](#continue-expressions)\n\n> **Syntax**  \n> _ContinueExpression_ :  \n> `continue` [LIFETIME\\_OR\\_LABEL](../tokens.html#lifetimes-and-loop-labels)?\n\nWhen `continue` is encountered, the current iteration of the associated loop body is immediately terminated, returning control to the loop _head_. In the case of a `while` loop, the head is the conditional expression controlling the loop. In the case of a `for` loop, the head is the call-expression controlling the loop.\n\nLike `break`, `continue` is normally associated with the innermost enclosing loop, but `continue 'label` may be used to specify the loop affected. A `continue` expression is only permitted in the body of a loop.\n\n## [break and loop values](#break-and-loop-values)\n\nWhen associated with a `loop`, a break expression may be used to return a value from that loop, via one of the forms `break EXPR` or `break 'label EXPR`, where `EXPR` is an expression whose result is returned from the `loop`. For example:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet (mut a, mut b) = (1, 1);\nlet result = loop {\n    if b > 10 {\n        break b;\n    }\n    let c = a + b;\n    a = b;\n    b = c;\n};\n// first number in Fibonacci sequence over 10:\nassert_eq!(result, 13);\n}\n```\n\nIn the case a `loop` has an associated `break`, it is not considered diverging, and the `loop` must have a type compatible with each `break` expression.`break` without an expression is considered identical to `break` with expression `()`.\n\n[ ](../expressions/closure-expr.html \"Previous chapter\") [ ](../expressions/range-expr.html \"Next chapter\") "}