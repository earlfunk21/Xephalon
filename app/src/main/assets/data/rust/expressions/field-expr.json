{"lang":"Rust","fullPath":"/expressions/field-expr","category":"expressions","title":"field-expr","url":"https://doc.rust-lang.org/stable/reference/expressions/field-expr.html","markdown":"# [Field access expressions](#field-access-expressions)\n\n> **Syntax**  \n> _FieldExpression_ :  \n> [_Expression_](../expressions.html) `.` [IDENTIFIER](../identifiers.html)\n\nA _field expression_ is a [place expression](../expressions.html#place-expressions-and-value-expressions) that evaluates to the location of a field of a [struct](../items/structs.html) or [union](../items/unions.html). When the operand is [mutable](../expressions.html#mutability), the field expression is also mutable.\n\nThe syntax for a field expression is an expression, called the _container operand_, then a `.`, and finally an [identifier](../identifiers.html). Field expressions cannot be followed by a parenthetical comma-separated list of expressions, as that is instead parsed as a [method call expression](method-call-expr.html). That is, they cannot be the function operand of a [call expression](call-expr.html).\n\n> **Note**: Wrap the field expression in a [parenthesized expression](grouped-expr.html) to use it in a call expression.\n> \n> ```rust\n> #![allow(unused)]\n> fn main() {\n> struct HoldsCallable<F: Fn()> { callable: F }\n> let holds_callable = HoldsCallable { callable: || () };\n> \n> // Invalid: Parsed as calling the method \"callable\"\n> // holds_callable.callable();\n> \n> // Valid\n> (holds_callable.callable)();\n> }\n> ```\n\nExamples:\n\n```rust\nmystruct.myfield;\nfoo().x;\n(Struct {a: 10, b: 20}).a;\n(mystruct.function_field)() // Call expression containing a field expression\n```\n\n## [Automatic dereferencing](#automatic-dereferencing)\n\nIf the type of the container operand implements [Deref](../special-types-and-traits.html#deref-and-derefmut) or [DerefMut](../special-types-and-traits.html#deref-and-derefmut) depending on whether the operand is [mutable](../expressions.html#mutability), it is _automatically dereferenced_ as many times as necessary to make the field access possible. This process is also called _autoderef_ for short.\n\n## [Borrowing](#borrowing)\n\nThe fields of a struct or a reference to a struct are treated as separate entities when borrowing. If the struct does not implement [Drop](../special-types-and-traits.html#drop) and is stored in a local variable, this also applies to moving out of each of its fields. This also does not apply if automatic dereferencing is done though user-defined types other than [Box](../special-types-and-traits.html#boxt).\n\n```rust\n#![allow(unused)]\nfn main() {\nstruct A { f1: String, f2: String, f3: String }\nlet mut x: A;\nx = A {\n    f1: \"f1\".to_string(),\n    f2: \"f2\".to_string(),\n    f3: \"f3\".to_string()\n};\nlet a: &mut String = &mut x.f1; // x.f1 borrowed mutably\nlet b: &String = &x.f2;         // x.f2 borrowed immutably\nlet c: &String = &x.f2;         // Can borrow again\nlet d: String = x.f3;           // Move out of x.f3\n}\n```\n\n[ ](../expressions/method-call-expr.html \"Previous chapter\") [ ](../expressions/closure-expr.html \"Next chapter\") "}