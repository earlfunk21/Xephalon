{"lang":"Rust","fullPath":"/expressions/closure-expr","category":"expressions","title":"closure-expr","url":"https://doc.rust-lang.org/stable/reference/expressions/closure-expr.html","markdown":"# [Closure expressions](#closure-expressions)\n\n> **Syntax**  \n> _ClosureExpression_ :  \n> `move`?  \n> ( `||` | `|` _ClosureParameters_? `|` )  \n> ([_Expression_](../expressions.html) | `->` [_TypeNoBounds_](../types.html#type-expressions) [_BlockExpression_](block-expr.html))\n> \n> _ClosureParameters_ :  \n> _ClosureParam_ (`,` _ClosureParam_)\\* `,`?\n> \n> _ClosureParam_ :  \n> [_OuterAttribute_](../attributes.html)\\* [_PatternNoTopAlt_](../patterns.html) ( `:` [_Type_](../types.html#type-expressions) )?\n\nA _closure expression_, also known as a lambda expression or a lambda, defines a [closure type](../types/closure.html) and evaluates to a value of that type. The syntax for a closure expression is an optional `move` keyword, then a pipe-symbol-delimited (`|`) comma-separated list of [patterns](../patterns.html), called the _closure parameters_ each optionally followed by a `:` and a type, then an optional `->` and type, called the _return type_, and then an expression, called the _closure body operand_. The optional type after each pattern is a type annotation for the pattern. If there is a return type, the closure body must be a [block](block-expr.html).\n\nA closure expression denotes a function that maps a list of parameters onto the expression that follows the parameters. Just like a [let binding](../statements.html#let-statements), the closure parameters are irrefutable [patterns](../patterns.html), whose type annotation is optional and will be inferred from context if not given. Each closure expression has a unique, anonymous type.\n\nSignificantly, closure expressions _capture their environment_, which regular [function definitions](../items/functions.html) do not. Without the `move` keyword, the closure expression [infers how it captures each variable from its environment](../types/closure.html#capture-modes), preferring to capture by shared reference, effectively borrowing all outer variables mentioned inside the closure's body. If needed the compiler will infer that instead mutable references should be taken, or that the values should be moved or copied (depending on their type) from the environment. A closure can be forced to capture its environment by copying or moving values by prefixing it with the `move` keyword. This is often used to ensure that the closure's lifetime is `'static`.\n\n## [Closure trait implementations](#closure-trait-implementations)\n\nWhich traits the closure type implement depends on how variables are captured and the types of the captured variables. See the [call traits and coercions](../types/closure.html#call-traits-and-coercions) chapter for how and when a closure implements `Fn`, `FnMut`, and `FnOnce`. The closure type implements [Send](../special-types-and-traits.html#send) and [Sync](../special-types-and-traits.html#sync) if the type of every captured variable also implements the trait.\n\n## [Example](#example)\n\nIn this example, we define a function `ten_times` that takes a higher-order function argument, and we then call it with a closure expression as an argument, followed by a closure expression that moves values from its environment.\n\n```rust\n#![allow(unused)]\nfn main() {\nfn ten_times<F>(f: F) where F: Fn(i32) {\n    for index in 0..10 {\n        f(index);\n    }\n}\n\nten_times(|j| println!(\"hello, {}\", j));\n// With type annotations\nten_times(|j: i32| -> () { println!(\"hello, {}\", j) });\n\nlet word = \"konnichiwa\".to_owned();\nten_times(move |j| println!(\"{}, {}\", word, j));\n}\n```\n\n## [Attributes on closure parameters](#attributes-on-closure-parameters)\n\nAttributes on closure parameters follow the same rules and restrictions as [regular function parameters](../items/functions.html#attributes-on-function-parameters).\n\n[ ](../expressions/field-expr.html \"Previous chapter\") [ ](../expressions/loop-expr.html \"Next chapter\") "}