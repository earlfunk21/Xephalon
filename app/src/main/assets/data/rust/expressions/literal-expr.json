{"lang":"Rust","fullPath":"/expressions/literal-expr","category":"expressions","title":"literal-expr","url":"https://doc.rust-lang.org/stable/reference/expressions/literal-expr.html","markdown":"# [Literal expressions](#literal-expressions)\n\n> **Syntax**  \n> _LiteralExpression_ :  \n> [CHAR\\_LITERAL](../tokens.html#character-literals)  \n> | [STRING\\_LITERAL](../tokens.html#string-literals)  \n> | [RAW\\_STRING\\_LITERAL](../tokens.html#raw-string-literals)  \n> | [BYTE\\_LITERAL](../tokens.html#byte-literals)  \n> | [BYTE\\_STRING\\_LITERAL](../tokens.html#byte-string-literals)  \n> | [RAW\\_BYTE\\_STRING\\_LITERAL](../tokens.html#raw-byte-string-literals)  \n> | [INTEGER\\_LITERAL](../tokens.html#integer-literals)  \n> | [FLOAT\\_LITERAL](../tokens.html#floating-point-literals)  \n> | `true` | `false`\n\nA _literal expression_ is an expression consisting of a single token, rather than a sequence of tokens, that immediately and directly denotes the value it evaluates to, rather than referring to it by name or some other evaluation rule.\n\nA literal is a form of [constant expression](../const%5Feval.html#constant-expressions), so is evaluated (primarily) at compile time.\n\nEach of the lexical [literal](../tokens.html#literals) forms described earlier can make up a literal expression, as can the keywords `true` and `false`.\n\n```rust\n#![allow(unused)]\nfn main() {\n\"hello\";   // string type\n'5';       // character type\n5;         // integer type\n}\n```\n\n## [Character literal expressions](#character-literal-expressions)\n\nA character literal expression consists of a single [CHAR\\_LITERAL](../tokens.html#character-literals) token.\n\n> **Note**: This section is incomplete.\n\n## [String literal expressions](#string-literal-expressions)\n\nA string literal expression consists of a single [STRING\\_LITERAL](../tokens.html#string-literals) or [RAW\\_STRING\\_LITERAL](../tokens.html#raw-string-literals) token.\n\n> **Note**: This section is incomplete.\n\n## [Byte literal expressions](#byte-literal-expressions)\n\nA byte literal expression consists of a single [BYTE\\_LITERAL](../tokens.html#byte-literals) token.\n\n> **Note**: This section is incomplete.\n\n## [Byte string literal expressions](#byte-string-literal-expressions)\n\nA string literal expression consists of a single [BYTE\\_STRING\\_LITERAL](../tokens.html#byte-string-literals) or [RAW\\_BYTE\\_STRING\\_LITERAL](../tokens.html#raw-byte-string-literals) token.\n\n> **Note**: This section is incomplete.\n\n## [Integer literal expressions](#integer-literal-expressions)\n\nAn integer literal expression consists of a single [INTEGER\\_LITERAL](../tokens.html#integer-literals) token.\n\nIf the token has a [suffix](../tokens.html#suffixes), the suffix must be the name of one of the [primitive integer types](../types/numeric.html): `u8`, `i8`, `u16`, `i16`, `u32`, `i32`, `u64`, `i64`, `u128`, `i128`, `usize`, or `isize`, and the expression has that type.\n\nIf the token has no suffix, the expression's type is determined by type inference:\n\n* If an integer type can be _uniquely_ determined from the surrounding program context, the expression has that type.\n* If the program context under-constrains the type, it defaults to the signed 32-bit integer `i32`.\n* If the program context over-constrains the type, it is considered a static type error.\n\nExamples of integer literal expressions:\n\n```rust\n#![allow(unused)]\nfn main() {\n123;                               // type i32\n123i32;                            // type i32\n123u32;                            // type u32\n123_u32;                           // type u32\nlet a: u64 = 123;                  // type u64\n\n0xff;                              // type i32\n0xff_u8;                           // type u8\n\n0o70;                              // type i32\n0o70_i16;                          // type i16\n\n0b1111_1111_1001_0000;             // type i32\n0b1111_1111_1001_0000i64;          // type i64\n\n0usize;                            // type usize\n}\n```\n\nThe value of the expression is determined from the string representation of the token as follows:\n\n* An integer radix is chosen by inspecting the first two characters of the string, as follows:  \n   * `0b` indicates radix 2  \n   * `0o` indicates radix 8  \n   * `0x` indicates radix 16  \n   * otherwise the radix is 10.\n* If the radix is not 10, the first two characters are removed from the string.\n* Any suffix is removed from the string.\n* Any underscores are removed from the string.\n* The string is converted to a `u128` value as if by [u128::from\\_str\\_radix](../../core/primitive.u128.html#method.from%5Fstr%5Fradix) with the chosen radix. If the value does not fit in `u128`, it is a compiler error.\n* The `u128` value is converted to the expression's type via a [numeric cast](operator-expr.html#numeric-cast).\n\n> **Note**: The final cast will truncate the value of the literal if it does not fit in the expression's type.`rustc` includes a [lint check](../attributes/diagnostics.html#lint-check-attributes) named `overflowing_literals`, defaulting to `deny`, which rejects expressions where this occurs.\n\n> **Note**: `-1i8`, for example, is an application of the [negation operator](operator-expr.html#negation-operators) to the literal expression `1i8`, not a single integer literal expression. See [Overflow](operator-expr.html#overflow) for notes on representing the most negative value for a signed type.\n\n## [Floating-point literal expressions](#floating-point-literal-expressions)\n\nA floating-point literal expression has one of two forms:\n\n* a single [FLOAT\\_LITERAL](../tokens.html#floating-point-literals) token\n* a single [INTEGER\\_LITERAL](../tokens.html#integer-literals) token which has a suffix and no radix indicator\n\nIf the token has a [suffix](../tokens.html#suffixes), the suffix must be the name of one of the [primitive floating-point types](../types/numeric.html#floating-point-types): `f32` or `f64`, and the expression has that type.\n\nIf the token has no suffix, the expression's type is determined by type inference:\n\n* If a floating-point type can be _uniquely_ determined from the surrounding program context, the expression has that type.\n* If the program context under-constrains the type, it defaults to `f64`.\n* If the program context over-constrains the type, it is considered a static type error.\n\nExamples of floating-point literal expressions:\n\n```rust\n#![allow(unused)]\nfn main() {\n123.0f64;        // type f64\n0.1f64;          // type f64\n0.1f32;          // type f32\n12E+99_f64;      // type f64\n5f32;            // type f32\nlet x: f64 = 2.; // type f64\n}\n```\n\nThe value of the expression is determined from the string representation of the token as follows:\n\n* Any suffix is removed from the string.\n* Any underscores are removed from the string.\n* The string is converted to the expression's type as if by [f32::from\\_str](../../core/primitive.f32.html#method.from%5Fstr) or [f64::from\\_str](../../core/primitive.f64.html#method.from%5Fstr).\n\n> **Note**: `-1.0`, for example, is an application of the [negation operator](operator-expr.html#negation-operators) to the literal expression `1.0`, not a single floating-point literal expression.\n\n> **Note**: `inf` and `NaN` are not literal tokens. The [f32::INFINITY](../../core/primitive.f32.html#associatedconstant.INFINITY), [f64::INFINITY](../../core/primitive.f64.html#associatedconstant.INFINITY), [f32::NAN](../../core/primitive.f32.html#associatedconstant.NAN), and [f64::NAN](../../core/primitive.f64.html#associatedconstant.NAN) constants can be used instead of literal expressions. In `rustc`, a literal large enough to be evaluated as infinite will trigger the `overflowing_literals` lint check.\n\n## [Boolean literal expressions](#boolean-literal-expressions)\n\nA boolean literal expression consists of one of the keywords `true` or `false`.\n\nThe expression's type is the primitive [boolean type](../types/boolean.html), and its value is:\n\n* true if the keyword is `true`\n* false if the keyword is `false`\n\n[ ](../expressions.html \"Previous chapter\") [ ](../expressions/path-expr.html \"Next chapter\") "}