{"lang":"Rust","fullPath":"/expressions/call-expr","category":"expressions","title":"call-expr","url":"https://doc.rust-lang.org/stable/reference/expressions/call-expr.html","markdown":"# [Call expressions](#call-expressions)\n\n> **Syntax**  \n> _CallExpression_ :  \n> [_Expression_](../expressions.html) `(` _CallParams_? `)`\n> \n> _CallParams_ :  \n> [_Expression_](../expressions.html) ( `,` [_Expression_](../expressions.html) )\\* `,`?\n\nA _call expression_ calls a function. The syntax of a call expression is an expression, called the _function operand_, followed by a parenthesized comma-separated list of expression, called the _argument operands_. If the function eventually returns, then the expression completes. For [non-function types](../types/function-item.html), the expression `f(...)` uses the method on one of the [std::ops::Fn](../../std/ops/trait.Fn.html), [std::ops::FnMut](../../std/ops/trait.FnMut.html) or [std::ops::FnOnce](../../std/ops/trait.FnOnce.html) traits, which differ in whether they take the type by reference, mutable reference, or take ownership respectively. An automatic borrow will be taken if needed. The function operand will also be [automatically dereferenced](field-expr.html#automatic-dereferencing) as required.\n\nSome examples of call expressions:\n\n```rust\n#![allow(unused)]\nfn main() {\nfn add(x: i32, y: i32) -> i32 { 0 }\nlet three: i32 = add(1i32, 2i32);\nlet name: &'static str = (|| \"Rust\")();\n}\n```\n\n## [Disambiguating Function Calls](#disambiguating-function-calls)\n\nAll function calls are sugar for a more explicit [fully-qualified syntax](../paths.html#qualified-paths). Function calls may need to be fully qualified, depending on the ambiguity of a call in light of in-scope items.\n\n> **Note**: In the past, the terms \"Unambiguous Function Call Syntax\", \"Universal Function Call Syntax\", or \"UFCS\", have been used in documentation, issues, RFCs, and other community writings. However, these terms lack descriptive power and potentially confuse the issue at hand. We mention them here for searchability's sake.\n\nSeveral situations often occur which result in ambiguities about the receiver or referent of method or associated function calls. These situations may include:\n\n* Multiple in-scope traits define methods with the same name for the same types\n* Auto-`deref` is undesirable; for example, distinguishing between methods on a smart pointer itself and the pointer's referent\n* Methods which take no arguments, like [default()](../../std/default/trait.Default.html#tymethod.default), and return properties of a type, like [size\\_of()](../../std/mem/fn.size%5Fof.html)\n\nTo resolve the ambiguity, the programmer may refer to their desired method or function using more specific paths, types, or traits.\n\nFor example,\n\n```rust\ntrait Pretty {\n    fn print(&self);\n}\n\ntrait Ugly {\n  fn print(&self);\n}\n\nstruct Foo;\nimpl Pretty for Foo {\n    fn print(&self) {}\n}\n\nstruct Bar;\nimpl Pretty for Bar {\n    fn print(&self) {}\n}\nimpl Ugly for Bar {\n    fn print(&self) {}\n}\n\nfn main() {\n    let f = Foo;\n    let b = Bar;\n\n    // we can do this because we only have one item called `print` for `Foo`s\n    f.print();\n    // more explicit, and, in the case of `Foo`, not necessary\n    Foo::print(&f);\n    // if you're not into the whole brevity thing\n    <Foo as Pretty>::print(&f);\n\n    // b.print(); // Error: multiple 'print' found\n    // Bar::print(&b); // Still an error: multiple `print` found\n\n    // necessary because of in-scope items defining `print`\n    <Bar as Pretty>::print(&b);\n}\n```\n\nRefer to [RFC 132](https://github.com/rust-lang/rfcs/blob/master/text/0132-ufcs.md) for further details and motivations.\n\n[ ](../expressions/struct-expr.html \"Previous chapter\") [ ](../expressions/method-call-expr.html \"Next chapter\") "}