{"lang":"Rust","fullPath":"/expressions/tuple-expr","category":"expressions","title":"tuple-expr","url":"https://doc.rust-lang.org/stable/reference/expressions/tuple-expr.html","markdown":"# [Tuple and tuple indexing expressions](#tuple-and-tuple-indexing-expressions)\n\n## [Tuple expressions](#tuple-expressions)\n\n> **Syntax**  \n> _TupleExpression_ :  \n> `(` _TupleElements_? `)`\n> \n> _TupleElements_ :  \n> ( [_Expression_](../expressions.html) `,` )+ [_Expression_](../expressions.html)?\n\nA _tuple expression_ constructs [tuple values](../types/tuple.html).\n\nThe syntax for tuple expressions is a parenthesized, comma separated list of expressions, called the _tuple initializer operands_. 1-ary tuple expressions require a comma after their tuple initializer operand to be disambiguated with a [parenthetical expression](grouped-expr.html).\n\nTuple expressions are a [value expression](../expressions.html#place-expressions-and-value-expressions) that evaluate into a newly constructed value of a tuple type. The number of tuple initializer operands is the arity of the constructed tuple. Tuple expressions without any tuple initializer operands produce the unit tuple. For other tuple expressions, the first written tuple initializer operand initializes the field `0` and subsequent operands initializes the next highest field. For example, in the tuple expression `('a', 'b', 'c')`, `'a'` initializes the value of the field `0`, `'b'` field `1`, and `'c'` field `2`.\n\nExamples of tuple expressions and their types:\n\n| Expression           | Type                        |\n| -------------------- | --------------------------- |\n| ()                   | () (unit)                   |\n| (0.0, 4.5)           | (f64, f64)                  |\n| (\"x\".to\\_string(), ) | (String, )                  |\n| (\"a\", 4usize, true)  | (&'static str, usize, bool) |\n\n## [Tuple indexing expressions](#tuple-indexing-expressions)\n\n> **Syntax**  \n> _TupleIndexingExpression_ :  \n> [_Expression_](../expressions.html) `.` [TUPLE\\_INDEX](../tokens.html#tuple-index)\n\nA _tuple indexing expression_ accesses fields of [tuples](../types/tuple.html) and [tuple structs](../types/struct.html).\n\nThe syntax for a tuple index expression is an expression, called the _tuple operand_, then a `.`, then finally a tuple index. The syntax for the _tuple index_ is a [decimal literal](../tokens.html#integer-literals) with no leading zeros, underscores, or suffix. For example `0` and `2` are valid tuple indices but not `01`, `0_`, nor `0i32`.\n\nThe type of the tuple operand must be a [tuple type](../types/tuple.html) or a [tuple struct](../types/struct.html). The tuple index must be a name of a field of the type of the tuple operand.\n\nEvaluation of tuple index expressions has no side effects beyond evaluation of its tuple operand. As a [place expression](../expressions.html#place-expressions-and-value-expressions), it evaluates to the location of the field of the tuple operand with the same name as the tuple index.\n\nExamples of tuple indexing expressions:\n\n```rust\n#![allow(unused)]\nfn main() {\n// Indexing a tuple\nlet pair = (\"a string\", 2);\nassert_eq!(pair.1, 2);\n\n// Indexing a tuple struct\nstruct Point(f32, f32);\nlet point = Point(1.0, 0.0);\nassert_eq!(point.0, 1.0);\nassert_eq!(point.1, 0.0);\n}\n```\n\n> **Note**: Unlike field access expressions, tuple index expressions can be the function operand of a [call expression](./call-expr.html) as it cannot be confused with a method call since method names cannot be numbers.\n\n> **Note**: Although arrays and slices also have elements, you must use an [array or slice indexing expression](array-expr.html#array-and-slice-indexing-expressions) or a [slice pattern](../patterns.html#slice-patterns) to access their elements.\n\n[ ](../expressions/array-expr.html \"Previous chapter\") [ ](../expressions/struct-expr.html \"Next chapter\") "}