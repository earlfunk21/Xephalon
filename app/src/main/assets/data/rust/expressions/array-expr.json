{"lang":"Rust","fullPath":"/expressions/array-expr","category":"expressions","title":"array-expr","url":"https://doc.rust-lang.org/stable/reference/expressions/array-expr.html","markdown":"# [Array and array index expressions](#array-and-array-index-expressions)\n\n## [Array expressions](#array-expressions)\n\n> **Syntax**  \n> _ArrayExpression_ :  \n> `[` _ArrayElements_? `]`\n> \n> _ArrayElements_ :  \n> [_Expression_](../expressions.html) ( `,` [_Expression_](../expressions.html) )\\* `,`?  \n> | [_Expression_](../expressions.html) `;` [_Expression_](../expressions.html)\n\n_Array expressions_ construct [arrays](../types/array.html). Array expressions come in two forms.\n\nThe first form lists out every value in the array. The syntax for this form is a comma-separated list of expressions of uniform type enclosed in square brackets. This produces an array containing each of these values in the order they are written.\n\nThe syntax for the second form is two expressions separated by a semicolon (`;`) enclosed in square brackets. The expression before the `;` is called the _repeat operand_. The expression after the `;` is called the _length operand_. It must have type `usize` and be a [constant expression](../const%5Feval.html#constant-expressions), such as a [literal](../tokens.html#literals) or a [constant item](../items/constant-items.html). An array expression of this form creates an array with the length of the value of the length operand with each element being a copy of the repeat operand. That is, `[a; b]` creates an array containing `b` copies of the value of `a`. If the length operand has a value greater than 1 then this requires that the type of the repeat operand is [Copy](../special-types-and-traits.html#copy) or that it must be a [path](path-expr.html) to a constant item.\n\nWhen the repeat operand is a constant item, it is evaluated the length operand's value times. If that value is `0`, then the constant item is not evaluated at all. For expressions that are not a constant item, it is evaluated exactly once, and then the result is copied the length operand's value times.\n\n```rust\n#![allow(unused)]\nfn main() {\n[1, 2, 3, 4];\n[\"a\", \"b\", \"c\", \"d\"];\n[0; 128];              // array with 128 zeros\n[0u8, 0u8, 0u8, 0u8,];\n[[1, 0, 0], [0, 1, 0], [0, 0, 1]]; // 2D array\nconst EMPTY: Vec<i32> = Vec::new();\n[EMPTY; 2];\n}\n```\n\n## [Array and slice indexing expressions](#array-and-slice-indexing-expressions)\n\n> **Syntax**  \n> _IndexExpression_ :  \n> [_Expression_](../expressions.html) `[` [_Expression_](../expressions.html) `]`\n\n[Array](../types/array.html) and [slice](../types/slice.html)\\-typed values can be indexed by writing a square-bracket-enclosed expression of type `usize` (the index) after them. When the array is mutable, the resulting [memory location](../expressions.html#place-expressions-and-value-expressions) can be assigned to.\n\nFor other types an index expression `a[b]` is equivalent to `*std::ops::Index::index(&a, b)`, or `*std::ops::IndexMut::index_mut(&mut a, b)` in a mutable place expression context. Just as with methods, Rust will also insert dereference operations on `a` repeatedly to find an implementation.\n\nIndices are zero-based for arrays and slices. Array access is a [constant expression](../const%5Feval.html#constant-expressions), so bounds can be checked at compile-time with a constant index value. Otherwise a check will be performed at run-time that will put the thread in a _panicked state_ if it fails.\n\n```rust\n#![allow(unused)]\nfn main() {\n// lint is deny by default.\n#![warn(unconditional_panic)]\n\n([1, 2, 3, 4])[2];        // Evaluates to 3\n\nlet b = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];\nb[1][2];                  // multidimensional array indexing\n\nlet x = ([\"a\", \"b\"])[10]; // warning: index out of bounds\n\nlet n = 10;\nlet y = ([\"a\", \"b\"])[n];  // panics\n\nlet arr = [\"a\", \"b\"];\narr[10];                  // warning: index out of bounds\n}\n```\n\nThe array index expression can be implemented for types other than arrays and slices by implementing the [Index](../../std/ops/trait.Index.html) and [IndexMut](../../std/ops/trait.IndexMut.html) traits.\n\n[ ](../expressions/grouped-expr.html \"Previous chapter\") [ ](../expressions/tuple-expr.html \"Next chapter\") "}