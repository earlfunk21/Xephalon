{"lang":"Rust","fullPath":"/expressions/if-expr","category":"expressions","title":"if-expr","url":"https://doc.rust-lang.org/stable/reference/expressions/if-expr.html","markdown":"# [if and if let expressions](#if-and-if-let-expressions)\n\n## [if expressions](#if-expressions)\n\n> **Syntax**  \n> _IfExpression_ :  \n> `if` [_Expression_](../expressions.html)_except struct expression_ [_BlockExpression_](block-expr.html)  \n> (`else` ([_BlockExpression_](block-expr.html)| _IfExpression_| _IfLetExpression_ ) )?\n\nAn `if` expression is a conditional branch in program control. The syntax of an `if` expression is a condition operand, followed by a consequent block, any number of `else if` conditions and blocks, and an optional trailing `else` block. The condition operands must have the [boolean type](../types/boolean.html). If a condition operand evaluates to `true`, the consequent block is executed and any subsequent `else if` or `else` block is skipped. If a condition operand evaluates to `false`, the consequent block is skipped and any subsequent `else if` condition is evaluated. If all `if` and `else if` conditions evaluate to `false` then any `else` block is executed. An if expression evaluates to the same value as the executed block, or `()` if no block is evaluated. An `if` expression must have the same type in all situations.\n\n```rust\n#![allow(unused)]\nfn main() {\nlet x = 3;\nif x == 4 {\n    println!(\"x is four\");\n} else if x == 3 {\n    println!(\"x is three\");\n} else {\n    println!(\"x is something else\");\n}\n\nlet y = if 12 * 15 > 150 {\n    \"Bigger\"\n} else {\n    \"Smaller\"\n};\nassert_eq!(y, \"Bigger\");\n}\n```\n\n## [if let expressions](#if-let-expressions)\n\n> **Syntax**  \n> _IfLetExpression_ :  \n> `if` `let` [_Pattern_](../patterns.html) `=` [_Scrutinee_](match-expr.html)_except lazy boolean operator expression_ [_BlockExpression_](block-expr.html)  \n> (`else` ([_BlockExpression_](block-expr.html)| _IfExpression_| _IfLetExpression_ ) )?\n\nAn `if let` expression is semantically similar to an `if` expression but in place of a condition operand it expects the keyword `let` followed by a pattern, an `=` and a [scrutinee](../glossary.html#scrutinee) operand. If the value of the scrutinee matches the pattern, the corresponding block will execute. Otherwise, flow proceeds to the following `else` block if it exists. Like `if` expressions, `if let` expressions have a value determined by the block that is evaluated.\n\n```rust\n#![allow(unused)]\nfn main() {\nlet dish = (\"Ham\", \"Eggs\");\n\n// this body will be skipped because the pattern is refuted\nif let (\"Bacon\", b) = dish {\n    println!(\"Bacon is served with {}\", b);\n} else {\n    // This block is evaluated instead.\n    println!(\"No bacon will be served\");\n}\n\n// this body will execute\nif let (\"Ham\", b) = dish {\n    println!(\"Ham is served with {}\", b);\n}\n\nif let _ = 5 {\n    println!(\"Irrefutable patterns are always true\");\n}\n}\n```\n\n`if` and `if let` expressions can be intermixed:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet x = Some(3);\nlet a = if let Some(1) = x {\n    1\n} else if x == Some(2) {\n    2\n} else if let Some(y) = x {\n    y\n} else {\n    -1\n};\nassert_eq!(a, 3);\n}\n```\n\nAn `if let` expression is equivalent to a [match expression](match-expr.html) as follows:\n\n```rust\nif let PATS = EXPR {\n    /* body */\n} else {\n    /*else */\n}\n```\n\nis equivalent to\n\n```rust\nmatch EXPR {\n    PATS => { /* body */ },\n    _ => { /* else */ },    // () if there is no else\n}\n```\n\nMultiple patterns may be specified with the `|` operator. This has the same semantics as with `|` in `match` expressions:\n\n```rust\n#![allow(unused)]\nfn main() {\nenum E {\n    X(u8),\n    Y(u8),\n    Z(u8),\n}\nlet v = E::Y(12);\nif let E::X(n) | E::Y(n) = v {\n    assert_eq!(n, 12);\n}\n}\n```\n\nThe expression cannot be a [lazy boolean operator expression](operator-expr.html#lazy-boolean-operators). Use of a lazy boolean operator is ambiguous with a planned feature change of the language (the implementation of if-let chains - see [eRFC 2947](https://github.com/rust-lang/rfcs/blob/master/text/2497-if-let-chains.md#rollout-plan-and-transitioning-to-rust-2018)). When lazy boolean operator expression is desired, this can be achieved by using parenthesis as below:\n\n```rust\n// Before...\nif let PAT = EXPR && EXPR { .. }\n\n// After...\nif let PAT = ( EXPR && EXPR ) { .. }\n\n// Before...\nif let PAT = EXPR || EXPR { .. }\n\n// After...\nif let PAT = ( EXPR || EXPR ) { .. }\n```\n\n[ ](../expressions/range-expr.html \"Previous chapter\") [ ](../expressions/match-expr.html \"Next chapter\") "}