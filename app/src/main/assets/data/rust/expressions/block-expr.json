{"lang":"Rust","fullPath":"/expressions/block-expr","category":"expressions","title":"block-expr","url":"https://doc.rust-lang.org/stable/reference/expressions/block-expr.html","markdown":"# [Block expressions](#block-expressions)\n\n> **Syntax**  \n> _BlockExpression_ :  \n> `{`  \n> [_InnerAttribute_](../attributes.html)\\*  \n> _Statements_?  \n> `}`\n> \n> _Statements_ :  \n> [_Statement_](../statements.html)+  \n> | [_Statement_](../statements.html)+ [_ExpressionWithoutBlock_](../expressions.html)  \n> | [_ExpressionWithoutBlock_](../expressions.html)\n\nA _block expression_, or _block_, is a control flow expression and anonymous namespace scope for items and variable declarations. As a control flow expression, a block sequentially executes its component non-item declaration statements and then its final optional expression. As an anonymous namespace scope, item declarations are only in scope inside the block itself and variables declared by `let` statements are in scope from the next statement until the end of the block.\n\nThe syntax for a block is `{`, then any [inner attributes](../attributes.html), then any number of [statements](../statements.html), then an optional expression, called the final operand, and finally a `}`.\n\nStatements are usually required to be followed by a semicolon, with two exceptions:\n\n1. Item declaration statements do not need to be followed by a semicolon.\n2. Expression statements usually require a following semicolon except if its outer expression is a flow control expression.\n\nFurthermore, extra semicolons between statements are allowed, but these semicolons do not affect semantics.\n\nWhen evaluating a block expression, each statement, except for item declaration statements, is executed sequentially. Then the final operand is executed, if given.\n\nThe type of a block is the type of the final operand, or `()` if the final operand is omitted.\n\n```rust\n#![allow(unused)]\nfn main() {\nfn fn_call() {}\nlet _: () = {\n    fn_call();\n};\n\nlet five: i32 = {\n    fn_call();\n    5\n};\n\nassert_eq!(5, five);\n}\n```\n\n> Note: As a control flow expression, if a block expression is the outer expression of an expression statement, the expected type is `()` unless it is followed immediately by a semicolon.\n\nBlocks are always [value expressions](../expressions.html#place-expressions-and-value-expressions) and evaluate the last operand in value expression context.\n\n> **Note**: This can be used to force moving a value if really needed. For example, the following example fails on the call to `consume_self` because the struct was moved out of `s` in the block expression.\n> \n> ```rust\n> #![allow(unused)]\n> fn main() {\n> struct Struct;\n> \n> impl Struct {\n>    fn consume_self(self) {}\n>    fn borrow_self(&self) {}\n> }\n> \n> fn move_by_block_expression() {\n>    let s = Struct;\n> \n>    // Move the value out of `s` in the block expression.\n>    (&{ s }).borrow_self();\n> \n>    // Fails to execute because `s` is moved out of.\n>    s.consume_self();\n> }\n> }\n> ```\n\n## [async blocks](#async-blocks)\n\n> **Syntax**  \n> _AsyncBlockExpression_ :  \n> `async` `move`? _BlockExpression_\n\nAn _async block_ is a variant of a block expression which evaluates to a future. The final expression of the block, if present, determines the result value of the future.\n\nExecuting an async block is similar to executing a closure expression: its immediate effect is to produce and return an anonymous type. Whereas closures return a type that implements one or more of the [std::ops::Fn](../../std/ops/trait.Fn.html) traits, however, the type returned for an async block implements the [std::future::Future](../../std/future/trait.Future.html) trait. The actual data format for this type is unspecified.\n\n> **Note:** The future type that rustc generates is roughly equivalent to an enum with one variant per `await` point, where each variant stores the data needed to resume from its corresponding point.\n\n> **Edition differences**: Async blocks are only available beginning with Rust 2018.\n\n### [Capture modes](#capture-modes)\n\nAsync blocks capture variables from their environment using the same [capture modes](../types/closure.html#capture-modes) as closures. Like closures, when written `async { .. }` the capture mode for each variable will be inferred from the content of the block.`async move { .. }` blocks however will move all referenced variables into the resulting future.\n\n### [Async context](#async-context)\n\nBecause async blocks construct a future, they define an **async context** which can in turn contain [await expressions](await-expr.html). Async contexts are established by async blocks as well as the bodies of async functions, whose semantics are defined in terms of async blocks.\n\n### [Control-flow operators](#control-flow-operators)\n\nAsync blocks act like a function boundary, much like closures. Therefore, the `?` operator and `return` expressions both affect the output of the future, not the enclosing function or other context. That is, `return <expr>` from within an async block will return the result of `<expr>` as the output of the future. Similarly, if `<expr>?` propagates an error, that error is propagated as the result of the future.\n\nFinally, the `break` and `continue` keywords cannot be used to branch out from an async block. Therefore the following is illegal:\n\n```rust\n#![allow(unused)]\nfn main() {\nloop {\n    async move {\n        break; // error[E0267]: `break` inside of an `async` block\n    }\n}\n}\n```\n\n## [unsafe blocks](#unsafe-blocks)\n\n> **Syntax**  \n> _UnsafeBlockExpression_ :  \n> `unsafe` _BlockExpression_\n\n_See [unsafe block](../unsafe-blocks.html) for more information on when to use `unsafe`_\n\nA block of code can be prefixed with the `unsafe` keyword to permit [unsafe operations](../unsafety.html). Examples:\n\n```rust\n#![allow(unused)]\nfn main() {\nunsafe {\n    let b = [13u8, 17u8];\n    let a = &b[0] as *const u8;\n    assert_eq!(*a, 13);\n    assert_eq!(*a.offset(1), 17);\n}\n\nunsafe fn an_unsafe_fn() -> i32 { 10 }\nlet a = unsafe { an_unsafe_fn() };\n}\n```\n\n## [Labelled block expressions](#labelled-block-expressions)\n\nLabelled block expressions are documented in the [Loops and other breakable expressions](loop-expr.html#labelled-block-expressions) section.\n\n## [Attributes on block expressions](#attributes-on-block-expressions)\n\n[Inner attributes](../attributes.html) are allowed directly after the opening brace of a block expression in the following situations:\n\n* [Function](../items/functions.html) and [method](../items/associated-items.html#methods) bodies.\n* Loop bodies ([loop](loop-expr.html#infinite-loops), [while](loop-expr.html#predicate-loops), [while let](loop-expr.html#predicate-pattern-loops), and [for](loop-expr.html#iterator-loops)).\n* Block expressions used as a [statement](../statements.html).\n* Block expressions as elements of [array expressions](array-expr.html), [tuple expressions](tuple-expr.html),[call expressions](call-expr.html), and tuple-style [struct](struct-expr.html) expressions.\n* A block expression as the tail expression of another block expression.\n\nThe attributes that have meaning on a block expression are [cfg](../conditional-compilation.html) and [the lint check attributes](../attributes/diagnostics.html#lint-check-attributes).\n\nFor example, this function returns `true` on unix platforms and `false` on other platforms.\n\n```rust\n#![allow(unused)]\nfn main() {\nfn is_unix_platform() -> bool {\n    #[cfg(unix)] { true }\n    #[cfg(not(unix))] { false }\n}\n}\n```\n\n[ ](../expressions/path-expr.html \"Previous chapter\") [ ](../expressions/operator-expr.html \"Next chapter\") "}