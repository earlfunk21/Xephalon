{"lang":"Rust","fullPath":"/type-coercions","category":"","title":"type-coercions.html","url":"https://doc.rust-lang.org/stable/reference/type-coercions.html","markdown":"# [Type coercions](#type-coercions)\n\n**Type coercions** are implicit operations that change the type of a value. They happen automatically at specific locations and are highly restricted in what types actually coerce.\n\nAny conversions allowed by coercion can also be explicitly performed by the[type cast operator](expressions/operator-expr.html#type-cast-expressions), `as`.\n\nCoercions are originally defined in [RFC 401](https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md) and expanded upon in [RFC 1558](https://github.com/rust-lang/rfcs/blob/master/text/1558-closure-to-fn-coercion.md).\n\n## [Coercion sites](#coercion-sites)\n\nA coercion can only occur at certain coercion sites in a program; these are typically places where the desired type is explicit or can be derived by propagation from explicit types (without type inference). Possible coercion sites are:\n\n* `let` statements where an explicit type is given.  \nFor example, `&mut 42` is coerced to have type `&i8` in the following:  \n```rust  \n#![allow(unused)]  \nfn main() {  \nlet _: &i8 = &mut 42;  \n}  \n```\n* `static` and `const` item declarations (similar to `let` statements).\n* Arguments for function calls  \nThe value being coerced is the actual parameter, and it is coerced to the type of the formal parameter.  \nFor example, `&mut 42` is coerced to have type `&i8` in the following:  \n```rust  \nfn bar(_: &i8) { }  \nfn main() {  \n    bar(&mut 42);  \n}  \n```  \nFor method calls, the receiver (`self` parameter) can only take advantage of [unsized coercions](#unsized-coercions).\n* Instantiations of struct, union, or enum variant fields  \nFor example, `&mut 42` is coerced to have type `&i8` in the following:  \n```rust  \nstruct Foo<'a> { x: &'a i8 }  \nfn main() {  \n    Foo { x: &mut 42 };  \n}  \n```\n* Function resultsâ€”either the final line of a block if it is not semicolon-terminated or any expression in a `return` statement  \nFor example, `x` is coerced to have type `&dyn Display` in the following:  \n```rust  \n#![allow(unused)]  \nfn main() {  \nuse std::fmt::Display;  \nfn foo(x: &u32) -> &dyn Display {  \n    x  \n}  \n}  \n```\n\nIf the expression in one of these coercion sites is a coercion-propagating expression, then the relevant sub-expressions in that expression are also coercion sites. Propagation recurses from these new coercion sites. Propagating expressions and their relevant sub-expressions are:\n\n* Array literals, where the array has type `[U; n]`. Each sub-expression in the array literal is a coercion site for coercion to type `U`.\n* Array literals with repeating syntax, where the array has type `[U; n]`. The repeated sub-expression is a coercion site for coercion to type `U`.\n* Tuples, where a tuple is a coercion site to type `(U_0, U_1, ..., U_n)`. Each sub-expression is a coercion site to the respective type, e.g. the zeroth sub-expression is a coercion site to type `U_0`.\n* Parenthesized sub-expressions (`(e)`): if the expression has type `U`, then the sub-expression is a coercion site to `U`.\n* Blocks: if a block has type `U`, then the last expression in the block (if it is not semicolon-terminated) is a coercion site to `U`. This includes blocks which are part of control flow statements, such as `if`/`else`, if the block has a known type.\n\n## [Coercion types](#coercion-types)\n\nCoercion is allowed between the following types:\n\n* `T` to `U` if `T` is a [subtype](subtyping.html) of `U` (_reflexive case_)\n* `T_1` to `T_3` where `T_1` coerces to `T_2` and `T_2` coerces to `T_3`(_transitive case_)  \nNote that this is not fully supported yet.\n* `&mut T` to `&T`\n* `*mut T` to `*const T`\n* `&T` to `*const T`\n* `&mut T` to `*mut T`\n* `&T` or `&mut T` to `&U` if `T` implements `Deref<Target = U>`. For example:  \n```rust  \nuse std::ops::Deref;  \nstruct CharContainer {  \n    value: char,  \n}  \nimpl Deref for CharContainer {  \n    type Target = char;  \n    fn deref<'a>(&'a self) -> &'a char {  \n        &self.value  \n    }  \n}  \nfn foo(arg: &char) {}  \nfn main() {  \n    let x = &mut CharContainer { value: 'y' };  \n    foo(x); //&mut CharContainer is coerced to &char.  \n}  \n```\n* `&mut T` to `&mut U` if `T` implements `DerefMut<Target = U>`.\n* TyCtor(`T`) to TyCtor(`U`), where TyCtor(`T`) is one of  \n   * `&T`  \n   * `&mut T`  \n   * `*const T`  \n   * `*mut T`  \n   * `Box<T>`  \nand where `U` can be obtained from `T` by [unsized coercion](#unsized-coercions).\n* Function item types to `fn` pointers\n* Non capturing closures to `fn` pointers\n* `!` to any `T`\n\n### [Unsized Coercions](#unsized-coercions)\n\nThe following coercions are called `unsized coercions`, since they relate to converting sized types to unsized types, and are permitted in a few cases where other coercions are not, as described above. They can still happen anywhere else a coercion can occur.\n\nTwo traits, [Unsize](../std/marker/trait.Unsize.html) and [CoerceUnsized](../std/ops/trait.CoerceUnsized.html), are used to assist in this process and expose it for library use. The following coercions are built-ins and, if `T` can be coerced to `U` with one of them, then an implementation of `Unsize<U>` for `T` will be provided:\n\n* `[T; n]` to `[T]`.\n* `T` to `dyn U`, when `T` implements `U + Sized`, and `U` is [object safe](items/traits.html#object-safety).\n* `Foo<..., T, ...>` to `Foo<..., U, ...>`, when:  \n   * `Foo` is a struct.  \n   * `T` implements `Unsize<U>`.  \n   * The last field of `Foo` has a type involving `T`.  \n   * If that field has type `Bar<T>`, then `Bar<T>` implements `Unsized<Bar<U>>`.  \n   * T is not part of the type of any other fields.\n\nAdditionally, a type `Foo<T>` can implement `CoerceUnsized<Foo<U>>` when `T`implements `Unsize<U>` or `CoerceUnsized<Foo<U>>`. This allows it to provide a unsized coercion to `Foo<U>`.\n\n> Note: While the definition of the unsized coercions and their implementation has been stabilized, the traits themselves are not yet stable and therefore can't be used directly in stable Rust.\n\n## [Least upper bound coercions](#least-upper-bound-coercions)\n\nIn some contexts, the compiler must coerce together multiple types to try and find the most general type. This is called a \"Least Upper Bound\" coercion. LUB coercion is used and only used in the following situations:\n\n* To find the common type for a series of if branches.\n* To find the common type for a series of match arms.\n* To find the common type for array elements.\n* To find the type for the return type of a closure with multiple return statements.\n* To check the type for the return type of a function with multiple return statements.\n\nIn each such case, there are a set of types `T0..Tn` to be mutually coerced to some target type `T_t`, which is unknown to start. Computing the LUB coercion is done iteratively. The target type `T_t` begins as the type `T0`. For each new type `Ti`, we consider whether\n\n* If `Ti` can be coerced to the current target type `T_t`, then no change is made.\n* Otherwise, check whether `T_t` can be coerced to `Ti`; if so, the `T_t` is changed to `Ti`. (This check is also conditioned on whether all of the source expressions considered thus far have implicit coercions.)\n* If not, try to compute a mutual supertype of `T_t` and `Ti`, which will become the new target type.\n\n### [Examples:](#examples)\n\n```rust\n#![allow(unused)]\nfn main() {\nlet (a, b, c) = (0, 1, 2);\n// For if branches\nlet bar = if true {\n    a\n} else if false {\n    b\n} else {\n    c\n};\n\n// For match arms\nlet baw = match 42 {\n    0 => a,\n    1 => b,\n    _ => c,\n};\n\n// For array elements\nlet bax = [a, b, c];\n\n// For closure with multiple return statements\nlet clo = || {\n    if true {\n        a\n    } else if false {\n        b\n    } else {\n        c\n    }\n};\nlet baz = clo();\n\n// For type checking of function with multiple return statements\nfn foo() -> i32 {\n    let (a, b, c) = (0, 1, 2);\n    match 42 {\n        0 => a,\n        1 => b,\n        _ => c,\n    }\n}\n}\n```\n\nIn these examples, types of the `ba*` are found by LUB coercion. And the compiler checks whether LUB coercion result of `a`, `b`, `c` is `i32` in the processing of the function `foo`.\n\n### [Caveat](#caveat)\n\nThis description is obviously informal. Making it more precise is expected to proceed as part of a general effort to specify the Rust type checker more precisely.\n\n[ ](trait-bounds.html \"Previous chapter\") [ ](destructors.html \"Next chapter\") "}