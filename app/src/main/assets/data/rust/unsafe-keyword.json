{"lang":"Rust","fullPath":"/unsafe-keyword","category":"","title":"unsafe-keyword.html","url":"https://doc.rust-lang.org/stable/reference/unsafe-keyword.html","markdown":"# [The unsafe keyword](#the-unsafe-keyword)\n\nThe `unsafe` keyword can occur in several different contexts: unsafe functions (`unsafe fn`), unsafe blocks (`unsafe {}`), unsafe traits (`unsafe trait`), and unsafe trait implementations (`unsafe impl`). It plays several different roles, depending on where it is used and whether the `unsafe_op_in_unsafe_fn` lint is enabled:\n\n* it is used to mark code that _defines_ extra safety conditions (`unsafe fn`, `unsafe trait`)\n* it is used to mark code that needs to _satisfy_ extra safety conditions (`unsafe {}`, `unsafe impl`, `unsafe fn` without [unsafe\\_op\\_in\\_unsafe\\_fn](../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn))\n\nThe following discusses each of these cases. See the [keyword documentation](../std/keyword.unsafe.html) for some illustrative examples.\n\n## [Unsafe functions (unsafe fn)](#unsafe-functions-unsafe-fn)\n\nUnsafe functions are functions that are not safe in all contexts and/or for all possible inputs. We say they have _extra safety conditions_, which are requirements that must be upheld by all callers and that the compiler does not check. For example, [get\\_unchecked](../std/primitive.slice.html#method.get%5Funchecked) has the extra safety condition that the index must be in-bounds. The unsafe function should come with documentation explaining what those extra safety conditions are.\n\nSuch a function must be prefixed with the keyword `unsafe` and can only be called from inside an `unsafe` block, or inside `unsafe fn` without the [unsafe\\_op\\_in\\_unsafe\\_fn](../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn) lint.\n\n## [Unsafe blocks (unsafe {})](#unsafe-blocks-unsafe-)\n\nA block of code can be prefixed with the `unsafe` keyword, to permit calling `unsafe` functions or dereferencing raw pointers. By default, the body of an unsafe function is also considered to be an unsafe block; this can be changed by enabling the [unsafe\\_op\\_in\\_unsafe\\_fn](../rustc/lints/listing/allowed-by-default.html#unsafe-op-in-unsafe-fn) lint.\n\nBy putting operations into an unsafe block, the programmer states that they have taken care of satisfying the extra safety conditions of all operations inside that block.\n\nUnsafe blocks are the logical dual to unsafe functions: where unsafe functions define a proof obligation that callers must uphold, unsafe blocks state that all relevant proof obligations have been discharged. There are many ways to discharge proof obligations; for example, there could be run-time checks or data structure invariants that guarantee that certain properties are definitely true, or the unsafe block could be inside an `unsafe fn` and use its own proof obligations to discharge the proof obligations of its callees.\n\nUnsafe blocks are used to wrap foreign libraries, make direct use of hardware or implement features not directly present in the language. For example, Rust provides the language features necessary to implement memory-safe concurrency in the language but the implementation of threads and message passing in the standard library uses unsafe blocks.\n\nRust's type system is a conservative approximation of the dynamic safety requirements, so in some cases there is a performance cost to using safe code. For example, a doubly-linked list is not a tree structure and can only be represented with reference-counted pointers in safe code. By using `unsafe` blocks to represent the reverse links as raw pointers, it can be implemented without reference counting. (See [\"Learn Rust With Entirely Too Many Linked Lists\"](https://rust-unofficial.github.io/too-many-lists/) for a more in-depth exploration of this particular example.)\n\n## [Unsafe traits (unsafe trait)](#unsafe-traits-unsafe-trait)\n\nAn unsafe trait is a trait that comes with extra safety conditions that must be upheld by _implementations_ of the trait. The unsafe trait should come with documentation explaining what those extra safety conditions are.\n\nSuch a trait must be prefixed with the keyword `unsafe` and can only be implemented by `unsafe impl` blocks.\n\n## [Unsafe trait implementations (unsafe impl)](#unsafe-trait-implementations-unsafe-impl)\n\nWhen implementing an unsafe trait, the implementation needs to be prefixed with the `unsafe` keyword. By writing `unsafe impl`, the programmer states that they have taken care of satisfying the extra safety conditions required by the trait.\n\nUnsafe trait implementations are the logical dual to unsafe traits: where unsafe traits define a proof obligation that implementations must uphold, unsafe implementations state that all relevant proof obligations have been discharged.\n\n[ ](unsafety.html \"Previous chapter\") [ ](behavior-considered-undefined.html \"Next chapter\") "}