{"lang":"Rust","fullPath":"/types/pointer","category":"types","title":"pointer","url":"https://doc.rust-lang.org/stable/reference/types/pointer.html","markdown":"# [Pointer types](#pointer-types)\n\nAll pointers are explicit first-class values. They can be moved or copied, stored into data structs, and returned from functions.\n\n## [References (& and &mut)](#references--and-mut)\n\n> **Syntax**  \n> _ReferenceType_ :  \n> `&` [_Lifetime_](../trait-bounds.html)? `mut`? [_TypeNoBounds_](../types.html#type-expressions)\n\n### [Shared references (&)](#shared-references-)\n\nShared references point to memory which is owned by some other value. When a shared reference to a value is created, it prevents direct mutation of the value.[Interior mutability](../interior-mutability.html) provides an exception for this in certain circumstances. As the name suggests, any number of shared references to a value may exist. A shared reference type is written `&type`, or `&'a type` when you need to specify an explicit lifetime. Copying a reference is a \"shallow\" operation: it involves only copying the pointer itself, that is, pointers are `Copy`. Releasing a reference has no effect on the value it points to, but referencing of a [temporary value](../expressions.html#temporaries) will keep it alive during the scope of the reference itself.\n\n### [Mutable references (&mut)](#mutable-references-mut)\n\nMutable references point to memory which is owned by some other value. A mutable reference type is written `&mut type` or `&'a mut type`. A mutable reference (that hasn't been borrowed) is the only way to access the value it points to, so is not `Copy`.\n\n## [Raw pointers (\\*const and \\*mut)](#raw-pointers-const-and-mut)\n\n> **Syntax**  \n> _RawPointerType_ :  \n> `*` ( `mut` | `const` ) [_TypeNoBounds_](../types.html#type-expressions)\n\nRaw pointers are pointers without safety or liveness guarantees. Raw pointers are written as `*const T` or `*mut T`. For example `*const i32` means a raw pointer to a 32-bit integer. Copying or dropping a raw pointer has no effect on the lifecycle of any other value. Dereferencing a raw pointer is an [unsafe operation](../unsafety.html). This can also be used to convert a raw pointer to a reference by reborrowing it (`&*` or `&mut *`). Raw pointers are generally discouraged; they exist to support interoperability with foreign code, and writing performance-critical or low-level functions.\n\nWhen comparing raw pointers they are compared by their address, rather than by what they point to. When comparing raw pointers to [dynamically sized types](../dynamically-sized-types.html) they also have their additional data compared.\n\nRaw pointers can be created directly using [core::ptr::addr\\_of!](../../core/ptr/macro.addr%5Fof.html) for `*const` pointers and [core::ptr::addr\\_of\\_mut!](../../core/ptr/macro.addr%5Fof%5Fmut.html) for `*mut` pointers.\n\n## [Smart Pointers](#smart-pointers)\n\nThe standard library contains additional 'smart pointer' types beyond references and raw pointers.\n\n[ ](../types/closure.html \"Previous chapter\") [ ](../types/function-pointer.html \"Next chapter\") "}