{"lang":"Rust","fullPath":"/types/closure","category":"types","title":"closure","url":"https://doc.rust-lang.org/stable/reference/types/closure.html","markdown":"# [Closure types](#closure-types)\n\nA [closure expression](../expressions/closure-expr.html) produces a closure value with a unique, anonymous type that cannot be written out. A closure type is approximately equivalent to a struct which contains the captured variables. For instance, the following closure:\n\n```rust\n#![allow(unused)]\nfn main() {\nfn f<F : FnOnce() -> String> (g: F) {\n    println!(\"{}\", g());\n}\n\nlet mut s = String::from(\"foo\");\nlet t = String::from(\"bar\");\n\nf(|| {\n    s += &t;\n    s\n});\n// Prints \"foobar\".\n}\n```\n\ngenerates a closure type roughly like the following:\n\n```rust\nstruct Closure<'a> {\n    s : String,\n    t : &'a String,\n}\n\nimpl<'a> FnOnce<()> for Closure<'a> {\n    type Output = String;\n    fn call_once(self) -> String {\n        self.s += &*self.t;\n        self.s\n    }\n}\n```\n\nso that the call to `f` works as if it were:\n\n```rust\nf(Closure{s: s, t: &t});\n```\n\n## [Capture modes](#capture-modes)\n\nThe compiler prefers to capture a closed-over variable by immutable borrow, followed by unique immutable borrow (see below), by mutable borrow, and finally by move. It will pick the first choice of these that is compatible with how the captured variable is used inside the closure body. The compiler does not take surrounding code into account, such as the lifetimes of involved variables, or of the closure itself.\n\nIf the `move` keyword is used, then all captures are by move or, for `Copy`types, by copy, regardless of whether a borrow would work. The `move` keyword is usually used to allow the closure to outlive the captured values, such as if the closure is being returned or used to spawn a new thread.\n\nComposite types such as structs, tuples, and enums are always captured entirely, not by individual fields. It may be necessary to borrow into a local variable in order to capture a single field:\n\n```rust\n#![allow(unused)]\nfn main() {\nuse std::collections::HashSet;\n\nstruct SetVec {\n    set: HashSet<u32>,\n    vec: Vec<u32>\n}\n\nimpl SetVec {\n    fn populate(&mut self) {\n        let vec = &mut self.vec;\n        self.set.iter().for_each(|&n| {\n            vec.push(n);\n        })\n    }\n}\n}\n```\n\nIf, instead, the closure were to use `self.vec` directly, then it would attempt to capture `self` by mutable reference. But since `self.set` is already borrowed to iterate over, the code would not compile.\n\n## [Unique immutable borrows in captures](#unique-immutable-borrows-in-captures)\n\nCaptures can occur by a special kind of borrow called a _unique immutable borrow_, which cannot be used anywhere else in the language and cannot be written out explicitly. It occurs when modifying the referent of a mutable reference, as in the following example:\n\n```rust\n#![allow(unused)]\nfn main() {\nlet mut b = false;\nlet x = &mut b;\n{\n    let mut c = || { *x = true; };\n    // The following line is an error:\n    // let y = &x;\n    c();\n}\nlet z = &x;\n}\n```\n\nIn this case, borrowing `x` mutably is not possible, because `x` is not `mut`. But at the same time, borrowing `x` immutably would make the assignment illegal, because a `& &mut` reference might not be unique, so it cannot safely be used to modify a value. So a unique immutable borrow is used: it borrows `x` immutably, but like a mutable borrow, it must be unique. In the above example, uncommenting the declaration of `y` will produce an error because it would violate the uniqueness of the closure's borrow of `x`; the declaration of z is valid because the closure's lifetime has expired at the end of the block, releasing the borrow.\n\n## [Call traits and coercions](#call-traits-and-coercions)\n\nClosure types all implement [FnOnce](../../std/ops/trait.FnOnce.html), indicating that they can be called once by consuming ownership of the closure. Additionally, some closures implement more specific call traits:\n\n* A closure which does not move out of any captured variables implements[FnMut](../../std/ops/trait.FnMut.html), indicating that it can be called by mutable reference.\n* A closure which does not mutate or move out of any captured variables implements [Fn](../../std/ops/trait.Fn.html), indicating that it can be called by shared reference.\n\n> Note: `move` closures may still implement [Fn](../../std/ops/trait.Fn.html) or [FnMut](../../std/ops/trait.FnMut.html), even though they capture variables by move. This is because the traits implemented by a closure type are determined by what the closure does with captured values, not how it captures them.\n\n_Non-capturing closures_ are closures that don't capture anything from their environment. They can be coerced to function pointers (e.g., `fn()`) with the matching signature.\n\n```rust\n#![allow(unused)]\nfn main() {\nlet add = |x, y| x + y;\n\nlet mut x = add(5,7);\n\ntype Binop = fn(i32, i32) -> i32;\nlet bo: Binop = add;\nx = bo(5,7);\n}\n```\n\n## [Other traits](#other-traits)\n\nAll closure types implement [Sized](../special-types-and-traits.html#sized). Additionally, closure types implement the following traits if allowed to do so by the types of the captures it stores:\n\n* [Clone](../special-types-and-traits.html#clone)\n* [Copy](../special-types-and-traits.html#copy)\n* [Sync](../special-types-and-traits.html#sync)\n* [Send](../special-types-and-traits.html#send)\n\nThe rules for [Send](../special-types-and-traits.html#send) and [Sync](../special-types-and-traits.html#sync) match those for normal struct types, while[Clone](../special-types-and-traits.html#clone) and [Copy](../special-types-and-traits.html#copy) behave as if [derived](../attributes/derive.html). For [Clone](../special-types-and-traits.html#clone), the order of cloning of the captured variables is left unspecified.\n\nBecause captures are often by reference, the following general rules arise:\n\n* A closure is [Sync](../special-types-and-traits.html#sync) if all captured variables are [Sync](../special-types-and-traits.html#sync).\n* A closure is [Send](../special-types-and-traits.html#send) if all variables captured by non-unique immutable reference are [Sync](../special-types-and-traits.html#sync), and all values captured by unique immutable or mutable reference, copy, or move are [Send](../special-types-and-traits.html#send).\n* A closure is [Clone](../special-types-and-traits.html#clone) or [Copy](../special-types-and-traits.html#copy) if it does not capture any values by unique immutable or mutable reference, and if all values it captures by copy or move are [Clone](../special-types-and-traits.html#clone) or [Copy](../special-types-and-traits.html#copy), respectively.\n\n[ ](../types/function-item.html \"Previous chapter\") [ ](../types/pointer.html \"Next chapter\") "}