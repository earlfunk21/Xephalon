{"lang":"Rust","fullPath":"/statements","category":"","title":"statements.html","url":"https://doc.rust-lang.org/stable/reference/statements.html","markdown":"# [Statements](#statements)\n\n> **Syntax**  \n> _Statement_ :  \n> `;`  \n> | [_Item_](items.html)  \n> | [_LetStatement_](#let-statements)  \n> | [_ExpressionStatement_](#expression-statements)  \n> | [_MacroInvocationSemi_](macros.html#macro-invocation)\n\nA _statement_ is a component of a [block](expressions/block-expr.html), which is in turn a component of an outer [expression](expressions.html) or [function](items/functions.html).\n\nRust has two kinds of statement: [declaration statements](#declaration-statements) and [expression statements](#expression-statements).\n\n## [Declaration statements](#declaration-statements)\n\nA _declaration statement_ is one that introduces one or more _names_ into the enclosing statement block. The declared names may denote new variables or new [items](items.html).\n\nThe two kinds of declaration statements are item declarations and `let` statements.\n\n### [Item declarations](#item-declarations)\n\nAn _item declaration statement_ has a syntactic form identical to an [item declaration](items.html) within a [module](items/modules.html). Declaring an item within a statement block restricts its scope to the block containing the statement. The item is not given a [canonical path](paths.html#canonical-paths) nor are any sub-items it may declare. The exception to this is that associated items defined by [implementations](items/implementations.html) are still accessible in outer scopes as long as the item and, if applicable, trait are accessible. It is otherwise identical in meaning to declaring the item inside a module.\n\nThere is no implicit capture of the containing function's generic parameters, parameters, and local variables. For example, `inner` may not access `outer_var`.\n\n```rust\n#![allow(unused)]\nfn main() {\nfn outer() {\n  let outer_var = true;\n\n  fn inner() { /* outer_var is not in scope here */ }\n\n  inner();\n}\n}\n```\n\n### [let statements](#let-statements)\n\n> **Syntax**  \n> _LetStatement_ :  \n> [_OuterAttribute_](attributes.html)\\* `let` [_PatternNoTopAlt_](patterns.html)( `:` [_Type_](types.html) )? (`=` [_Expression_](expressions.html) [†](#let-else-restriction)( `else` [_BlockExpression_](expressions/block-expr.html)) ? ) ? `;`\n> \n> † When an `else` block is specified, the_Expression_ must not be a [_LazyBooleanExpression_](expressions/operator-expr.html#lazy-boolean-operators), or end with a `}`.\n\nA _`let` statement_ introduces a new set of [variables](variables.html), given by a [pattern](patterns.html). The pattern is followed optionally by a type annotation and then either ends, or is followed by an initializer expression plus an optional `else` block. When no type annotation is given, the compiler will infer the type, or signal an error if insufficient type information is available for definite inference. Any variables introduced by a variable declaration are visible from the point of declaration until the end of the enclosing block scope, except when they are shadowed by another variable declaration.\n\nIf an `else` block is not present, the pattern must be irrefutable. If an `else` block is present, the pattern may be refutable. If the pattern does not match (this requires it to be refutable), the `else` block is executed. The `else` block must always diverge (evaluate to the [never type](types/never.html)).\n\n```rust\n#![allow(unused)]\nfn main() {\nlet (mut v, w) = (vec![1, 2, 3], 42); // The bindings may be mut or const\nlet Some(t) = v.pop() else { // Refutable patterns require an else block\n    panic!(); // The else block must diverge\n};\nlet [u, v] = [v[0], v[1]] else { // This pattern is irrefutable, so the compiler\n                                 // will lint as the else block is redundant.\n    panic!();\n};\n}\n```\n\n## [Expression statements](#expression-statements)\n\n> **Syntax**  \n> _ExpressionStatement_ :  \n> [_ExpressionWithoutBlock_](expressions.html) `;`  \n> | [_ExpressionWithBlock_](expressions.html) `;`?\n\nAn _expression statement_ is one that evaluates an [expression](expressions.html) and ignores its result. As a rule, an expression statement's purpose is to trigger the effects of evaluating its expression.\n\nAn expression that consists of only a [block expression](expressions/block-expr.html) or control flow expression, if used in a context where a statement is permitted, can omit the trailing semicolon. This can cause an ambiguity between it being parsed as a standalone statement and as a part of another expression; in this case, it is parsed as a statement. The type of [_ExpressionWithBlock_](expressions.html) expressions when used as statements must be the unit type.\n\n```rust\n#![allow(unused)]\nfn main() {\nlet mut v = vec![1, 2, 3];\nv.pop();          // Ignore the element returned from pop\nif v.is_empty() {\n    v.push(5);\n} else {\n    v.remove(0);\n}                 // Semicolon can be omitted.\n[1];              // Separate expression statement, not an indexing expression.\n}\n```\n\nWhen the trailing semicolon is omitted, the result must be type `()`.\n\n```rust\n#![allow(unused)]\nfn main() {\n// bad: the block's type is i32, not ()\n// Error: expected `()` because of default return type\n// if true {\n//   1\n// }\n\n// good: the block's type is i32\nif true {\n  1\n} else {\n  2\n};\n}\n```\n\n## [Attributes on Statements](#attributes-on-statements)\n\nStatements accept [outer attributes](attributes.html). The attributes that have meaning on a statement are [cfg](conditional-compilation.html), and [the lint check attributes](attributes/diagnostics.html#lint-check-attributes).\n\n[ ](statements-and-expressions.html \"Previous chapter\") [ ](expressions.html \"Next chapter\") "}