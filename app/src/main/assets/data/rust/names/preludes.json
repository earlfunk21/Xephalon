{"lang":"Rust","fullPath":"/names/preludes","category":"names","title":"preludes","url":"https://doc.rust-lang.org/stable/reference/names/preludes.html","markdown":"# [Preludes](#preludes)\n\nA _prelude_ is a collection of names that are automatically brought into scope of every module in a crate.\n\nThese prelude names are not part of the module itself: they are implicitly queried during [name resolution](name-resolution.html). For example, even though something like[Box](../../std/boxed/struct.Box.html) is in scope in every module, you cannot refer to it as `self::Box`because it is not a member of the current module.\n\nThere are several different preludes:\n\n* [Standard library prelude](#standard-library-prelude)\n* [Extern prelude](#extern-prelude)\n* [Language prelude](#language-prelude)\n* [macro\\_use prelude](#macro%5Fuse-prelude)\n* [Tool prelude](#tool-prelude)\n\n## [Standard library prelude](#standard-library-prelude)\n\nEach crate has a standard library prelude, which consists of the names from a single standard library module. The module used depends on the crate's edition, and on whether the [no\\_std attribute](#the-no%5Fstd-attribute) is applied to the crate:\n\n| Edition | no\\_std not applied                                                  | no\\_std applied                                                        |\n| ------- | -------------------------------------------------------------------- | ---------------------------------------------------------------------- |\n| 2015    | [std::prelude::rust\\_2015](../../std/prelude/rust%5F2015/index.html) | [core::prelude::rust\\_2015](../../core/prelude/rust%5F2015/index.html) |\n| 2018    | [std::prelude::rust\\_2018](../../std/prelude/rust%5F2018/index.html) | [core::prelude::rust\\_2018](../../core/prelude/rust%5F2018/index.html) |\n| 2021    | [std::prelude::rust\\_2021](../../std/prelude/rust%5F2021/index.html) | [core::prelude::rust\\_2021](../../core/prelude/rust%5F2021/index.html) |\n\n> **Note**:\n> \n> [std::prelude::rust\\_2015](../../std/prelude/rust%5F2015/index.html) and [std::prelude::rust\\_2018](../../std/prelude/rust%5F2018/index.html) have the same contents as [std::prelude::v1](../../std/prelude/v1/index.html).\n> \n> [core::prelude::rust\\_2015](../../core/prelude/rust%5F2015/index.html) and [core::prelude::rust\\_2018](../../core/prelude/rust%5F2018/index.html) have the same contents as [core::prelude::v1](../../core/prelude/v1/index.html).\n\n## [Extern prelude](#extern-prelude)\n\nExternal crates imported with [extern crate](../items/extern-crates.html) in the root module or provided to the compiler (as with the `--extern` flag with `rustc`) are added to the_extern prelude_. If imported with an alias such as `extern crate orig_name as new_name`, then the symbol `new_name` is instead added to the prelude.\n\nThe [core](../../core/index.html) crate is always added to the extern prelude. The [std](../../std/index.html) crate is added as long as the [no\\_std attribute](#the-no%5Fstd-attribute) is not specified in the crate root.\n\n> **Edition Differences**: In the 2015 edition, crates in the extern prelude cannot be referenced via [use declarations](../items/use-declarations.html), so it is generally standard practice to include `extern crate` declarations to bring them into scope.\n> \n> Beginning in the 2018 edition, [use declarations](../items/use-declarations.html) can reference crates in the extern prelude, so it is considered unidiomatic to use `extern crate`.\n\n> **Note**: Additional crates that ship with `rustc`, such as [alloc](../../alloc/index.html), and[test](../../test/index.html), are not automatically included with the `--extern` flag when using Cargo. They must be brought into scope with an `extern crate` declaration, even in the 2018 edition.\n> \n> ```rust\n> #![allow(unused)]\n> fn main() {\n> extern crate alloc;\n> use alloc::rc::Rc;\n> }\n> ```\n> \n> Cargo does bring in `proc_macro` to the extern prelude for proc-macro crates only.\n\n### [The no\\_std attribute](#the-no%5Fstd-attribute)\n\nBy default, the standard library is automatically included in the crate root module. The [std](../../std/index.html) crate is added to the root, along with an implicit[macro\\_use attribute](../macros-by-example.html#the-macro%5Fuse-attribute) pulling in all macros exported from `std` into the[macro\\_use prelude](#macro%5Fuse-prelude). Both [core](../../core/index.html) and [std](../../std/index.html) are added to the [extern prelude](#extern-prelude).\n\nThe _`nostd` [attribute](../attributes.html)_ may be applied at the crate level to prevent the[std](../../std/index.html) crate from being automatically added into scope. It does three things:\n\n* Prevents `std` from being added to the [extern prelude](#extern-prelude).\n* Affects which module is used to make up the [standard library prelude](#standard-library-prelude) (as described above).\n* Injects the [core](../../core/index.html) crate into the crate root instead of [std](../../std/index.html), and pulls in all macros exported from `core` in the [macro\\_use prelude](#macro%5Fuse-prelude).\n\n> **Note**: Using the core prelude over the standard prelude is useful when either the crate is targeting a platform that does not support the standard library or is purposefully not using the capabilities of the standard library. Those capabilities are mainly dynamic memory allocation (e.g. `Box`and `Vec`) and file and network capabilities (e.g. `std::fs` and `std::io`).\n\nWarning: Using `no_std` does not prevent the standard library from being linked in. It is still valid to put `extern crate std;` into the crate and dependencies can also link it in.\n\n## [Language prelude](#language-prelude)\n\nThe language prelude includes names of types and attributes that are built-in to the language. The language prelude is always in scope. It includes the following:\n\n* [Type namespace](namespaces.html)  \n   * [Boolean type](../types/boolean.html) — `bool`  \n   * [Textual types](../types/textual.html) — `char` and `str`  \n   * [Integer types](../types/numeric.html#integer-types) — `i8`, `i16`, `i32`, `i64`, `i128`, `u8`, `u16`, `u32`, `u64`, `u128`  \n   * [Machine-dependent integer types](../types/numeric.html#machine-dependent-integer-types) — `usize` and `isize`  \n   * [floating-point types](../types/numeric.html#floating-point-types) — `f32` and `f64`\n* [Macro namespace](namespaces.html)  \n   * [Built-in attributes](../attributes.html#built-in-attributes-index)\n\n## [macro\\_use prelude](#macro%5Fuse-prelude)\n\nThe `macro_use` prelude includes macros from external crates that were imported by the [macro\\_use attribute](../macros-by-example.html#the-macro%5Fuse-attribute) applied to an [extern crate](../items/extern-crates.html).\n\n## [Tool prelude](#tool-prelude)\n\nThe tool prelude includes tool names for external tools in the [type namespace](namespaces.html). See the [tool attributes](../attributes.html#tool-attributes) section for more details.\n\n## [The no\\_implicit\\_prelude attribute](#the-no%5Fimplicit%5Fprelude-attribute)\n\nThe _`noimplicitprelude` [attribute](../attributes.html)_ may be applied at the crate level or on a module to indicate that it should not automatically bring the [standard library prelude](#standard-library-prelude), [extern prelude](#extern-prelude), or [tool prelude](#tool-prelude) into scope for that module or any of its descendants.\n\nThis attribute does not affect the [language prelude](#language-prelude).\n\n> **Edition Differences**: In the 2015 edition, the `no_implicit_prelude`attribute does not affect the [macro\\_use prelude](#macro%5Fuse-prelude), and all macros exported from the standard library are still included in the `macro_use` prelude. Starting in the 2018 edition, it will remove the `macro_use` prelude.\n\n[ ](../names/scopes.html \"Previous chapter\") [ ](../paths.html \"Next chapter\") "}