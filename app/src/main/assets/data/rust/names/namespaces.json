{"lang":"Rust","fullPath":"/names/namespaces","category":"names","title":"namespaces","url":"https://doc.rust-lang.org/stable/reference/names/namespaces.html","markdown":"# [Namespaces](#namespaces)\n\nA _namespace_ is a logical grouping of declared [names](../names.html). Names are segregated into separate namespaces based on the kind of entity the name refers to. Namespaces allow the occurrence of a name in one namespace to not conflict with the same name in another namespace.\n\nWithin a namespace, names are organized in a hierarchy, where each level of the hierarchy has its own collection of named entities.\n\nThere are several different namespaces that each contain different kinds of entities. The usage of a name will look for the declaration of that name in different namespaces, based on the context, as described in the [name resolution](name-resolution.html) chapter.\n\nThe following is a list of namespaces, with their corresponding entities:\n\n* Type Namespace  \n   * [Module declarations](../items/modules.html)  \n   * [External crate declarations](../items/extern-crates.html)  \n   * [External crate prelude](preludes.html#extern-prelude) items  \n   * [Struct](../items/structs.html), [union](../items/unions.html), [enum](../items/enumerations.html), enum variant declarations  \n   * [Trait item declarations](../items/traits.html)  \n   * [Type aliases](../items/type-aliases.html)  \n   * [Associated type declarations](../items/associated-items.html#associated-types)  \n   * Built-in types: [boolean](../types/boolean.html), [numeric](../types/numeric.html), and [textual](../types/textual.html)  \n   * [Generic type parameters](../items/generics.html)  \n   * [Self type](../paths.html#self-1)  \n   * [Tool attribute modules](../attributes.html#tool-attributes)\n* Value Namespace  \n   * [Function declarations](../items/functions.html)  \n   * [Constant item declarations](../items/constant-items.html)  \n   * [Static item declarations](../items/static-items.html)  \n   * [Struct constructors](../items/structs.html)  \n   * [Enum variant constructors](../items/enumerations.html)  \n   * [Self constructors](../paths.html#self-1)  \n   * [Generic const parameters](../items/generics.html#const-generics)  \n   * [Associated const declarations](../items/associated-items.html#associated-constants)  \n   * [Associated function declarations](../items/associated-items.html#associated-functions-and-methods)  \n   * Local bindings â€” [let](../statements.html#let-statements), [if let](../expressions/if-expr.html#if-let-expressions), [while let](../expressions/loop-expr.html#predicate-pattern-loops), [for](../expressions/loop-expr.html#iterator-loops), [match](../expressions/match-expr.html)arms, [function parameters](../items/functions.html#function-parameters), [closure parameters](../expressions/closure-expr.html)  \n   * Captured [closure](../expressions/closure-expr.html) variables\n* Macro Namespace  \n   * [macro\\_rules declarations](../macros-by-example.html)  \n   * [Built-in attributes](../attributes.html#built-in-attributes-index)  \n   * [Tool attributes](../attributes.html#tool-attributes)  \n   * [Function-like procedural macros](../procedural-macros.html#function-like-procedural-macros)  \n   * [Derive macros](../procedural-macros.html#derive-macros)  \n   * [Derive macro helpers](../procedural-macros.html#derive-macro-helper-attributes)  \n   * [Attribute macros](../procedural-macros.html#attribute-macros)\n* Lifetime Namespace  \n   * [Generic lifetime parameters](../items/generics.html)\n* Label Namespace  \n   * [Loop labels](../expressions/loop-expr.html#loop-labels)\n\nAn example of how overlapping names in different namespaces can be used unambiguously:\n\n```rust\n#![allow(unused)]\nfn main() {\n// Foo introduces a type in the type namespace and a constructor in the value\n// namespace.\nstruct Foo(u32);\n\n// The `Foo` macro is declared in the macro namespace.\nmacro_rules! Foo {\n    () => {};\n}\n\n// `Foo` in the `f` parameter type refers to `Foo` in the type namespace.\n// `'Foo` introduces a new lifetime in the lifetime namespace.\nfn example<'Foo>(f: Foo) {\n    // `Foo` refers to the `Foo` constructor in the value namespace.\n    let ctor = Foo;\n    // `Foo` refers to the `Foo` macro in the macro namespace.\n    Foo!{}\n    // `'Foo` introduces a label in the label namespace.\n    'Foo: loop {\n        // `'Foo` refers to the `'Foo` lifetime parameter, and `Foo`\n        // refers to the type namespace.\n        let x: &'Foo Foo;\n        // `'Foo` refers to the label.\n        break 'Foo;\n    }\n}\n}\n```\n\n## [Named entities without a namespace](#named-entities-without-a-namespace)\n\nThe following entities have explicit names, but the names are not a part of any specific namespace.\n\n### [Fields](#fields)\n\nEven though struct, enum, and union fields are named, the named fields do not live in an explicit namespace. They can only be accessed via a [field expression](../expressions/field-expr.html), which only inspects the field names of the specific type being accessed.\n\n### [Use declarations](#use-declarations)\n\nA [use declaration](../items/use-declarations.html) has named aliases that it imports into scope, but the`use` item itself does not belong to a specific namespace. Instead, it can introduce aliases into multiple namespaces, depending on the item kind being imported.\n\n## [Sub-namespaces](#sub-namespaces)\n\nThe macro namespace is split into two sub-namespaces: one for [bang-style macros](../macros.html) and one for [attributes](../attributes.html). When an attribute is resolved, any bang-style macros in scope will be ignored. And conversely resolving a bang-style macro will ignore attribute macros in scope. This prevents one style from shadowing another.\n\nFor example, the [cfg attribute](../conditional-compilation.html#the-cfg-attribute) and the [cfg macro](../conditional-compilation.html#the-cfg-macro) are two different entities with the same name in the macro namespace, but they can still be used in their respective context.\n\nIt is still an error for a [use import](../items/use-declarations.html) to shadow another macro, regardless of their sub-namespaces.\n\n[ ](../names.html \"Previous chapter\") [ ](../names/scopes.html \"Next chapter\") "}