{"lang":"JavascriptES5","category":"","fullPath":"","title":"8 Types8.1 The Undefined Type8.2 The Null Type8.3 The Boolean Type8.4 The String Type8.5 The Number Type8.6 The Object Type8.6.1 Property Attributes8.6.2 Object Internal Properties and\n          Methods8.7 The Reference Specification Type8.7.1 GetValue (V)8.7.2 PutValue (V, W)8.8 The List Specification Type8.9 The Completion Specification Type8.10 The Property Descriptor and Property\n        Identifier Specification Types8.10.1 IsAccessorDescriptor ( Desc\n          )8.10.2 IsDataDescriptor ( Desc )8.10.3 IsGenericDescriptor ( Desc\n          )8.10.4 FromPropertyDescriptor ( Desc\n          )8.10.5 ToPropertyDescriptor ( Obj\n          )8.11 The Lexical Environment and\n        Environment Record Specification Types8.12 Algorithms for Object Internal\n        Methods8.12.1 [[GetOwnProperty]] (P)8.12.2 [[GetProperty]] (P)8.12.3 [[Get]] (P)8.12.4 [[CanPut]] (P)8.12.5 [[Put]] ( P, V, Throw )8.12.6 [[HasProperty]] (P)8.12.7 [[Delete]] (P, Throw)8.12.8 [[DefaultValue]] (hint)8.12.9 [[DefineOwnProperty]] (P,\n          Desc, Throw)","markdown":"# [8](#sec-8 \"link to this section\") Types\n\nAlgorithms within this specification manipulate values each of which has an associated type. The possible value types are exactly those defined in this clause. Types are further subclassified into ECMAScript language types and specification types.\n\nAn ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Number, and Object.\n\nA specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. The specification types are [Reference](#sec-8.7), [List](#sec-8.8), [Completion](#sec-8.9), [Property Descriptor](#sec-8.10), [Property Identifier](#sec-8.10), [Lexical Environment](#sec-10.2), and [Environment Record](#sec-10.2.1). Specification type values are specification artefacts that do not necessarily correspond to any specific entity within an ECMAScript implementation. Specification type values may be used to describe intermediate results of ECMAScript expression evaluation but such values cannot be stored as properties of objects or values of ECMAScript language variables.\n\nWithin this specification, the notation “Type(_x_)” is used as shorthand for “the type of _x_” where “type” refers to the ECMAScript language and specification types defined in this clause.\n\n# [8.1](#sec-8.1 \"link to this section\") The Undefined Type\n\nThe Undefined type has exactly one value, called **undefined**. Any variable that has not been assigned a value has the value **undefined**.\n\n# [8.2](#sec-8.2 \"link to this section\") The Null Type\n\nThe Null type has exactly one value, called **null**.\n\n# [8.3](#sec-8.3 \"link to this section\") The Boolean Type\n\nThe Boolean type represents a logical entity having two values, called **true** and **false**.\n\n# [8.4](#sec-8.4 \"link to this section\") The String Type\n\nThe String type is the set of all finite ordered sequences of zero or more 16-bit unsigned integer values (“elements”). The String type is generally used to represent textual data in a running ECMAScript program, in which case each element in the String is treated as a code unit value ([see Clause 6](#sec-6)). Each element is regarded as occupying a position within the sequence. These positions are indexed with nonnegative integers. The first element (if any) is at position 0, the next element (if any) at position 1, and so on. The length of a String is the number of elements (i.e., 16-bit values) within it. The empty String has length zero and therefore contains no elements.\n\nWhen a String contains actual textual data, each element is considered to be a single UTF-16 code unit. Whether or not this is the actual storage format of a String, the characters within a String are numbered by their initial code unit element position as though they were represented using UTF-16\\. All operations on Strings (except as otherwise stated) treat them as sequences of undifferentiated 16-bit unsigned integers; they do not ensure the resulting String is in normalised form, nor do they ensure language-sensitive results.\n\nNOTE The rationale behind this design was to keep the implementation of Strings as simple and high-performing as possible. The intent is that textual data coming into the execution environment from outside (e.g., user input, text read from a file or received over the network, etc.) be converted to Unicode Normalised Form C before the running program sees it. Usually this would occur at the same time incoming text is converted from its original character encoding to Unicode (and would impose no additional overhead). Since it is recommended that ECMAScript source code be in Normalised Form C, string literals are guaranteed to be normalised (if source text is guaranteed to be normalised), as long as they do not contain any Unicode escape sequences.\n\n# [8.5](#sec-8.5 \"link to this section\") The Number Type\n\nThe Number type has exactly 18437736874454810627 (that is, 264−253+3) values, representing the double-precision 64-bit format IEEE 754 values as specified in the IEEE Standard for Binary Floating-Point Arithmetic, except that the 9007199254740990 (that is, 253−2) distinct “Not-a-Number” values of the IEEE Standard are represented in ECMAScript as a single special **NaN** value. (Note that the **NaN** value is produced by the program expression`NaN`.) In some implementations, external code might be able to detect a difference between various Not-a-Number values, but such behaviour is implementation-dependent; to ECMAScript code, all NaN values are indistinguishable from each other.\n\nThere are two other special values, called **positive Infinity** and **negative Infinity**. For brevity, these values are also referred to for expository purposes by the symbols +∞ and −∞, respectively. (Note that these two infinite Number values are produced by the program expressions `+Infinity` (or simply `Infinity`) and `-Infinity`.)\n\nThe other 18437736874454810624 (that is, 264−253) values are called the finite numbers. Half of these are positive numbers and half are negative numbers; for every finite positive Number value there is a corresponding negative value having the same magnitude.\n\nNote that there is both a **positive zero** and a **negative zero**. For brevity, these values are also referred to for expository purposes by the symbols +0 and −0, respectively. (Note that these two different zero Number values are produced by the program expressions `+0` (or simply`0`) and `-0`.)\n\nThe 18437736874454810622 (that is, 264−253−2) finite nonzero values are of two kinds:\n\n18428729675200069632 (that is, 264−254) of them are normalised, having the form\n\n_s_ × _m_ × 2_e_\n\nwhere s is +1 or −1, m is a positive integer less than 253 but not less than 252, ande is an integer ranging from −1074 to 971, inclusive.\n\nThe remaining 9007199254740990 (that is, 253−2) values are denormalised, having the form\n\n_s_ × _m_ × 2_e_\n\nwhere s is +1 or −1, m is a positive integer less than 252, and e is −1074.\n\nNote that all the positive and negative integers whose magnitude is no greater than 253 are representable in the Number type (indeed, the integer 0 has two representations, `+0` and `-0`).\n\nA finite number has an _odd significand_ if it is nonzero and the integer m used to express it (in one of the two forms shown above) is odd. Otherwise, it has an _even significand_.\n\nIn this specification, the phrase “the Number value for_x_” where x represents an exact nonzero real mathematical quantity (which might even be an irrational number such as π) means a Number value chosen in the following manner. Consider the set of all finite values of the Number type, with −0 removed and with two additional values added to it that are not representable in the Number type, namely 21024 (which is +1 × 253 × 2971) and −21024 (which is −1 × 253 × 2971). Choose the member of this set that is closest in value to x. If two values of the set are equally close, then the one with an even significand is chosen; for this purpose, the two extra values 21024 and −21024 are considered to have even significands. Finally, if 21024 was chosen, replace it with +∞; if −21024 was chosen, replace it with −∞; if +0 was chosen, replace it with −0 if and only if x is less than zero; any other chosen value is used unchanged. The result is the Number value for x. (This procedure corresponds exactly to the behaviour of the IEEE 754 “round to nearest” mode.)\n\nSome ECMAScript operators deal only with integers in the range −231 through 231−1, inclusive, or in the range 0 through 232−1, inclusive. These operators accept any value of the Number type but first convert each such value to one of 232 integer values. See the descriptions of the [ToInt32](#sec-9.5) and [ToUint32](#sec-9.6) operators in [9.5](#sec-9.5) and [9.6](#sec-9.6), respectively.\n\n# [8.6](#sec-8.6 \"link to this section\") The Object Type\n\nAn Object is a collection of properties. Each property is either a named data property, a named accessor property, or an internal property:\n\n* A _named data property_ associates a name with an ECMAScript language value and a set of Boolean attributes.\n* A _named accessor property_ associates a name with one or two accessor functions, and a set of Boolean attributes. The accessor functions are used to store or retrieve an ECMAScript language value that is associated with the property.\n* An _internal property_ has no name and is not directly accessible via ECMAScript language operators. Internal properties exist purely for specification purposes.\n\nThere are two kinds of access for named (non-internal) properties: _get_ and _put_, corresponding to retrieval and assignment, respectively.\n\n# [8.6.1](#sec-8.6.1 \"link to this section\") Property Attributes\n\nAttributes are used in this specification to define and explain the state of named properties. A named data property associates a name with the attributes listed in Table 5\n\nTable 5 — Attributes of a Named Data Property\n\n| Attribute Name       | Value Domain                 | Description                                                                                                                                                   |\n| -------------------- | ---------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| \\[\\[Value\\]\\]        | Any ECMAScript language type | The value retrieved by reading the property.                                                                                                                  |\n| \\[\\[Writable\\]\\]     | Boolean                      | If **false**, attempts by ECMAScript code to change the property’s \\[\\[Value\\]\\] attribute using \\[\\[Put\\]\\] will not succeed.                                |\n| \\[\\[Enumerable\\]\\]   | Boolean                      | If **true**, the property will be enumerated by a for-in enumeration ([see 12.6.4](#sec-12.6.4)). Otherwise, the property is said to be non-enumerable.       |\n| \\[\\[Configurable\\]\\] | Boolean                      | If **false**, attempts to delete the property, change the property to be an accessor property, or change its attributes (other than \\[\\[Value\\]\\]) will fail. |\n\nA named accessor property associates a name with the attributes listed in Table 6.\n\nTable 6 — Attributes of a Named Accessor Property\n\n| Attribute Name       | Value Domain          | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n| -------------------- | --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| \\[\\[Get\\]\\]          | Object _or_ Undefined | If the value is an Object it must be a function Object. The function’s \\[\\[Call\\]\\] internal method ([8.6.2](#sec-8.6.2)) is called with an empty arguments list to return the property value each time a get access of the property is performed.                                                                                                                                                                                                             |\n| \\[\\[Set\\]\\]          | Object _or_ Undefined | If the value is an Object it must be a function Object. The function’s \\[\\[Call\\]\\] internal method ([8.6.2](#sec-8.6.2)) is called with an arguments list containing the assigned value as its sole argument each time a set access of the property is performed. The effect of a property's \\[\\[Set\\]\\] internal method may, but is not required to, have an effect on the value returned by subsequent calls to the property's \\[\\[Get\\]\\] internal method. |\n| \\[\\[Enumerable\\]\\]   | Boolean               | If **true**, the property is to be enumerated by a for-in enumeration ([see 12.6.4](#sec-12.6.4)). Otherwise, the property is said to be non-enumerable.                                                                                                                                                                                                                                                                                                       |\n| \\[\\[Configurable\\]\\] | Boolean               | If **false**, attempts to delete the property, change the property to be a data property, or change its attributes will fail.                                                                                                                                                                                                                                                                                                                                  |\n\nIf the value of an attribute is not explicitly specified by this specification for a named property, the default value defined in Table 7 is used.\n\nTable 7 — Default Attribute Values\n\n| Attribute Name       | Default Value |\n| -------------------- | ------------- |\n| \\[\\[Value\\]\\]        | **undefined** |\n| \\[\\[Get\\]\\]          | **undefined** |\n| \\[\\[Set\\]\\]          | **undefined** |\n| \\[\\[Writable\\]\\]     | **false**     |\n| \\[\\[Enumerable\\]\\]   | **false**     |\n| \\[\\[Configurable\\]\\] | **false**     |\n\n# [8.6.2](#sec-8.6.2 \"link to this section\") Object Internal Properties and Methods\n\nThis specification uses various internal properties to define the semantics of object values. These internal properties are not part of the ECMAScript language. They are defined by this specification purely for expository purposes. An implementation of ECMAScript must behave as if it produced and operated upon internal properties in the manner described here. The names of internal properties are enclosed in double square brackets \\[\\[ \\]\\]. When an algorithm uses an internal property of an object and the object does not implement the indicated internal property, a **TypeError** exception is thrown.\n\nThe Table 8 summarises the internal properties used by this specification that are applicable to all ECMAScript objects. The Table 9 summarises the internal properties used by this specification that are only applicable to some ECMAScript objects. The descriptions in these tables indicate their behaviour for native ECMAScript objects, unless stated otherwise in this document for particular kinds of native ECMAScript objects. Host objects may support these internal properties with any implementation-dependent behaviour as long as it is consistent with the specific host object restrictions stated in this document.\n\nThe “Value Type Domain” columns of the following tables define the types of values associated with internal properties. The type names refer to the types defined in [Clause 8](#sec-8) augmented by the following additional names. “_any_” means the value may be any ECMAScript language type. “_primitive_” means Undefined, Null, Boolean, String, or Number. “_SpecOp_” means the internal property is an internal method, an implementation provided procedure defined by an abstract operation specification. “SpecOp” is followed by a list of descriptive parameter names. If a parameter name is the same as a type name then the name describes the type of the parameter. If a “SpecOp” returns a value, its parameter list is followed by the symbol “→” and the type of the returned value.\n\nTable 8 — Internal Properties Common to All Objects\n\n| Internal Property         | Value Type Domain                                                               | Description                                                                                                                                     |\n| ------------------------- | ------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |\n| \\[\\[Prototype\\]\\]         | Object _or_ Null                                                                | The prototype of this object.                                                                                                                   |\n| \\[\\[Class\\]\\]             | String                                                                          | A String value indicating a specification defined classification of objects.                                                                    |\n| \\[\\[Extensible\\]\\]        | Boolean                                                                         | If **true**, own properties may be added to the object.                                                                                         |\n| \\[\\[Get\\]\\]               | SpecOp(_propertyName_) **_→_** any                                              | Returns the value of the named property.                                                                                                        |\n| \\[\\[GetOwnProperty\\]\\]    | SpecOp (_propertyName_) **_→_** Undefined _or_ [Property Descriptor](#sec-8.10) | Returns the [Property Descriptor](#sec-8.10) of the named own property of this object, or **undefined** if absent.                              |\n| \\[\\[GetProperty\\]\\]       | SpecOp (_propertyName_) **_→_** Undefined _or_ [Property Descriptor](#sec-8.10) | Returns the fully populated [Property Descriptor](#sec-8.10) of the named property of this object, or **undefined** if absent.                  |\n| \\[\\[Put\\]\\]               | SpecOp (_propertyName_, _any, Boolean_)                                         | Sets the specified named property to the value of the second parameter. The flag controls failure handling.                                     |\n| \\[\\[CanPut\\]\\]            | SpecOp (_propertyName_) **_→_** Boolean                                         | Returns a Boolean value indicating whether a \\[\\[Put\\]\\] operation with _PropertyName_ can be performed.                                        |\n| \\[\\[HasProperty\\]\\]       | SpecOp (_propertyName_) **_→_** _Boolean_                                       | Returns a Boolean value indicating whether the object already has a property with the given name.                                               |\n| \\[\\[Delete\\]\\]            | SpecOp (_propertyName, Boolean_) **_→_** Boolean                                | Removes the specified named own property from the object. The flag controls failure handling.                                                   |\n| \\[\\[DefaultValue\\]\\]      | SpecOp (_Hint_) **_→_** _primitive_                                             | Hint is a String. Returns a default value for the object.                                                                                       |\n| \\[\\[DefineOwnProperty\\]\\] | SpecOp (_propertyName, PropertyDescriptor, Boolean_) **_→_** Boolean            | Creates or alters the named own property to have the state described by a [Property Descriptor](#sec-8.10). The flag controls failure handling. |\n\nEvery object (including host objects) must implement all of the internal properties listed in Table 8\\. However, the \\[\\[DefaultValue\\]\\] internal method may, for some objects, simply throw a **TypeError** exception.\n\nAll objects have an internal property called \\[\\[Prototype\\]\\]. The value of this property is either **null** or an object and is used for implementing inheritance. Whether or not a native object can have a host object as its \\[\\[Prototype\\]\\] depends on the implementation. Every \\[\\[Prototype\\]\\] chain must have finite length (that is, starting from any object, recursively accessing the \\[\\[Prototype\\]\\] internal property must eventually lead to a **null** value). Named data properties of the \\[\\[Prototype\\]\\] object are inherited (are visible as properties of the child object) for the purposes of get access, but not for put access. Named accessor properties are inherited for both get access and put access.\n\nEvery ECMAScript object has a Boolean-valued \\[\\[Extensible\\]\\] internal property that controls whether or not named properties may be added to the object. If the value of the \\[\\[Extensible\\]\\] internal property is **false** then additional named properties may not be added to the object. In addition, if \\[\\[Extensible\\]\\] is **false** the value of the \\[\\[Class\\]\\] and \\[\\[Prototype\\]\\] internal properties of the object may not be modified. Once the value of an \\[\\[Extensible\\]\\] internal property has been set to **false** it may not be subsequently changed to **true**.\n\nNOTE This specification defines no ECMAScript language operators or built-in functions that permit a program to modify an object’s \\[\\[Class\\]\\] or \\[\\[Prototype\\]\\] internal properties or to change the value of \\[\\[Extensible\\]\\] from **false** to **true**. Implementation specific extensions that modify \\[\\[Class\\]\\], \\[\\[Prototype\\]\\] or \\[\\[Extensible\\]\\] must not violate the invariants defined in the preceding paragraph.\n\nThe value of the \\[\\[Class\\]\\] internal property is defined by this specification for every kind of built-in object. The value of the \\[\\[Class\\]\\] internal property of a host object may be any String value except one of `\"Arguments\"`,`\"Array\"`, `\"Boolean\"`, `\"Date\"`, `\"Error\"`, `\"Function\"`,`\"JSON\"`, `\"Math\"`, `\"Number\"`, `\"Object\"`, `\"RegExp\"`, and`\"String\"`. The value of a \\[\\[Class\\]\\] internal property is used internally to distinguish different kinds of objects. Note that this specification does not provide any means for a program to access that value except through`Object.prototype.toString` ([see 15.2.4.2](#sec-15.2.4.2)).\n\nUnless otherwise specified, the common internal methods of native ECMAScript objects behave as described in [8.12](#sec-8.12). Array objects have a slightly different implementation of the \\[\\[DefineOwnProperty\\]\\] internal method ([see 15.4.5.1](#sec-15.4.5.1)) and String objects have a slightly different implementation of the \\[\\[GetOwnProperty\\]\\] internal method ([see 15.5.5.2](#sec-15.5.5.2)). Arguments objects ([10.6](#sec-10.6)) have different implementations of \\[\\[Get\\]\\], \\[\\[GetOwnProperty\\]\\], \\[\\[DefineOwnProperty\\]\\], and \\[\\[Delete\\]\\]. Function objects ([15.3](#sec-15.3)) have a different implementation of \\[\\[Get\\]\\].\n\nHost objects may implement these internal methods in any manner unless specified otherwise; for example, one possibility is that \\[\\[Get\\]\\] and \\[\\[Put\\]\\] for a particular host object indeed fetch and store property values but \\[\\[HasProperty\\]\\] always generates **false**. However, if any specified manipulation of a host object's internal properties is not supported by an implementation, that manipulation must throw a **TypeError** exception when attempted.\n\nThe \\[\\[GetOwnProperty\\]\\] internal method of a host object must conform to the following invariants for each property of the host object:\n\n* If a property is described as a data property and it may return different values over time, then either or both of the \\[\\[Writable\\]\\] and \\[\\[Configurable\\]\\] attributes must be **true** even if no mechanism to change the value is exposed via the other internal methods.\n* If a property is described as a data property and its \\[\\[Writable\\]\\] and \\[\\[Configurable\\]\\] are both **false**, then the [SameValue (according to 9.12)](#sec-9.12) must be returned for the \\[\\[Value\\]\\] attribute of the property on all calls to \\[\\[GetOwnProperty\\]\\].\n* If the attributes other than \\[\\[Writable\\]\\] may change over time or if the property might disappear, then the \\[\\[Configurable\\]\\] attribute must be **true**.\n* If the \\[\\[Writable\\]\\] attribute may change from **false** to **true**, then the \\[\\[Configurable\\]\\] attribute must be **true**.\n* If the value of the host object’s \\[\\[Extensible\\]\\] internal property has been observed by ECMAScript code to be**false**, then if a call to \\[\\[GetOwnProperty\\]\\] describes a property as non-existent all subsequent calls must also describe that property as non-existent.\n\nThe \\[\\[DefineOwnProperty\\]\\] internal method of a host object must not permit the addition of a new property to a host object if the \\[\\[Extensible\\]\\] internal property of that host object has been observed by ECMAScript code to be**false**.\n\nIf the \\[\\[Extensible\\]\\] internal property of that host object has been observed by ECMAScript code to be **false** then it must not subsequently become **true**.\n\nTable 9 — Internal Properties Only Defined for Some Objects\n\n| Internal Property        | Value Type Domain                                                                 | Description                                                                                                                                                                                                                                                                                                                                                |\n| ------------------------ | --------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| \\[\\[PrimitiveValue\\]\\]   | _primitive_                                                                       | Internal state information associated with this object. Of the standard built-in ECMAScript objects, only Boolean, Date, Number, and String objects implement \\[\\[PrimitiveValue\\]\\].                                                                                                                                                                      |\n| \\[\\[Construct\\]\\]        | SpecOp(a [List](#sec-8.8) of _any_) **_→_** Object                                | Creates an object. Invoked via the new operator. The arguments to the SpecOp are the arguments passed to the **new** operator. Objects that implement this internal method are called _constructors_.                                                                                                                                                      |\n| \\[\\[Call\\]\\]             | SpecOp(_any_, a [List](#sec-8.8) of _any_) **_→_** _any_ or [Reference](#sec-8.7) | Executes code associated with the object. Invoked via a function call expression. The arguments to the SpecOp are this object and a list containing the arguments passed to the function call expression. Objects that implement this internal method are _callable_. Only callable objects that are host objects may return [Reference](#sec-8.7) values. |\n| \\[\\[HasInstance\\]\\]      | SpecOp(_any_) **_→_** Boolean                                                     | Returns a Boolean value indicating whether the argument is likely an Object that was constructed by this object. Of the standard built-in ECMAScript objects, only Function objects implement \\[\\[HasInstance\\]\\].                                                                                                                                         |\n| \\[\\[Scope\\]\\]            | [Lexical Environment](#sec-10.2)                                                  | A [lexical environment](#sec-10.2) that defines the environment in which a Function object is executed. Of the standard built-in ECMAScript objects, only Function objects implement \\[\\[Scope\\]\\].                                                                                                                                                        |\n| \\[\\[FormalParameters\\]\\] | [List](#sec-8.8) of Strings                                                       | A possibly empty [List](#sec-8.8) containing the identifier Strings of a Function’s FormalParameterList. Of the standard built-in ECMAScript objects, only Function objects implement \\[\\[FormalParameterList\\]\\].                                                                                                                                         |\n| \\[\\[Code\\]\\]             | ECMAScript code                                                                   | The ECMAScript code of a function. Of the standard built-in ECMAScript objects, only Function objects implement \\[\\[Code\\]\\].                                                                                                                                                                                                                              |\n| \\[\\[TargetFunction\\]\\]   | Object                                                                            | The target function of a function object created using the standard built-in Function.prototype.bind method. Only ECMAScript objects created using Function.prototype.bind have a \\[\\[TargetFunction\\]\\] internal property.                                                                                                                                |\n| \\[\\[BoundThis\\]\\]        | _any_                                                                             | The pre-bound this value of a function Object created using the standard built-in Function.prototype.bind method. Only ECMAScript objects created using Function.prototype.bind have a \\[\\[BoundThis\\]\\] internal property.                                                                                                                                |\n| \\[\\[BoundArguments\\]\\]   | [List](#sec-8.8) of _any_                                                         | The pre-bound argument values of a function Object created using the standard built-in Function.prototype.bind method. Only ECMAScript objects created using Function.prototype.bind have a \\[\\[BoundArguments\\]\\] internal property.                                                                                                                      |\n| \\[\\[Match\\]\\]            | SpecOp(_String_, _index_) **_→_** _MatchResult_                                   | Tests for a regular expression match and returns a MatchResult value ([see 15.10.2.1](#sec-15.10.2.1)). Of the standard built-in ECMAScript objects, only RegExp objects implement \\[\\[Match\\]\\].                                                                                                                                                          |\n| \\[\\[ParameterMap\\]\\]     | Object                                                                            | Provides a mapping between the properties of an arguments object ([see 10.6](#sec-10.6)) and the formal parameters of the associated function. Only ECMAScript objects that are arguments objects have a \\[\\[ParameterMap\\]\\] internal property.                                                                                                           |\n\n# [8.7](#sec-8.7 \"link to this section\") The Reference Specification Type\n\nThe Reference type is used to explain the behaviour of such operators as `delete`, `typeof`, and the assignment operators. For example, the left-hand operand of an assignment is expected to produce a reference. The behaviour of assignment could, instead, be explained entirely in terms of a case analysis on the syntactic form of the left-hand operand of an assignment operator, but for one difficulty: function calls are permitted to return references. This possibility is admitted purely for the sake of host objects. No built-in ECMAScript function defined by this specification returns a reference and there is no provision for a user-defined function to return a reference. (Another reason not to use a syntactic case analysis is that it would be lengthy and awkward, affecting many parts of the specification.)\n\nA **Reference** is a resolved name binding. A Reference consists of three components, the base value, thereferenced name and the Boolean valued strict reference flag. The base value is either **undefined**, an Object, a Boolean, a String, a Number, or an [environment record (10.2.1)](#sec-10.2.1). A base value of**undefined** indicates that the reference could not be resolved to a binding. The referenced name is a String.\n\nThe following abstract operations are used in this specification to access the components of references:\n\n* GetBase(V). Returns the base value component of the reference V.\n* GetReferencedName(V). Returns the referenced name component of the reference V.\n* IsStrictReference(V). Returns the strict reference component of the reference V.\n* HasPrimitiveBase(V). Returns **true** if the base value is a Boolean, String, or Number.\n* IsPropertyReference(V). Returns **true** if either the base value is an object or HasPrimitiveBase(V) is**true**; otherwise returns **false**.\n* IsUnresolvableReference(V). Returns **true** if the base value is **undefined** and **false** otherwise.\n\nThe following abstract operations are used in this specification to operate on references:\n\n# [8.7.1](#sec-8.7.1 \"link to this section\") GetValue (V)\n\n1. If [Type](#sec-8)(_V_) is not [Reference](#sec-8.7), return _V_.\n2. Let _base_ be the result of calling [GetBase](#sec-8.7)(_V_).\n3. If [IsUnresolvableReference](#sec-8.7)(_V_), throw a **ReferenceError** exception.\n4. If [IsPropertyReference](#sec-8.7)(_V_), then  \n   1. If [HasPrimitiveBase](#sec-8.7)(_V_) is **false**, then let _get_ be the \\[\\[Get\\]\\] internal method of _base_, otherwise let _get_ be the special \\[\\[Get\\]\\] internal method defined below.  \n   2. Return the result of calling the _get_ internal method using _base_ as its **this** value, and passing [GetReferencedName](#sec-8.7)(_V_) for the argument.\n5. Else, _base_ must be an environment record.  \n   1. Return the result of calling the GetBindingValue ([see 10.2.1](#sec-10.2.1)) concrete method of_base_ passing [GetReferencedName](#sec-8.7)(_V_) and [IsStrictReference](#sec-8.7)(_V_) as arguments.\n\nThe following \\[\\[Get\\]\\] internal method is used by GetValue when V is a property reference with a primitive base value. It is called using base as its **this** value and with property P as its argument. The following steps are taken:\n\n1. Let _O_ be [ToObject](#sec-9.9)(_base_).\n2. Let _desc_ be the result of calling the \\[\\[GetProperty\\]\\] internal method of _O_ with property name_P_.\n3. If _desc_ is **undefined**, return **undefined**.\n4. If [IsDataDescriptor](#sec-8.10.2)(_desc_) is **true**, return _desc_.\\[\\[Value\\]\\].\n5. Otherwise, [IsAccessorDescriptor](#sec-8.10.1)(_desc_) must be **true** so, let _getter_ be_desc_.\\[\\[Get\\]\\] ([see 8.10](#sec-8.10)).\n6. If _getter_ is **undefined**, return **undefined**.\n7. Return the result calling the \\[\\[Call\\]\\] internal method of _getter_ providing _base_ as the **this** value and providing no arguments.\n\nNOTE The object that may be created in step 1 is not accessible outside of the above method. An implementation might choose to avoid the actual creation of the object. The only situation where such an actual property access that uses this internal method can have visible effect is when it invokes an accessor function.\n\n# [8.7.2](#sec-8.7.2 \"link to this section\") PutValue (V, W)\n\n1. If [Type](#sec-8)(_V_) is not [Reference](#sec-8.7), throw a **ReferenceError** exception.\n2. Let _base_ be the result of calling [GetBase](#sec-8.7)(_V_).\n3. If [IsUnresolvableReference](#sec-8.7)(_V_), then  \n   1. If [IsStrictReference](#sec-8.7)(_V_) is **true**, then  \n         1. Throw **ReferenceError** exception.  \n   2. Call the \\[\\[Put\\]\\] internal method of the global object, passing [GetReferencedName](#sec-8.7)(_V_) for the property name, _W_ for the value, and **false** for the _Throw_ flag.\n4. Else if [IsPropertyReference](#sec-8.7)(_V_), then  \n   1. If [HasPrimitiveBase](#sec-8.7)(_V_) is **false**, then let _put_ be the \\[\\[Put\\]\\] internal method of _base_, otherwise let _put_ be the special \\[\\[Put\\]\\] internal method defined below.  \n   2. Call the _put_ internal method using _base_ as its **this** value, and passing [GetReferencedName](#sec-8.7)(_V_) for the property name, _W_ for the value, and [IsStrictReference](#sec-8.7)(_V_) for the _Throw_ flag.\n5. Else _base_ must be a reference whose base is an environment record. So,  \n   1. Call the SetMutableBinding ([10.2.1](#sec-10.2.1)) concrete method of _base_, passing [GetReferencedName](#sec-8.7)(_V_), _W_, and [IsStrictReference](#sec-8.7)(_V_) as arguments.\n6. Return.\n\nThe following \\[\\[Put\\]\\] internal method is used by PutValue when V is a property reference with a primitive base value. It is called using base as its **this** value and with property P, value W, and Boolean flag Throw as arguments. The following steps are taken:\n\n1. Let _O_ be [ToObject](#sec-9.9)(_base_).\n2. If the result of calling the \\[\\[CanPut\\]\\] internal method of _O_ with argument _P_ is **false**, then  \n   1. If _Throw_ is **true**, then throw a **TypeError** exception.  \n   2. Else return.\n3. Let _ownDesc_ be the result of calling the \\[\\[GetOwnProperty\\]\\] internal method of _O_ with argument_P_.\n4. If [IsDataDescriptor](#sec-8.10.2)(_ownDesc_) is **true**, then  \n   1. If _Throw_ is **true**, then throw a **TypeError** exception.  \n   2. Else return.\n5. Let _desc_ be the result of calling the \\[\\[GetProperty\\]\\] internal method of _O_ with argument _P_. This may be either an own or inherited accessor property descriptor or an inherited data property descriptor.\n6. If [IsAccessorDescriptor](#sec-8.10.1)(_desc_) is **true**, then  \n   1. Let _setter_ be _desc_.\\[\\[Set\\]\\] ([see 8.10](#sec-8.10)) which cannot be **undefined**.  \n   2. Call the \\[\\[Call\\]\\] internal method of _setter_ providing _base_ as the **this** value and an argument list containing only _W_.\n7. Else, this is a request to create an own property on the transient object _O_  \n   1. If _Throw_ is **true**, then throw a **TypeError** exception.\n8. Return.\n\nNOTE The object that may be created in step 1 is not accessible outside of the above method. An implementation might choose to avoid the actual creation of that transient object. The only situations where such an actual property assignment that uses this internal method can have visible effect are when it either invokes an accessor function or is in violation of a Throw predicated error check. When Throw is **true** any property assignment that would create a new property on the transient object throws an error.\n\n# [8.8](#sec-8.8 \"link to this section\") The List Specification Type\n\nThe List type is used to explain the evaluation of argument lists ([see 11.2.4](#sec-11.2.4)) in`new` expressions, in function calls, and in other algorithms where a simple list of values is needed. Values of the List type are simply ordered sequences of values. These sequences may be of any length.\n\n# [8.9](#sec-8.9 \"link to this section\") The Completion Specification Type\n\nThe Completion type is used to explain the behaviour of statements (`break`, `continue`,`return` and `throw`) that perform nonlocal transfers of control. Values of the Completion type are triples of the form (_type_, _value_, _target_), where _type_ is one of **normal**, **break**,**continue**, **return**, or **throw**, _value_ is any ECMAScript language value or **empty**, and_target_ is any ECMAScript identifier or **empty**. If cv is a completion value then _cv_.type, _cv_.value, and _cv_.target may be used to directly refer to its constituent values.\n\nThe term “abrupt completion” refers to any completion with a _type_ other than **normal**.\n\n# [8.10](#sec-8.10 \"link to this section\") The Property Descriptor and Property Identifier Specification Types\n\nThe Property Descriptor type is used to explain the manipulation and reification of named property attributes. Values of the Property Descriptor type are records composed of named fields where each field’s name is an attribute name and its value is a corresponding attribute value as specified in [8.6.1](#sec-8.6.1). In addition, any field may be present or absent.\n\nProperty Descriptor values may be further classified as data property descriptors and accessor property descriptors based upon the existence or use of certain fields. A data property descriptor is one that includes any fields named either \\[\\[Value\\]\\] or \\[\\[Writable\\]\\]. An accessor property descriptor is one that includes any fields named either \\[\\[Get\\]\\] or \\[\\[Set\\]\\]. Any property descriptor may have fields named \\[\\[Enumerable\\]\\] and \\[\\[Configurable\\]\\]. A Property Descriptor value may not be both a data property descriptor and an accessor property descriptor; however, it may be neither. A generic property descriptor is a Property Descriptor value that is neither a data property descriptor nor an accessor property descriptor. A fully populated property descriptor is one that is either an accessor property descriptor or a data property descriptor and that has all of the fields that correspond to the property attributes defined in either 8.6.1 Table 5 or Table 6.\n\nFor notational convenience within this specification, an object literal-like syntax can be used to define a property descriptor value. For example, Property Descriptor {\\[\\[Value\\]\\]: 42, \\[\\[Writable\\]\\]: **false**, \\[\\[Configurable\\]\\]: **true**} defines a data property descriptor. Field name order is not significant. Any fields that are not explicitly listed are considered to be absent.\n\nIn specification text and algorithms, dot notation may be used to refer to a specific field of a Property Descriptor. For example, if D is a property descriptor then D.\\[\\[Value\\]\\] is shorthand for “the field of D named \\[\\[Value\\]\\]”.\n\nThe Property Identifier type is used to associate a property name with a Property Descriptor. Values of the Property Identifier type are pairs of the form (name, descriptor), where name is a String and descriptor is a Property Descriptor value.\n\nThe following abstract operations are used in this specification to operate upon Property Descriptor values:\n\n# [8.10.1](#sec-8.10.1 \"link to this section\") IsAccessorDescriptor ( Desc )\n\nWhen the abstract operation IsAccessorDescriptor is called with property descriptor Desc, the following steps are taken:\n\n1. If _Desc_ is **undefined**, then return **false**.\n2. If both _Desc_.\\[\\[Get\\]\\] and _Desc_.\\[\\[Set\\]\\] are absent, then return **false**.\n3. Return **true**.\n\n# [8.10.2](#sec-8.10.2 \"link to this section\") IsDataDescriptor ( Desc )\n\nWhen the abstract operation IsDataDescriptor is called with property descriptor Desc, the following steps are taken:\n\n1. If _Desc_ is **undefined**, then return **false**.\n2. If both _Desc_.\\[\\[Value\\]\\] and _Desc_.\\[\\[Writable\\]\\] are absent, then return **false**.\n3. Return **true**.\n\n# [8.10.3](#sec-8.10.3 \"link to this section\") IsGenericDescriptor ( Desc )\n\nWhen the abstract operation IsGenericDescriptor is called with property descriptor Desc, the following steps are taken:\n\n1. If _Desc_ is **undefined**, then return **false**.\n2. If [IsAccessorDescriptor](#sec-8.10.1)(_Desc_) and [IsDataDescriptor](#sec-8.10.2)(_Desc_) are both **false**, then return **true**.\n3. Return **false**.\n\n# [8.10.4](#sec-8.10.4 \"link to this section\") FromPropertyDescriptor ( Desc )\n\nWhen the abstract operation FromPropertyDescriptor is called with property descriptor Desc, the following steps are taken:\n\nThe following algorithm assumes that Desc is a fully populated [Property Descriptor](#sec-8.10), such as that returned from \\[\\[GetOwnProperty\\]\\] ([see 8.12.1](#sec-8.12.1)).\n\n1. If _Desc_ is **undefined**, then return **undefined**.\n2. Let _obj_ be the result of creating a new object as if by the expression **new Object()** where **Object** is the standard built-in constructor with that name.\n3. If [IsDataDescriptor](#sec-8.10.2)(_Desc_) is **true**, then  \n   1. Call the \\[\\[DefineOwnProperty\\]\\] internal method of _obj_ with arguments \"`value`\", [Property Descriptor](#sec-8.10) {\\[\\[Value\\]\\]: _Desc_.\\[\\[Value\\]\\], \\[\\[Writable\\]\\]: **true**, \\[\\[Enumerable\\]\\]: **true**, \\[\\[Configurable\\]\\]: **true**}, and **false**.  \n   2. Call the \\[\\[DefineOwnProperty\\]\\] internal method of _obj_ with arguments \"`writable`\", [Property Descriptor](#sec-8.10) {\\[\\[Value\\]\\]: _Desc_.\\[\\[Writable\\]\\], \\[\\[Writable\\]\\]: **true**, \\[\\[Enumerable\\]\\]: **true**, \\[\\[Configurable\\]\\]: **true**}, and **false**.\n4. Else, [IsAccessorDescriptor](#sec-8.10.1)(_Desc_) must be **true**, so  \n   1. Call the \\[\\[DefineOwnProperty\\]\\] internal method of _obj_ with arguments \"`get\"`, [Property Descriptor](#sec-8.10) {\\[\\[Value\\]\\]: _Desc_.\\[\\[Get\\]\\], \\[\\[Writable\\]\\]: **true**, \\[\\[Enumerable\\]\\]: **true**, \\[\\[Configurable\\]\\]: **true**}, and **false**.  \n   2. Call the \\[\\[DefineOwnProperty\\]\\] internal method of _obj_ with arguments \"`set`\", [Property Descriptor](#sec-8.10) {\\[\\[Value\\]\\]: _Desc_.\\[\\[Set\\]\\], \\[\\[Writable\\]\\]: **true**, \\[\\[Enumerable\\]\\]: **true**, \\[\\[Configurable\\]\\]: **true**}, and **false**.\n5. Call the \\[\\[DefineOwnProperty\\]\\] internal method of _obj_ with arguments \"`enumerable`\", [Property Descriptor](#sec-8.10) {\\[\\[Value\\]\\]: _Desc_.\\[\\[Enumerable\\]\\], \\[\\[Writable\\]\\]: **true**, \\[\\[Enumerable\\]\\]: **true**, \\[\\[Configurable\\]\\]: **true**}, and **false**.\n6. Call the \\[\\[DefineOwnProperty\\]\\] internal method of _obj_ with arguments \"`configurable`\", [Property Descriptor](#sec-8.10) {\\[\\[Value\\]\\]: _Desc_.\\[\\[Configurable\\]\\], \\[\\[Writable\\]\\]: **true**, \\[\\[Enumerable\\]\\]: **true**, \\[\\[Configurable\\]\\]: **true**}, and **false**.\n7. Return _obj_.\n\n# [8.10.5](#sec-8.10.5 \"link to this section\") ToPropertyDescriptor ( Obj )\n\nWhen the abstract operation ToPropertyDescriptor is called with object Obj, the following steps are taken:\n\n1. If [Type](#sec-8)(_Obj_) is not Object throw a **TypeError** exception.\n2. Let _desc_ be the result of creating a new [Property Descriptor](#sec-8.10) that initially has no fields.\n3. If the result of calling the \\[\\[HasProperty\\]\\] internal method of _Obj_ with argument \"`enumerable`\" is**true**, then  \n   1. Let _enum_ be the result of calling the \\[\\[Get\\]\\] internal method of _Obj_ with \"`enumerable`\".  \n   2. Set the \\[\\[Enumerable\\]\\] field of _desc_ to [ToBoolean](#sec-9.2)(_enum_).\n4. If the result of calling the \\[\\[HasProperty\\]\\] internal method of _Obj_ with argument \"`configurable`\" is **true**, then  \n   1. Let _conf_ be the result of calling the \\[\\[Get\\]\\] internal method of _Obj_ with argument \"`configurable`\".  \n   2. Set the \\[\\[Configurable\\]\\] field of _desc_ to [ToBoolean](#sec-9.2)(_conf_).\n5. If the result of calling the \\[\\[HasProperty\\]\\] internal method of _Obj_ with argument \"`value`\" is**true**, then  \n   1. Let _value_ be the result of calling the \\[\\[Get\\]\\] internal method of _Obj_ with argument “`value`”.  \n   2. Set the \\[\\[Value\\]\\] field of _desc_ to _value_.\n6. If the result of calling the \\[\\[HasProperty\\]\\] internal method of _Obj_ with argument \"`writable`\" is**true**, then  \n   1. Let _writable_ be the result of calling the \\[\\[Get\\]\\] internal method of _Obj_ with argument \"`writable`\".  \n   2. Set the \\[\\[Writable\\]\\] field of _desc_ to [ToBoolean](#sec-9.2)(_writable_).\n7. If the result of calling the \\[\\[HasProperty\\]\\] internal method of _Obj_ with argument \"`get`\" is**true**, then  \n   1. Let _getter_ be the result of calling the \\[\\[Get\\]\\] internal method of _Obj_ with argument \"`get`\".  \n   2. If [IsCallable](#sec-9.11)(_getter_) is **false** and _getter_ is not **undefined**, then throw a **TypeError** exception.  \n   3. Set the \\[\\[Get\\]\\] field of _desc_ to _getter_.\n8. If the result of calling the \\[\\[HasProperty\\]\\] internal method of _Obj_ with argument \"`set`\" is**true**, then  \n   1. Let _setter_ be the result of calling the \\[\\[Get\\]\\] internal method of _Obj_ with argument \"`set`\".  \n   2. If [IsCallable](#sec-9.11)(_setter_) is **false** and _setter_ is not **undefined**, then throw a **TypeError** exception.  \n   3. Set the \\[\\[Set\\]\\] field of _desc_ to _setter_.\n9. If either _desc_.\\[\\[Get\\]\\] or _desc_.\\[\\[Set\\]\\] are present, then  \n   1. If either _desc_.\\[\\[Value\\]\\] or _desc_.\\[\\[Writable\\]\\] are present, then throw a **TypeError** exception.\n10. Return _desc_.\n\n# [8.11](#sec-8.11 \"link to this section\") The Lexical Environment and Environment Record Specification Types\n\nThe [Lexical Environment](#sec-10.2) and [Environment Record](#sec-10.2.1) types are used to explain the behaviour of name resolution in nested functions and blocks. These types and the operations upon them are defined in [Clause 10](#sec-10).\n\n# [8.12](#sec-8.12 \"link to this section\") Algorithms for Object Internal Methods\n\nIn the following algorithm descriptions, assume O is a native ECMAScript object, P is a String, Desc is a Property Description record, and Throw is a Boolean flag.\n\n# [8.12.1](#sec-8.12.1 \"link to this section\") \\[\\[GetOwnProperty\\]\\] (P)\n\nWhen the \\[\\[GetOwnProperty\\]\\] internal method of O is called with property name P, the following steps are taken:\n\n1. If _O_ doesn’t have an own property with name _P_, return **undefined**.\n2. Let _D_ be a newly created [Property Descriptor](#sec-8.10) with no fields.\n3. Let _X_ be _O_’s own property named _P_.\n4. If _X_ is a data property, then  \n   1. Set _D_.\\[\\[Value\\]\\] to the value of _X_’s \\[\\[Value\\]\\] attribute.  \n   2. Set _D_.\\[\\[Writable\\]\\] to the value of _X_’s \\[\\[Writable\\]\\] attribute\n5. Else _X_ is an accessor property, so  \n   1. Set _D_.\\[\\[Get\\]\\] to the value of _X_’s \\[\\[Get\\]\\] attribute.  \n   2. Set _D_.\\[\\[Set\\]\\] to the value of _X_’s \\[\\[Set\\]\\] attribute.\n6. Set _D_.\\[\\[Enumerable\\]\\] to the value of _X_’s \\[\\[Enumerable\\]\\] attribute.\n7. Set _D_.\\[\\[Configurable\\]\\] to the value of _X_’s \\[\\[Configurable\\]\\] attribute.\n8. Return _D_.\n\nHowever, if O is a String object it has a more elaborate \\[\\[GetOwnProperty\\]\\] internal method defined in [15.5.5.2](#sec-15.5.5.2).\n\n# [8.12.2](#sec-8.12.2 \"link to this section\") \\[\\[GetProperty\\]\\] (P)\n\nWhen the \\[\\[GetProperty\\]\\] internal method of O is called with property name P, the following steps are taken:\n\n1. Let _prop_ be the result of calling the \\[\\[GetOwnProperty\\]\\] internal method of _O_ with property name_P_.\n2. If _prop_ is not **undefined**, return _prop_.\n3. Let _proto_ be the value of the \\[\\[Prototype\\]\\] internal property of _O._\n4. If _proto_ is **null**, return **undefined**.\n5. Return the result of calling the \\[\\[GetProperty\\]\\] internal method of _proto_ with argument _P_.\n\n# [8.12.3](#sec-8.12.3 \"link to this section\") \\[\\[Get\\]\\] (P)\n\nWhen the \\[\\[Get\\]\\] internal method of O is called with property name P, the following steps are taken:\n\n1. Let _desc_ be the result of calling the \\[\\[GetProperty\\]\\] internal method of _O_ with property name_P_.\n2. If _desc_ is **undefined**, return **undefined**.\n3. If [IsDataDescriptor](#sec-8.10.2)(_desc_) is **true**, return _desc_.\\[\\[Value\\]\\].\n4. Otherwise, [IsAccessorDescriptor](#sec-8.10.1)(_desc_) must be true so, let _getter_ be_desc_.\\[\\[Get\\]\\].\n5. If _getter_ is **undefined**, return **undefined**.\n6. Return the result calling the \\[\\[Call\\]\\] internal method of _getter_ providing _O_ as the **this** value and providing no arguments.\n\n# [8.12.4](#sec-8.12.4 \"link to this section\") \\[\\[CanPut\\]\\] (P)\n\nWhen the \\[\\[CanPut\\]\\] internal method of O is called with property name P, the following steps are taken:\n\n1. Let _desc_ be the result of calling the \\[\\[GetOwnProperty\\]\\] internal method of _O_ with argument_P_.\n2. If _desc_ is not **undefined**, then  \n   1. If [IsAccessorDescriptor](#sec-8.10.1)(_desc_) is **true**, then  \n         1. If _desc_.\\[\\[Set\\]\\] is **undefined**, then return **false**.  \n         2. Else return **true**.  \n   2. Else, _desc_ must be a DataDescriptor so return the value of _desc_.\\[\\[Writable\\]\\].\n3. Let _proto_ be the \\[\\[Prototype\\]\\] internal property of _O_.\n4. If _proto_ is **null**, then return the value of the \\[\\[Extensible\\]\\] internal property of _O_.\n5. Let _inherited_ be the result of calling the \\[\\[GetProperty\\]\\] internal method of _proto_ with property name_P_.\n6. If _inherited_ is **undefined**, return the value of the \\[\\[Extensible\\]\\] internal property of _O_.\n7. If [IsAccessorDescriptor](#sec-8.10.1)(_inherited_) is **true**, then  \n   1. If _inherited_.\\[\\[Set\\]\\] is **undefined**, then return **false**.  \n   2. Else return **true**.\n8. Else, _inherited_ must be a DataDescriptor  \n   1. If the \\[\\[Extensible\\]\\] internal property of _O_ is **false**, return **false**.  \n   2. Else return the value of _inherited_.\\[\\[Writable\\]\\].\n\nHost objects may define additional constraints upon \\[\\[Put\\]\\] operations. If possible, host objects should not allow \\[\\[Put\\]\\] operations in situations where this definition of \\[\\[CanPut\\]\\] returns false.\n\n# [8.12.5](#sec-8.12.5 \"link to this section\") \\[\\[Put\\]\\] ( P, V, Throw )\n\nWhen the \\[\\[Put\\]\\] internal method of O is called with property P, value V, and Boolean flag Throw, the following steps are taken:\n\n1. If the result of calling the \\[\\[CanPut\\]\\] internal method of _O_ with argument _P_ is **false**, then  \n   1. If _Throw_ is **true**, then throw a **TypeError** exception.  \n   2. Else return.\n2. Let _ownDesc_ be the result of calling the \\[\\[GetOwnProperty\\]\\] internal method of _O_ with argument_P_.\n3. If [IsDataDescriptor](#sec-8.10.2)(_ownDesc_) is **true**, then  \n   1. Let _valueDesc_ be the [Property Descriptor](#sec-8.10) {\\[\\[Value\\]\\]: _V_}.  \n   2. Call the \\[\\[DefineOwnProperty\\]\\] internal method of _O_ passing _P_, _valueDesc_, and _Throw_ as arguments.  \n   3. Return.\n4. Let _desc_ be the result of calling the \\[\\[GetProperty\\]\\] internal method of _O_ with argument _P_. This may be either an own or inherited accessor property descriptor or an inherited data property descriptor.\n5. If [IsAccessorDescriptor](#sec-8.10.1)(_desc_) is **true**, then  \n   1. Let _setter_ be _desc_.\\[\\[Set\\]\\] which cannot be **undefined**.  \n   2. Call the \\[\\[Call\\]\\] internal method of _setter_ providing _O_ as the **this** value and providing_V_ as the sole argument.\n6. Else, create a named data property named _P_ on object _O_ as follows  \n   1. Let _newDesc_ be the [Property Descriptor](#sec-8.10)  \n   {\\[\\[Value\\]\\]: _V_, \\[\\[Writable\\]\\]:**true**, \\[\\[Enumerable\\]\\]: **true**, \\[\\[Configurable\\]\\]: **true**}.  \n   2. Call the \\[\\[DefineOwnProperty\\]\\] internal method of _O_ passing _P_, _newDesc_, and _Throw_ as arguments.\n7. Return.\n\n# [8.12.6](#sec-8.12.6 \"link to this section\") \\[\\[HasProperty\\]\\] (P)\n\nWhen the \\[\\[HasProperty\\]\\] internal method of O is called with property name P, the following steps are taken:\n\n1. Let _desc_ be the result of calling the \\[\\[GetProperty\\]\\] internal method of _O_ with property name_P_.\n2. If _desc_ is **undefined**, then return **false**.\n3. Else return **true**.\n\n# [8.12.7](#sec-8.12.7 \"link to this section\") \\[\\[Delete\\]\\] (P, Throw)\n\nWhen the \\[\\[Delete\\]\\] internal method of O is called with property name P and the Boolean flag Throw, the following steps are taken:\n\n1. Let _desc_ be the result of calling the \\[\\[GetOwnProperty\\]\\] internal method of _O_ with property name_P_.\n2. If _desc_ is **undefined**, then return **true**.\n3. If _desc_.\\[\\[Configurable\\]\\] is **true**, then  \n   1. Remove the own property with name _P_ from _O_.  \n   2. Return **true**.\n4. Else if _Throw_, then throw a **TypeError** exception.\n5. Return **false**.\n\n# [8.12.8](#sec-8.12.8 \"link to this section\") \\[\\[DefaultValue\\]\\] (hint)\n\nWhen the \\[\\[DefaultValue\\]\\] internal method of O is called with hint String, the following steps are taken:\n\n1. Let _toString_ be the result of calling the \\[\\[Get\\]\\] internal method of object _O_ with argument \"`toString`\".\n2. If [IsCallable](#sec-9.11)(_toString)_ is **true** then,  \n   1. Let _str_ be the result of calling the \\[\\[Call\\]\\] internal method of _toString_, with _O_ as the**this** value and an empty argument list.  \n   2. If _str_ is a primitive value, return _str_.\n3. Let _valueOf_ be the result of calling the \\[\\[Get\\]\\] internal method of object _O_ with argument \"`valueOf`\".\n4. If [IsCallable](#sec-9.11)(_valueOf)_ is **true** then,  \n   1. Let _val_ be the result of calling the \\[\\[Call\\]\\] internal method of _valueOf_, with _O_ as the this value and an empty argument list.  \n   2. If _val_ is a primitive value, return _val_.\n5. Throw a **TypeError** exception.\n\nWhen the \\[\\[DefaultValue\\]\\] internal method of O is called with hint Number, the following steps are taken:\n\n1. Let _valueOf_ be the result of calling the \\[\\[Get\\]\\] internal method of object _O_ with argument \"`valueOf`\".\n2. If [IsCallable](#sec-9.11)(_valueOf)_ is **true** then,  \n   1. Let _val_ be the result of calling the \\[\\[Call\\]\\] internal method of _valueOf_, with _O_ as the**this** value and an empty argument list.  \n   2. If _val_ is a primitive value, return _val_.\n3. Let _toString_ be the result of calling the \\[\\[Get\\]\\] internal method of object _O_ with argument \"`toString`\".\n4. If [IsCallable](#sec-9.11)(_toString)_ is **true** then,  \n   1. Let _str_ be the result of calling the \\[\\[Call\\]\\] internal method of _toString_, with _O_ as the this value and an empty argument list.  \n   2. If _str_ is a primitive value, return _str_.\n5. Throw a **TypeError** exception.\n\nWhen the \\[\\[DefaultValue\\]\\] internal method of O is called with no hint, then it behaves as if the hint were Number, unless O is a Date object ([see 15.9.6](#sec-15.9.6)), in which case it behaves as if the hint were String.\n\nThe above specification of \\[\\[DefaultValue\\]\\] for native objects can return only primitive values. If a host object implements its own \\[\\[DefaultValue\\]\\] internal method, it must ensure that its \\[\\[DefaultValue\\]\\] internal method can return only primitive values.\n\n# [8.12.9](#sec-8.12.9 \"link to this section\") \\[\\[DefineOwnProperty\\]\\] (P, Desc, Throw)\n\nIn the following algorithm, the term “Reject” means “If Throw is **true**, then throw a **TypeError** exception, otherwise return **false**”. The algorithm contains steps that test various fields of the [Property Descriptor](#sec-8.10) Desc for specific values. The fields that are tested in this manner need not actually exist in Desc. If a field is absent then its value is considered to be **false**.\n\nWhen the \\[\\[DefineOwnProperty\\]\\] internal method of O is called with property name P, property descriptor Desc, and Boolean flag Throw, the following steps are taken:\n\n1. Let _current_ be the result of calling the \\[\\[GetOwnProperty\\]\\] internal method of _O_ with property name_P_.\n2. Let _extensible_ be the value of the \\[\\[Extensible\\]\\] internal property of _O_.\n3. If _current_ is **undefined** and _extensible_ is **false**, then Reject.\n4. If _current_ is **undefined** and _extensible_ is **true**, then  \n   1. If [IsGenericDescriptor](#sec-8.10.3)(_Desc_) or [IsDataDescriptor](#sec-8.10.2)(_Desc_) is **true**, then  \n         1. Create an own data property named _P_ of object _O_ whose \\[\\[Value\\]\\], \\[\\[Writable\\]\\], \\[\\[Enumerable\\]\\] and \\[\\[Configurable\\]\\] attribute values are described by _Desc_. If the value of an attribute field of_Desc_ is absent, the attribute of the newly created property is set to its default value.  \n   2. Else, _Desc_ must be an accessor [Property Descriptor](#sec-8.10) so,  \n         1. Create an own accessor property named _P_ of object _O_ whose \\[\\[Get\\]\\], \\[\\[Set\\]\\], \\[\\[Enumerable\\]\\] and \\[\\[Configurable\\]\\] attribute values are described by _Desc_. If the value of an attribute field of_Desc_ is absent, the attribute of the newly created property is set to its default value.  \n   3. Return **true**.\n5. Return **true**, if every field in _Desc_ is absent.\n6. Return **true**, if every field in _Desc_ also occurs in _current_ and the value of every field in_Desc_ is the same value as the corresponding field in _current_ when compared using [the SameValue algorithm (9.12)](#sec-9.12).\n7. If the \\[\\[Configurable\\]\\] field of _current_ is **false** then  \n   1. Reject, if the \\[\\[Configurable\\]\\] field of _Desc_ is **true**.  \n   2. Reject, if the \\[\\[Enumerable\\]\\] field of _Desc_ is present and the \\[\\[Enumerable\\]\\] fields of _current_ and_Desc_ are the Boolean negation of each other.\n8. If [IsGenericDescriptor](#sec-8.10.3)(_Desc_) is **true**, then no further validation is required.\n9. Else, if [IsDataDescriptor](#sec-8.10.2)(_current_) and [IsDataDescriptor](#sec-8.10.2)(_Desc_) have different results, then  \n   1. Reject, if the \\[\\[Configurable\\]\\] field of _current_ is **false**.  \n   2. If [IsDataDescriptor](#sec-8.10.2)(_current_) is **true**, then  \n         1. Convert the property named _P_ of object _O_ from a data property to an accessor property. Preserve the existing values of the converted property’s \\[\\[Configurable\\]\\] and \\[\\[Enumerable\\]\\] attributes and set the rest of the property’s attributes to their default values.  \n   3. Else,  \n         1. Convert the property named _P_ of object _O_ from an accessor property to a data property. Preserve the existing values of the converted property’s \\[\\[Configurable\\]\\] and \\[\\[Enumerable\\]\\] attributes and set the rest of the property’s attributes to their default values.\n10. Else, if [IsDataDescriptor](#sec-8.10.2)(_current_) and [IsDataDescriptor](#sec-8.10.2)(_Desc_) are both **true**, then  \n   1. If the \\[\\[Configurable\\]\\] field of _current_ is **false**, then  \n         1. Reject, if the \\[\\[Writable\\]\\] field of _current_ is **false** and the \\[\\[Writable\\]\\] field of _Desc_ is **true**.  \n         2. If the \\[\\[Writable\\]\\] field of _current_ is **false**, then  \n                  1. Reject, if the \\[\\[Value\\]\\] field of _Desc_ is present and [SameValue](#sec-9.12)(_Desc_.\\[\\[Value\\]\\], _current_.\\[\\[Value\\]\\]) is **false**.  \n   2. else, the \\[\\[Configurable\\]\\] field of _current_ is **true**, so any change is acceptable.\n11. Else, [IsAccessorDescriptor](#sec-8.10.1)(_current_) and [IsAccessorDescriptor](#sec-8.10.1)(_Desc_) are both **true** so,  \n   1. If the \\[\\[Configurable\\]\\] field of _current_ is **false**, then  \n         1. Reject, if the \\[\\[Set\\]\\] field of _Desc_ is present and [SameValue](#sec-9.12)(_Desc_.\\[\\[Set\\]\\], _current_.\\[\\[Set\\]\\]) is **false**.  \n         2. Reject, if the \\[\\[Get\\]\\] field of _Desc_ is present and [SameValue](#sec-9.12)(_Desc_.\\[\\[Get\\]\\], _current_.\\[\\[Get\\]\\]) is **false**.\n12. For each attribute field of _Desc_ that is present, set the correspondingly named attribute of the property named_P_ of object _O_ to the value of the field.\n13. Return **true**.\n\nHowever, if O is an Array object, it has a more elaborate \\[\\[DefineOwnProperty\\]\\] internal method defined in [15.4.5.1](#sec-15.4.5.1).\n\nNOTE Step 10.b allows any field of Desc to be different from the corresponding field of current if current’s \\[\\[Configurable\\]\\] field is **true**. This even permits changing the \\[\\[Value\\]\\] of a property whose \\[\\[Writable\\]\\] attribute is **false**. This is allowed because a **true** \\[\\[Configurable\\]\\] attribute would permit an equivalent sequence of calls where \\[\\[Writable\\]\\] is first set to **true**, a new \\[\\[Value\\]\\] is set, and then \\[\\[Writable\\]\\] is set to **false**."}