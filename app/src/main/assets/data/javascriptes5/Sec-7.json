{"lang":"JavascriptES5","category":"","fullPath":"","title":"7 Lexical Conventions7.1 Unicode Format-Control Characters7.2 White Space7.3 Line Terminators7.4 Comments7.5 Tokens7.6 Identifier Names and Identifiers7.6.1 Reserved Words7.6.1.1 Keywords7.6.1.2 Future Reserved Words7.7 Punctuators7.8 Literals7.8.1 Null Literals7.8.2 Boolean Literals7.8.3 Numeric Literals7.8.4 String Literals7.8.5 Regular Expression Literals7.9 Automatic Semicolon Insertion7.9.1 Rules of Automatic Semicolon\n          Insertion7.9.2 Examples of Automatic Semicolon\n          Insertion","markdown":"# [7](#sec-7 \"link to this section\") Lexical Conventions\n\nThe source text of an ECMAScript program is first converted into a sequence of input elements, which are tokens, line terminators, comments, or white space. The source text is scanned from left to right, repeatedly taking the longest possible sequence of characters as the next input element.\n\nThere are two goal symbols for the lexical grammar. The InputElementDiv symbol is used in those syntactic grammar contexts where a leading division (`/`) or division-assignment (`/=`) operator is permitted. The InputElementRegExp symbol is used in other syntactic grammar contexts.\n\nNOTE There are no syntactic grammar contexts where both a leading division or division-assignment, and a leading RegularExpressionLiteral are permitted. This is not affected by [semicolon insertion (see 7.9)](#sec-7.9); in examples such as the following:\n\na = b  \n/hi/g.exec(c).map(d);\n\nwhere the first non-whitespace, non-comment character after a LineTerminator is slash (`/`) and the syntactic context allows division or division-assignment, no semicolon is inserted at the LineTerminator. That is, the above example is interpreted in the same way as:\n\na = b / hi / g.exec(c).map(d);\n\n## Syntax\n\nInputElementDiv ::\n\nWhiteSpace\n\nLineTerminator\n\nComment\n\nToken\n\nDivPunctuator\n\nInputElementRegExp ::\n\nWhiteSpace\n\nLineTerminator\n\nComment\n\nToken\n\nRegularExpressionLiteral\n\n# [7.1](#sec-7.1 \"link to this section\") Unicode Format-Control Characters\n\nThe Unicode format-control characters (i.e., the characters in category “Cf” in the Unicode Character Database such as left-to-right mark or right-to-left mark) are control codes used to control the formatting of a range of text in the absence of higher-level protocols for this (such as mark-up languages).\n\nIt is useful to allow format-control characters in source text to facilitate editing and display. All format control characters may be used within comments, and within string literals and regular expression literals.\n\n<ZWNJ> and <ZWJ> are format-control characters that are used to make necessary distinctions when forming words or phrases in certain languages. In ECMAScript source text, <ZWNJ> and<ZWJ> may also be used in an identifier after the first character.\n\n<BOM> is a format-control character used primarily at the start of a text to mark it as Unicode and to allow detection of the text's encoding and byte order. <BOM> characters intended for this purpose can sometimes also appear after the start of a text, for example as a result of concatenating files. <BOM> characters are treated as white space characters ([see 7.2](#sec-7.2)).\n\nThe special treatment of certain format-control characters outside of comments, string literals, and regular expression literals is summarised in Table 1.\n\nTable 1 — Format-Control Character Usage\n\n| **_Code Unit_** **_Value_** | Name                  | Formal Name | Usage            |\n| --------------------------- | --------------------- | ----------- | ---------------- |\n| \\\\u200C                     | Zero width non-joiner | <ZWNJ>      | _IdentifierPart_ |\n| \\\\u200D                     | Zero width joiner     | <ZWJ>       | _IdentifierPart_ |\n| \\\\uFEFF                     | Byte Order Mark       | <BOM>       | _Whitespace_     |\n\n# [7.2](#sec-7.2 \"link to this section\") White Space\n\nWhite space characters are used to improve source text readability and to separate tokens (indivisible lexical units) from each other, but are otherwise insignificant. White space characters may occur between any two tokens and at the start or end of input. White space characters may also occur within a StringLiteral or a RegularExpressionLiteral (where they are considered significant characters forming part of the literal value) or within a Comment, but cannot appear within any other kind of token.\n\nThe ECMAScript white space characters are listed in Table 2.\n\nTable 2 — Whitespace Characters\n\n| Code Unit Value             | Name                                                | Formal Name |\n| --------------------------- | --------------------------------------------------- | ----------- |\n| \\\\u0009                     | Tab                                                 | <TAB>       |\n| \\\\u000B                     | Vertical Tab                                        | <VT>        |\n| \\\\u000C                     | Form Feed                                           | <FF>        |\n| \\\\u0020                     | Space                                               | <SP>        |\n| \\\\u00A0                     | No-break space                                      | <NBSP>      |\n| \\\\uFEFF Other category “Zs” | Byte Order Mark Any other Unicode “space separator” | <BOM> <USP> |\n\nECMAScript implementations must recognise all of the white space characters defined in Unicode 3.0\\. Later editions of the Unicode Standard may define other white space characters. ECMAScript implementations may recognise white space characters from later editions of the Unicode Standard.\n\n## Syntax\n\nWhiteSpace ::\n\n<TAB>\n\n<VT>\n\n<FF>\n\n<SP>\n\n<NBSP>\n\n<BOM>\n\n<USP>\n\n# [7.3](#sec-7.3 \"link to this section\") Line Terminators\n\nLike white space characters, line terminator characters are used to improve source text readability and to separate tokens (indivisible lexical units) from each other. However, unlike white space characters, line terminators have some influence over the behaviour of the syntactic grammar. In general, line terminators may occur between any two tokens, but there are a few places where they are forbidden by the syntactic grammar. Line terminators also affect the process of [automatic semicolon insertion (7.9)](#sec-7.9). A line terminator cannot occur within any token except a StringLiteral. Line terminators may only occur within a StringLiteral token as part of a LineContinuation.\n\nA line terminator can occur within a MultiLineComment ([7.4](#sec-7.4)) but cannot occur within a SingleLineComment.\n\nLine terminators are included in the set of white space characters that are matched by the `\\s` class in regular expressions.\n\nThe ECMAScript line terminator characters are listed in Table 3.\n\nTable 3 — Line Terminator Characters\n\n| Code Unit Value | Name                | Formal Name |\n| --------------- | ------------------- | ----------- |\n| \\\\u000A         | Line Feed           | <LF>        |\n| \\\\u000D         | Carriage Return     | <CR>        |\n| \\\\u2028         | Line separator      | <LS>        |\n| \\\\u2029         | Paragraph separator | <PS>        |\n\nOnly the characters in Table 3 are treated as line terminators. Other new line or line breaking characters are treated as white space but not as line terminators. The character sequence <CR><LF> is commonly used as a line terminator. It should be considered a single character for the purpose of reporting line numbers.\n\n## Syntax\n\nLineTerminator ::\n\n<LF>\n\n<CR>\n\n<LS>\n\n<PS>\n\nLineTerminatorSequence ::\n\n<LF>\n\n<CR> \\[lookahead ∉ <LF> \\]\n\n<LS>\n\n<PS>\n\n<CR> <LF>\n\n# [7.4](#sec-7.4 \"link to this section\") Comments\n\nComments can be either single or multi-line. Multi-line comments cannot nest.\n\nBecause a single-line comment can contain any character except a LineTerminator character, and because of the general rule that a token is always as long as possible, a single-line comment always consists of all characters from the `//` marker to the end of the line. However, the LineTerminator at the end of the line is not considered to be part of the single-line comment; it is recognised separately by the lexical grammar and becomes part of the stream of input elements for the syntactic grammar. This point is very important, because it implies that the presence or absence of single-line comments does not affect the process of [automatic semicolon insertion (see 7.9)](#sec-7.9).\n\nComments behave like white space and are discarded except that, if a MultiLineComment contains a line terminator character, then the entire comment is considered to be a LineTerminator for purposes of parsing by the syntactic grammar.\n\n## Syntax\n\nComment ::\n\nMultiLineComment\n\nSingleLineComment\n\nMultiLineComment ::\n\n`/*` MultiLineCommentCharsopt `*/`\n\nMultiLineCommentChars ::\n\nMultiLineNotAsteriskChar MultiLineCommentCharsopt\n\n`*` PostAsteriskCommentCharsopt\n\nPostAsteriskCommentChars ::\n\nMultiLineNotForwardSlashOrAsteriskChar MultiLineCommentCharsopt\n\n`*` PostAsteriskCommentCharsopt\n\nMultiLineNotAsteriskChar ::\n\nSourceCharacter but not `*`\n\nMultiLineNotForwardSlashOrAsteriskChar ::\n\nSourceCharacter but not one of `/` or `*`\n\nSingleLineComment ::\n\n`//` SingleLineCommentCharsopt\n\nSingleLineCommentChars ::\n\nSingleLineCommentChar SingleLineCommentCharsopt\n\nSingleLineCommentChar ::\n\nSourceCharacter but not LineTerminator\n\n# [7.5](#sec-7.5 \"link to this section\") Tokens\n\n## Syntax\n\nToken ::\n\nIdentifierName\n\nPunctuator\n\nNumericLiteral\n\nStringLiteral\n\nNOTE The DivPunctuator and RegularExpressionLiteral productions define tokens, but are not included in the Token production.\n\n# [7.6](#sec-7.6 \"link to this section\") Identifier Names and Identifiers\n\nIdentifier Names are tokens that are interpreted according to the grammar given in the “Identifiers” section of chapter 5 of the Unicode standard, with some small modifications. An Identifier is an IdentifierName that is not a ReservedWord ([see 7.6.1](#sec-7.6.1)). The Unicode identifier grammar is based on both normative and informative character categories specified by the Unicode Standard. The characters in the specified categories in version 3.0 of the Unicode standard must be treated as in those categories by all conforming ECMAScript implementations.\n\nThis standard specifies specific character additions: The dollar sign (`$`) and the underscore (`_`) are permitted anywhere in an IdentifierName.\n\nUnicode escape sequences are also permitted in an IdentifierName, where they contribute a single character to the IdentifierName, as computed by the CV of the UnicodeEscapeSequence ([see 7.8.4](#sec-7.8.4)). The `\\` preceding the UnicodeEscapeSequence does not contribute a character to the IdentifierName. A UnicodeEscapeSequence cannot be used to put a character into an IdentifierName that would otherwise be illegal. In other words, if a `\\` UnicodeEscapeSequence sequence were replaced by its UnicodeEscapeSequence's CV, the result must still be a valid IdentifierName that has the exact same sequence of characters as the original IdentifierName. All interpretations of identifiers within this specification are based upon their actual characters regardless of whether or not an escape sequence was used to contribute any particular characters.\n\nTwo IdentifierName that are canonically equivalent according to the Unicode standard are _not_ equal unless they are represented by the exact same sequence of code units (in other words, conforming ECMAScript implementations are only required to do bitwise comparison on IdentifierName values). The intent is that the incoming source text has been converted to normalised form C before it reaches the compiler.\n\nECMAScript implementations may recognise identifier characters defined in later editions of the Unicode Standard. If portability is a concern, programmers should only employ identifier characters defined in Unicode 3.0.\n\n## Syntax\n\nIdentifier ::\n\nIdentifierName but not ReservedWord\n\nIdentifierName ::\n\nIdentifierStart\n\nIdentifierName IdentifierPart\n\nIdentifierStart ::\n\nUnicodeLetter\n\n`$`\n\n`_`\n\n`\\` UnicodeEscapeSequence\n\nIdentifierPart ::\n\nIdentifierStart\n\nUnicodeCombiningMark\n\nUnicodeDigit\n\nUnicodeConnectorPunctuation\n\n<ZWNJ>\n\n<ZWJ>\n\nUnicodeLetter ::\n\nany character in the Unicode categories “Uppercase letter (Lu)”, “Lowercase letter (Ll)”, “Titlecase letter (Lt)”, “Modifier letter (Lm)”, “Other letter (Lo)”, or “Letter number (Nl)”.\n\nUnicodeCombiningMark ::\n\nany character in the Unicode categories “Non-spacing mark (Mn)” or “Combining spacing mark (Mc)”\n\nUnicodeDigit ::\n\nany character in the Unicode category “Decimal number (Nd)”\n\nUnicodeConnectorPunctuation ::\n\nany character in the Unicode category “Connector punctuation (Pc)”\n\nThe definitions of the nonterminal UnicodeEscapeSequence is given in [7.8.4](#sec-7.8.4)\n\n# [7.6.1](#sec-7.6.1 \"link to this section\") Reserved Words\n\nA reserved word is an IdentifierName that cannot be used as an Identifier.\n\n## Syntax\n\nReservedWord ::\n\nKeyword\n\nFutureReservedWord\n\nNullLiteral\n\nBooleanLiteral\n\n# [7.6.1.1](#sec-7.6.1.1 \"link to this section\") Keywords\n\nThe following tokens are ECMAScript keywords and may not be used as Identifiers in ECMAScript programs.\n\n## Syntax\n\nKeyword :: one of\n\n| break    | do       | instanceof | typeof |\n| -------- | -------- | ---------- | ------ |\n| case     | else     | new        | var    |\n| catch    | finally  | return     | void   |\n| continue | for      | switch     | while  |\n| debugger | function | this       | with   |\n| default  | if       | throw      |        |\n| delete   | in       | try        |        |\n\n# [7.6.1.2](#sec-7.6.1.2 \"link to this section\") Future Reserved Words\n\nThe following words are used as keywords in proposed extensions and are therefore reserved to allow for the possibility of future adoption of those extensions.\n\n## Syntax\n\nFutureReservedWord :: one of\n\n| class | enum   | extends | super |\n| ----- | ------ | ------- | ----- |\n| const | export | import  |       |\n\nThe following tokens are also considered to be FutureReservedWords when they occur within [strict mode code (see 10.1.1)](#sec-10.1.1). The occurrence of any of these tokens within [strict mode code](#sec-10.1.1) in any context where the occurrence of a FutureReservedWord would produce an error must also produce an equivalent error:\n\n| implements | let     | private   | public | yield |\n| ---------- | ------- | --------- | ------ | ----- |\n| interface  | package | protected | static |       |\n\n# [7.7](#sec-7.7 \"link to this section\") Punctuators\n\n## Syntax\n\nPunctuator :: one of\n\n| {    | }     | (    | )    | \\[  | \\]  |\n| ---- | ----- | ---- | ---- | --- | --- |\n| .    | ;     | ,    | <    | \\>  | <=  |\n| \\>=  | \\==   | !=   | \\=== | !== |     |\n| +    | \\-    | \\*   | %    | ++  | \\-- |\n| <<   | \\>>   | \\>>> | &    | \\|  | ^   |\n| !    | \\~    | &&   | \\||  | ?   | :   |\n| \\=   | +=    | \\-=  | \\*=  | %=  | <<= |\n| \\>>= | \\>>>= | &=   | \\|=  | ^=  |     |\n\nDivPunctuator :: one of\n\n| / | /= |\n| - | -- |\n\n# [7.8](#sec-7.8 \"link to this section\") Literals\n\n## Syntax\n\nLiteral ::\n\nNullLiteral\n\nBooleanLiteral\n\nNumericLiteral\n\nStringLiteral\n\nRegularExpressionLiteral\n\n# [7.8.1](#sec-7.8.1 \"link to this section\") Null Literals\n\n## Syntax\n\nNullLiteral ::\n\n`null`\n\n## Semantics\n\nThe value of the null literal `null` is the sole value of the Null type, namely **null**.\n\n# [7.8.2](#sec-7.8.2 \"link to this section\") Boolean Literals\n\n## Syntax\n\nBooleanLiteral ::\n\n`true`\n\n`false`\n\n## Semantics\n\nThe value of the Boolean literal `true` is a value of the Boolean type, namely **true**.\n\nThe value of the Boolean literal `false` is a value of the Boolean type, namely **false**.\n\n# [7.8.3](#sec-7.8.3 \"link to this section\") Numeric Literals\n\n## Syntax\n\nNumericLiteral ::\n\nDecimalLiteral\n\nHexIntegerLiteral\n\nDecimalLiteral ::\n\nDecimalIntegerLiteral `.` DecimalDigitsopt ExponentPartopt\n\n`.` DecimalDigits ExponentPartopt\n\nDecimalIntegerLiteral ExponentPartopt\n\nDecimalIntegerLiteral ::\n\n`0`\n\nNonZeroDigit DecimalDigitsopt\n\nDecimalDigits ::\n\nDecimalDigit\n\nDecimalDigits DecimalDigit\n\nDecimalDigit :: one of\n\n`0` `1` `2` `3` `4` `5` `6` `7` `8` `9`\n\nNonZeroDigit :: one of\n\n`1` `2` `3` `4` `5` `6` `7` `8` `9`\n\nExponentPart ::\n\nExponentIndicator SignedInteger\n\nExponentIndicator :: one of\n\n`e` `E`\n\nSignedInteger ::\n\nDecimalDigits\n\n`+` DecimalDigits\n\n`-` DecimalDigits\n\nHexIntegerLiteral ::\n\n`0x` HexDigit\n\n`0X` HexDigit\n\nHexIntegerLiteral HexDigit\n\nHexDigit :: one of\n\n`0` `1` `2` `3` `4` `5` `6` `7` `8` `9` `a` `b` `c` `d` `e` `f` `A` `B` `C` `D` `E` `F`\n\nThe source character immediately following a NumericLiteral must not be an IdentifierStart or DecimalDigit.\n\nNOTE For example:\n\n3in\n\nis an error and not the two input elements `3` and `in`.\n\n## Semantics\n\nA numeric literal stands for a value of the Number type. This value is determined in two steps: first, a mathematical value (MV) is derived from the literal; second, this mathematical value is rounded as described below.\n\n* The MV of NumericLiteral :: DecimalLiteral is the MV of _DecimalLiteral_.\n* The MV of NumericLiteral :: HexIntegerLiteral is the MV of _HexIntegerLiteral_.\n* The MV of DecimalLiteral :: DecimalIntegerLiteral `.` is the MV of _DecimalIntegerLiteral_.\n* The MV of DecimalLiteral :: DecimalIntegerLiteral `.` DecimalDigits is the MV of _DecimalIntegerLiteral_ plus (the MV of _DecimalDigits_ times 10–_n_), where _n_ is the number of characters in _DecimalDigit_s.\n* The MV of DecimalLiteral :: DecimalIntegerLiteral `.` ExponentPart is the MV of _DecimalIntegerLiteral_ times 10_e_, where _e_ is the MV of _ExponentPart_.\n* The MV of DecimalLiteral :: DecimalIntegerLiteral `.` DecimalDigits ExponentPart is (the MV of _DecimalIntegerLiteral_ plus (the MV of _DecimalDigits_ times 10–_n_)) times 10_e_, where _n_ is the number of characters in_DecimalDigit_s and e is the MV of _ExponentPart_.\n* The MV of DecimalLiteral :: `.` DecimalDigits is the MV of _DecimalDigits_ times 10–_n_, where _n_ is the number of characters in _DecimalDigit_s.\n* The MV of DecimalLiteral :: `.` DecimalDigits ExponentPart is the MV of_DecimalDigits_ times 10_e_–_n_, where _n_ is the number of characters in_DecimalDigit_s and _e_ is the MV of _ExponentPart_.\n* The MV of DecimalLiteral :: DecimalIntegerLiteral is the MV of _DecimalIntegerLiteral_.\n* The MV of DecimalLiteral :: DecimalIntegerLiteral ExponentPart is the MV of_DecimalIntegerLiteral_ times 10_e_, where _e_ is the MV of _ExponentPart_.\n* The MV of DecimalIntegerLiteral :: `0` is 0.\n* The MV of DecimalIntegerLiteral :: NonZeroDigit is the MV of _NonZeroDigit._\n* The MV of DecimalIntegerLiteral :: NonZeroDigit DecimalDigits is (the MV of _NonZeroDigit_ times 10_n_) plus the MV of _DecimalDigits_, where _n_ is the number of characters in_DecimalDigits_.\n* The MV of DecimalDigits :: DecimalDigit is the MV of _DecimalDigit_.\n* The MV of DecimalDigits :: DecimalDigits DecimalDigit is (the MV of _DecimalDigits_ times 10) plus the MV of _DecimalDigit_.\n* The MV of ExponentPart :: ExponentIndicator SignedInteger is the MV of _SignedInteger_.\n* The MV of SignedInteger :: DecimalDigits is the MV of _DecimalDigits_.\n* The MV of SignedInteger :: `+` DecimalDigits is the MV of _DecimalDigits_.\n* The MV of SignedInteger :: `-` DecimalDigits is the negative of the MV of _DecimalDigits_.\n* The MV of DecimalDigit :: `0` or of HexDigit :: `0` is 0.\n* The MV of DecimalDigit :: `1` or of NonZeroDigit :: `1` or of HexDigit :: `1` is 1.\n* The MV of DecimalDigit :: `2` or of NonZeroDigit :: `2` or of HexDigit :: `2` is 2.\n* The MV of DecimalDigit :: `3` or of NonZeroDigit :: `3` or of HexDigit :: `3` is 3.\n* The MV of DecimalDigit :: `4` or of NonZeroDigit :: `4` or of HexDigit :: `4` is 4.\n* The MV of DecimalDigit :: `5` or of NonZeroDigit :: `5` or of HexDigit :: `5` is 5.\n* The MV of DecimalDigit :: `6` or of NonZeroDigit :: `6` or of HexDigit :: `6` is 6.\n* The MV of DecimalDigit :: `7` or of NonZeroDigit :: `7` or of HexDigit :: `7` is 7.\n* The MV of DecimalDigit :: `8` or of NonZeroDigit :: `8` or of HexDigit :: `8` is 8.\n* The MV of DecimalDigit :: `9` or of NonZeroDigit :: `9` or of HexDigit :: `9` is 9.\n* The MV of HexDigit :: `a` or of HexDigit :: `A` is 10.\n* The MV of HexDigit :: `b` or of HexDigit :: `B` is 11.\n* The MV of HexDigit :: `c` or of HexDigit :: `C` is 12.\n* The MV of HexDigit :: `d` or of HexDigit :: `D` is 13.\n* The MV of HexDigit :: `e` or of HexDigit :: `E` is 14.\n* The MV of HexDigit :: `f` or of HexDigit :: `F` is 15.\n* The MV of HexIntegerLiteral :: `0x` HexDigit is the MV of _HexDigit_.\n* The MV of HexIntegerLiteral :: `0X` HexDigit is the MV of _HexDigit_.\n* The MV of HexIntegerLiteral :: HexIntegerLiteral HexDigit is (the MV of _HexIntegerLiteral_ times 16) plus the MV of _HexDigit_.\n\nOnce the exact MV for a numeric literal has been determined, it is then rounded to a value of the Number type. If the MV is 0, then the rounded value is +0; otherwise, the rounded value must be the Number value for the MV (as specified in [8.5](#sec-8.5)), unless the literal is a DecimalLiteral and the literal has more than 20 significant digits, in which case the Number value may be either the Number value for the MV of a literal produced by replacing each significant digit after the 20th with a `0` digit or the Number value for the MV of a literal produced by replacing each significant digit after the 20th with a `0` digit and then incrementing the literal at the 20th significant digit position. A digit is _significant_ if it is not part of an ExponentPart and\n\n* it is not `0`; or\n* there is a nonzero digit to its left and there is a nonzero digit, not in the _ExponentPart_, to its right.\n\nA conforming implementation, when processing [strict mode code (see 10.1.1)](#sec-10.1.1), must not extend the syntax of NumericLiteral to include OctalIntegerLiteral as described in [B.1.1](#sec-B.1.1).\n\n# [7.8.4](#sec-7.8.4 \"link to this section\") String Literals\n\nA string literal is zero or more characters enclosed in single or double quotes. Each character may be represented by an escape sequence. All characters may appear literally in a string literal except for the closing quote character, backslash, carriage return, line separator, paragraph separator, and line feed. Any character may appear in the form of an escape sequence.\n\n## Syntax\n\nStringLiteral ::\n\n`\"` DoubleStringCharactersopt `\"`\n\n`'` SingleStringCharactersopt `'`\n\nDoubleStringCharacters ::\n\nDoubleStringCharacter DoubleStringCharactersopt\n\nSingleStringCharacters ::\n\nSingleStringCharacter SingleStringCharactersopt\n\nDoubleStringCharacter ::\n\nSourceCharacter but not one of `\"` or `\\` or LineTerminator\n\n`\\` EscapeSequence\n\nLineContinuation\n\nSingleStringCharacter ::\n\nSourceCharacter but not one of `'` or `\\` or LineTerminator\n\n`\\` EscapeSequence\n\nLineContinuation\n\nLineContinuation ::\n\n`\\` LineTerminatorSequence\n\nEscapeSequence ::\n\nCharacterEscapeSequence\n\n`0` \\[lookahead ∉ DecimalDigit\\]\n\nHexEscapeSequence\n\nUnicodeEscapeSequence\n\nCharacterEscapeSequence ::\n\nSingleEscapeCharacter\n\nNonEscapeCharacter\n\nSingleEscapeCharacter :: one of\n\n`'` `\"` `\\` `b` `f` `n` `r` `t` `v`\n\nNonEscapeCharacter ::\n\nSourceCharacter but not one of EscapeCharacter or LineTerminator\n\nEscapeCharacter ::\n\nSingleEscapeCharacter\n\nDecimalDigit\n\n`x`\n\n`u`\n\nHexEscapeSequence ::\n\n`x` HexDigit HexDigit\n\nUnicodeEscapeSequence ::\n\n`u` HexDigit HexDigit HexDigit HexDigit\n\nThe definition of the nonterminal HexDigit is given in [7.8.3](#sec-7.8.3). SourceCharacter is defined in [clause 6](#sec-6).\n\n## Semantics\n\nA string literal stands for a value of the String type. The String value (SV) of the literal is described in terms of character values (CV) contributed by the various parts of the string literal. As part of this process, some characters within the string literal are interpreted as having a mathematical value (MV), as described below or in [7.8.3](#sec-7.8.3).\n\n* The SV of StringLiteral :: `\"\"` is the empty character sequence.\n* The SV of StringLiteral :: `''` is the empty character sequence.\n* The SV of StringLiteral :: `\"` DoubleStringCharacters `\"` is the SV of_DoubleStringCharacters_.\n* The SV of StringLiteral :: `'` SingleStringCharacters `'` is the SV of_SingleStringCharacters_.\n* The SV of DoubleStringCharacters :: DoubleStringCharacter is a sequence of one character, the CV of_DoubleStringCharacter_.\n* The SV of DoubleStringCharacters :: DoubleStringCharacter DoubleStringCharacters is a sequence of the CV of_DoubleStringCharacter_ followed by all the characters in the SV of _DoubleStringCharacters_ in order.\n* The SV of SingleStringCharacters :: SingleStringCharacter is a sequence of one character, the CV of_SingleStringCharacter_.\n* The SV of SingleStringCharacters :: SingleStringCharacter SingleStringCharacters is a sequence of the CV of_SingleStringCharacter_ followed by all the characters in the SV of _SingleStringCharacters_ in order.\n* The SV of LineContinuation :: `\\` LineTerminatorSequence is the empty character sequence.\n* The CV of DoubleStringCharacter :: SourceCharacter but not one of `\"` or `\\` or LineTerminator is the _SourceCharacter_ character itself.\n* The CV of DoubleStringCharacter :: `\\` EscapeSequence is the CV of the _EscapeSequence_.\n* The CV of DoubleStringCharacter :: LineContinuation is the empty character sequence.\n* The CV of SingleStringCharacter :: SourceCharacter but not one of `'` or `\\` or LineTerminator is the _SourceCharacter_ character itself.\n* The CV of SingleStringCharacter :: `\\` EscapeSequence is the CV of the _EscapeSequence_.\n* The CV of SingleStringCharacter :: LineContinuation is the empty character sequence.\n* The CV of EscapeSequence :: CharacterEscapeSequence is the CV of the _CharacterEscapeSequence_.\n* The CV of EscapeSequence :: `0` \\[lookahead ∉ DecimalDigit\\] is a <NUL> character (Unicode value 0000).\n* The CV of EscapeSequence :: HexEscapeSequence is the CV of the _HexEscapeSequence_.\n* The CV of EscapeSequence :: UnicodeEscapeSequence is the CV of the _UnicodeEscapeSequence_.\n* The CV of CharacterEscapeSequence :: SingleEscapeCharacter is the character whose code unit value is determined by the_SingleEscapeCharacter_ according to Table 4:\n\nTable 4 — String Single Character Escape Sequences\n\n| Escape Sequence | Code Unit Value | Name                 | Symbol |\n| --------------- | --------------- | -------------------- | ------ |\n| \\\\b             | \\\\u0008         | backspace            | <BS>   |\n| \\\\t             | \\\\u0009         | horizontal tab       | <HT>   |\n| \\\\n             | \\\\u000A         | line feed (new line) | <LF>   |\n| \\\\v             | \\\\u000B         | vertical tab         | <VT>   |\n| \\\\f             | \\\\u000C         | form feed            | <FF>   |\n| \\\\r             | \\\\u000D         | carriage return      | <CR>   |\n| \\\\\"             | \\\\u0022         | double quote         | \"      |\n| \\\\'             | \\\\u0027         | single quote         | '      |\n| \\\\\\\\            | \\\\u005C         | backslash            | \\\\     |\n\n* The CV of CharacterEscapeSequence :: NonEscapeCharacter is the CV of the _NonEscapeCharacter_.\n* The CV of NonEscapeCharacter :: SourceCharacter but not one of EscapeCharacter or LineTerminator is the _SourceCharacter_ character itself.\n* The CV of HexEscapeSequence :: `x` HexDigit HexDigit is the character whose code unit value is (16 times the MV of the first _HexDigit_) plus the MV of the second _HexDigit_.\n* The CV of UnicodeEscapeSequence :: `u` HexDigit HexDigit HexDigit HexDigit is the character whose code unit value is (4096 times the MV of the first_HexDigit_) plus (256 times the MV of the second _HexDigit_) plus (16 times the MV of the third_HexDigit_) plus the MV of the fourth _HexDigit_.\n\nA conforming implementation, when processing [strict mode code (see 10.1.1)](#sec-10.1.1), may not extend the syntax of EscapeSequence to include OctalEscapeSequence as described in [B.1.2](#sec-B.1.2).\n\nNOTE A line terminator character cannot appear in a string literal, except as part of a LineContinuation to produce the empty character sequence. The correct way to cause a line terminator character to be part of the String value of a string literal is to use an escape sequence such as `\\n` or`\\u000A`.\n\n# [7.8.5](#sec-7.8.5 \"link to this section\") Regular Expression Literals\n\nA regular expression literal is an input element that is converted to a RegExp object ([see 15.10](#sec-15.10)) each time the literal is evaluated. Two regular expression literals in a program evaluate to regular expression objects that never compare as `===` to each other even if the two literals' contents are identical. A RegExp object may also be created at runtime by `new RegExp` ([see 15.10.4](#sec-15.10.4)) or calling the`RegExp` constructor as a function ([15.10.3](#sec-15.10.3)).\n\nThe productions below describe the syntax for a regular expression literal and are used by the input element scanner to find the end of the regular expression literal. The Strings of characters comprising the RegularExpressionBody and the RegularExpressionFlags are passed uninterpreted to the regular expression constructor, which interprets them according to its own, more stringent grammar. An implementation may extend the regular expression constructor's grammar, but it must not extend the RegularExpressionBody and RegularExpressionFlags productions or the productions used by these productions.\n\n## Syntax\n\nRegularExpressionLiteral ::\n\n`/` RegularExpressionBody `/` RegularExpressionFlags\n\nRegularExpressionBody ::\n\nRegularExpressionFirstChar RegularExpressionChars\n\nRegularExpressionChars ::\n\n\\[empty\\]\n\nRegularExpressionChars RegularExpressionChar\n\nRegularExpressionFirstChar ::\n\nRegularExpressionNonTerminator but not one of `*` or `\\` or `/` or `[`\n\nRegularExpressionBackslashSequence\n\nRegularExpressionClass\n\nRegularExpressionChar ::\n\nRegularExpressionNonTerminator but not one of `\\` or `/` or `[`\n\nRegularExpressionBackslashSequence\n\nRegularExpressionClass\n\nRegularExpressionBackslashSequence ::\n\n`\\` RegularExpressionNonTerminator\n\nRegularExpressionNonTerminator ::\n\nSourceCharacter but not LineTerminator\n\nRegularExpressionClass ::\n\n`[` RegularExpressionClassChars `]`\n\nRegularExpressionClassChars ::\n\n\\[empty\\]\n\nRegularExpressionClassChars RegularExpressionClassChar\n\nRegularExpressionClassChar ::\n\nRegularExpressionNonTerminator but not one of `]` or `\\`\n\nRegularExpressionBackslashSequence\n\nRegularExpressionFlags ::\n\n\\[empty\\]\n\nRegularExpressionFlags IdentifierPart\n\nNOTE Regular expression literals may not be empty; instead of representing an empty regular expression literal, the characters `//` start a single-line comment. To specify an empty regular expression, use: `/(?:)/`.\n\n## Semantics\n\nA regular expression literal evaluates to a value of the Object type that is an instance of the standard built-in constructor RegExp. This value is determined in two steps: first, the characters comprising the regular expression's RegularExpressionBody and RegularExpressionFlags production expansions are collected uninterpreted into two Strings Pattern and Flags, respectively. Then each time the literal is evaluated, a new object is created as if by the expression **new RegExp(**Pattern, Flags**)** where RegExp is the standard built-in constructor with that name. The newly constructed object becomes the value of the RegularExpressionLiteral. If the call to `new RegExp` would generate an error as specified in [15.10.4.1](#sec-15.10.4.1), the error must be treated as an early error ([Clause 16](#sec-16)).\n\n# [7.9](#sec-7.9 \"link to this section\") Automatic Semicolon Insertion\n\nCertain ECMAScript statements (empty statement, variable statement, expression statement,`do`\\-`while` statement, `continue` statement, `break` statement,`return` statement, and `throw` statement) must be terminated with semicolons. Such semicolons may always appear explicitly in the source text. For convenience, however, such semicolons may be omitted from the source text in certain situations. These situations are described by saying that semicolons are automatically inserted into the source code token stream in those situations.\n\n# [7.9.1](#sec-7.9.1 \"link to this section\") Rules of Automatic Semicolon Insertion\n\nThere are three basic rules of semicolon insertion:\n\n1. When, as the program is parsed from left to right, a token (called the _offending token_) is encountered that is not allowed by any production of the grammar, then a semicolon is automatically inserted before the offending token if one or more of the following conditions is true:  \n   * The offending token is separated from the previous token by at least one LineTerminator.  \n   * The offending token is `}`.\n2. When, as the program is parsed from left to right, the end of the input stream of tokens is encountered and the parser is unable to parse the input token stream as a single complete ECMAScript Program, then a semicolon is automatically inserted at the end of the input stream.\n3. When, as the program is parsed from left to right, a token is encountered that is allowed by some production of the grammar, but the production is a _restricted production_ and the token would be the first token for a terminal or nonterminal immediately following the annotation “\\[no_LineTerminator_ here\\]” within the restricted production (and therefore such a token is called a restricted token), and the restricted token is separated from the previous token by at least one LineTerminator, then a semicolon is automatically inserted before the restricted token.\n\nHowever, there is an additional overriding condition on the preceding rules: a semicolon is never inserted automatically if the semicolon would then be parsed as an empty statement or if that semicolon would become one of the two semicolons in the header of a `for` statement ([see 12.6.3](#sec-12.6.3)).\n\nNOTE The following are the only restricted productions in the grammar:\n\nPostfixExpression :\n\nLeftHandSideExpression \\[no LineTerminator here\\] `++`\n\nLeftHandSideExpression \\[no LineTerminator here\\] `--`\n\nContinueStatement :\n\n`continue` \\[no LineTerminator here\\] Identifier `;`\n\nBreakStatement :\n\n`break` \\[no LineTerminator here\\] Identifier `;`\n\nReturnStatement :\n\n`return` \\[no LineTerminator here\\] Expression `;`\n\nThrowStatement :\n\n`throw` \\[no LineTerminator here\\] Expression `;`\n\nThe practical effect of these restricted productions is as follows:\n\nWhen a `++` or `--` token is encountered where the parser would treat it as a postfix operator, and at least one LineTerminator occurred between the preceding token and the `++` or`--` token, then a semicolon is automatically inserted before the `++` or `--` token.\n\nWhen a `continue`, `break`, `return`, or `throw` token is encountered and aLineTerminator is encountered before the next token, a semicolon is automatically inserted after the`continue`, `break`, `return`, or `throw` token.\n\nThe resulting practical advice to ECMAScript programmers is:\n\nA postfix `++` or `--` operator should appear on the same line as its operand.\n\nAn Expression in a `return` or `throw` statement should start on the same line as the `return` or `throw` token.\n\nAn Identifier in a `break` or `continue` statement should be on the same line as the `break` or `continue` token.\n\n# [7.9.2](#sec-7.9.2 \"link to this section\") Examples of Automatic Semicolon Insertion\n\nThe source\n\n{ 1 2 } 3\n\nis not a valid sentence in the ECMAScript grammar, even with the automatic semicolon insertion rules. In contrast, the source\n\n{ 1  \n2 } 3\n\nis also not a valid ECMAScript sentence, but is transformed by automatic semicolon insertion into the following:\n\n{ 1  \n;2 ;} 3;\n\nwhich is a valid ECMAScript sentence.\n\nThe source\n\nfor (a; b  \n)\n\nis not a valid ECMAScript sentence and is not altered by automatic semicolon insertion because the semicolon is needed for the header of a `for` statement. Automatic semicolon insertion never inserts one of the two semicolons in the header of a `for` statement.\n\nThe source\n\nreturn  \na + b\n\nis transformed by automatic semicolon insertion into the following:\n\nreturn;  \na + b;\n\nNOTE The expression `a + b` is not treated as a value to be returned by the`return` statement, because a LineTerminator separates it from the token`return`.\n\nThe source\n\na = b  \n++c\n\nis transformed by automatic semicolon insertion into the following:\n\na = b;  \n++c;\n\nNOTE The token `++` is not treated as a postfix operator applying to the variable`b`, because a LineTerminator occurs between `b` and `++`.\n\nThe source\n\nif (a > b)  \nelse c = d\n\nis not a valid ECMAScript sentence and is not altered by automatic semicolon insertion before the `else` token, even though no production of the grammar applies at that point, because an automatically inserted semicolon would then be parsed as an empty statement.\n\nThe source\n\na = b + c  \n(d + e).print()\n\nis _not_ transformed by automatic semicolon insertion, because the parenthesised expression that begins the second line can be interpreted as an argument list for a function call:\n\na = b + c(d + e).print()\n\nIn the circumstance that an assignment statement must begin with a left parenthesis, it is a good idea for the programmer to provide an explicit semicolon at the end of the preceding statement rather than to rely on automatic semicolon insertion."}