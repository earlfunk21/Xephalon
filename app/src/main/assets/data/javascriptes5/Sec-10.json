{"lang":"JavascriptES5","category":"","fullPath":"","title":"10 Executable Code and Execution\n      Contexts10.1 Types of Executable Code10.1.1 Strict Mode Code10.2 Lexical Environments10.2.1 Environment Records10.2.1.1 Declarative Environment\n            Records10.2.1.1.1 HasBinding(N)10.2.1.1.2\n              CreateMutableBinding (N, D)10.2.1.1.3 SetMutableBinding\n              (N,V,S)10.2.1.1.4\n              GetBindingValue(N,S)10.2.1.1.5 DeleteBinding\n              (N)10.2.1.1.6\n              ImplicitThisValue()10.2.1.1.7\n              CreateImmutableBinding (N)10.2.1.1.8\n              InitializeImmutableBinding (N,V)10.2.1.2 Object Environment\n            Records10.2.1.2.1 HasBinding(N)10.2.1.2.2\n              CreateMutableBinding (N, D)10.2.1.2.3 SetMutableBinding\n              (N,V,S)10.2.1.2.4\n              GetBindingValue(N,S)10.2.1.2.5 DeleteBinding\n              (N)10.2.1.2.6\n              ImplicitThisValue()10.2.2 Lexical Environment\n          Operations10.2.2.1 GetIdentifierReference\n            (lex, name, strict)10.2.2.2\n            NewDeclarativeEnvironment (E)10.2.2.3 NewObjectEnvironment (O,\n            E)10.2.3 The Global Environment10.3 Execution Contexts10.3.1 Identifier Resolution10.4 Establishing an Execution\n        Context10.4.1 Entering Global Code10.4.1.1 Initial Global Execution\n            Context10.4.2 Entering Eval Code10.4.2.1 Strict Mode\n            Restrictions10.4.3 Entering Function Code10.5 Declaration Binding\n        Instantiation10.6 Arguments Object","markdown":"# [10](#sec-10 \"link to this section\") Executable Code and Execution Contexts\n\n# [10.1](#sec-10.1 \"link to this section\") Types of Executable Code\n\nThere are three types of ECMAScript executable code:\n\n* _Global code_ is source text that is treated as an ECMAScript _Program_. The global code of a particular_Program_ does not include any source text that is parsed as part of a _FunctionBody_.\n* _Eval code_ is the source text supplied to the built-in `eval` function. More precisely, if the parameter to the built-in `eval` function is a String, it is treated as an ECMAScript _Program_. The eval code for a particular invocation of `eval` is the global code portion of that _Program_.\n* _Function code_ is source text that is parsed as part of a _FunctionBody_. The _function code_ of a particular _FunctionBody_ does not include any source text that is parsed as part of a nested _FunctionBody_._Function code_ also denotes the source text supplied when using the built-in `Function` object as a constructor. More precisely, the last parameter provided to the `Function` constructor is converted to a String and treated as the _FunctionBody_. If more than one parameter is provided to the `Function` constructor, all parameters except the last one are converted to Strings and concatenated together, separated by commas. The resulting String is interpreted as the _FormalParameterList_ for the _FunctionBody_ defined by the last parameter. The function code for a particular instantiation of a `Function` does not include any source text that is parsed as part of a nested _FunctionBody_.\n\n# [10.1.1](#sec-10.1.1 \"link to this section\") Strict Mode Code\n\nAn ECMAScript Program syntactic unit may be processed using either unrestricted or strict mode syntax and semantics. When processed using strict mode the three types of ECMAScript code are referred to as strict global code, strict eval code, and strict function code. Code is interpreted as strict mode code in the following situations:\n\n* Global code is strict global code if it begins with a [Directive Prologue](#sec-14.1) that contains a [Use Strict Directive](#sec-14.1) ([see 14.1](#sec-14.1)).\n* Eval code is strict eval code if it begins with a [Directive Prologue](#sec-14.1) that contains a [Use Strict Directive](#sec-14.1) or if the call to eval is a [direct call (see 15.1.2.1.1) to the eval function](#sec-15.1.2.1.1) that is contained in strict mode code.\n* Function code that is part of a FunctionDeclaration, FunctionExpression, or accessor PropertyAssignment is strict function code if its FunctionDeclaration, FunctionExpression, or PropertyAssignment is contained in strict mode code or if the function code begins with a [Directive Prologue](#sec-14.1) that contains a [Use Strict Directive](#sec-14.1).\n* Function code that is supplied as the last argument to the built-in Function constructor is strict function code if the last argument is a String that when processed as a FunctionBody begins with a [Directive Prologue](#sec-14.1) that contains a [Use Strict Directive](#sec-14.1).\n\n# [10.2](#sec-10.2 \"link to this section\") Lexical Environments\n\nA _Lexical Environment_ is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. A Lexical Environment consists of an [Environment Record](#sec-10.2.1) and a possibly null reference to an _outer_ Lexical Environment. Usually a Lexical Environment is associated with some specific syntactic structure of ECMAScript code such as aFunctionDeclaration, a WithStatement, or a Catch clause of a TryStatement and a new Lexical Environment is created each time such code is evaluated.\n\nAn _[Environment Record](#sec-10.2.1)_ records the identifier bindings that are created within the scope of its associated Lexical Environment.\n\nThe outer environment reference is used to model the logical nesting of Lexical Environment values. The outer reference of a (inner) Lexical Environment is a reference to the Lexical Environment that logically surrounds the inner Lexical Environment. An outer Lexical Environment may, of course, have its own outer Lexical Environment. A Lexical Environment may serve as the outer environment for multiple inner Lexical Environments. For example, if a FunctionDeclaration contains two nested FunctionDeclarations then the Lexical Environments of each of the nested functions will have as their outer Lexical Environment the Lexical Environment of the current execution of the surrounding function.\n\nLexical Environments and [Environment Record](#sec-10.2.1) values are purely specification mechanisms and need not correspond to any specific artefact of an ECMAScript implementation. It is impossible for an ECMAScript program to directly access or manipulate such values.\n\n# [10.2.1](#sec-10.2.1 \"link to this section\") Environment Records\n\nThere are two kinds of Environment Record values used in this specification: _declarative environment records_ and_object environment records_. Declarative environment records are used to define the effect of ECMAScript language syntactic elements such as FunctionDeclarations, VariableDeclarations, andCatch clauses that directly associate identifier bindings with ECMAScript language values. Object environment records are used to define the effect of ECMAScript elements such as Program and WithStatement that associate identifier bindings with the properties of some object.\n\nFor specification purposes Environment Record values can be thought of as existing in a simple object-oriented hierarchy where Environment Record is an abstract class with two concrete subclasses, declarative environment record and object environment record. The abstract class includes the abstract specification methods defined in Table 17\\. These abstract methods have distinct concrete algorithms for each of the concrete subclasses.\n\nTable 17 — Abstract Methods of Environment Records\n\n| Method                     | Purpose                                                                                                                                                                                                                                                                                                                                                                |\n| -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| HasBinding(N)              | Determine if an environment record has a binding for an identifier. Return **true** if it does and **false** if it does not. The String value N is the text of the identifier.                                                                                                                                                                                         |\n| CreateMutableBinding(N, D) | Create a new mutable binding in an environment record. The String value N is the text of the bound name. If the optional Boolean argument D is **true** the binding is may be subsequently deleted.                                                                                                                                                                    |\n| SetMutableBinding(N,V, S)  | Set the value of an already existing mutable binding in an environment record. The String value N is the text of the bound name. V is the value for the binding and may be a value of any ECMAScript language type. S is a Boolean flag. If S is **true** and the binding cannot be set throw a **TypeError** exception. S is used to identify strict mode references. |\n| GetBindingValue(N,S)       | Returns the value of an already existing binding from an environment record. The String value N is the text of the bound name. S is used to identify strict mode references. If S is **true** and the binding does not exist or is uninitialised throw a **ReferenceError** exception.                                                                                 |\n| DeleteBinding(N)           | Delete a binding from an environment record. The String value N is the text of the bound name If a binding for N exists, remove the binding and return **true**. If the binding exists but cannot be removed return **false**. If the binding does not exist return **true**.                                                                                          |\n| ImplicitThisValue()        | Returns the value to use as the **this** value on calls to function objects that are obtained as binding values from this environment record.                                                                                                                                                                                                                          |\n\n# [10.2.1.1](#sec-10.2.1.1 \"link to this section\") Declarative Environment Records\n\nEach [declarative environment record](#sec-10.2.1) is associated with an ECMAScript program scope containing variable and/or function declarations. A [declarative environment record](#sec-10.2.1) binds the set of identifiers defined by the declarations contained within its scope.\n\nIn addition to the mutable bindings supported by all Environment Records, declarative environment records also provide for immutable bindings. An immutable binding is one where the association between an identifier and a value may not be modified once it has been established. Creation and initialisation of immutable binding are distinct steps so it is possible for such bindings to exist in either an initialised or uninitialised state. Declarative environment records support the methods listed in Table 18 in addition to the Environment Record abstract specification methods:\n\nTable 18 — Additional Methods of Declarative Environment Records\n\n| Method                          | Purpose                                                                                                                                                                                                                             |\n| ------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| CreateImmutableBinding(N)       | Create a new but uninitialised immutable binding in an environment record. The String value N is the text of the bound name.                                                                                                        |\n| InitializeImmutableBinding(N,V) | Set the value of an already existing but uninitialised immutable binding in an environment record. The String value N is the text of the bound name. V is the value for the binding and is a value of any ECMAScript language type. |\n\nThe behaviour of the concrete specification methods for Declarative Environment Records is defined by the following algorithms.\n\n# [10.2.1.1.1](#sec-10.2.1.1.1 \"link to this section\") HasBinding(N)\n\nThe concrete environment record method HasBinding for declarative environment records simply determines if the argument identifier is one of the identifiers bound by the record:\n\n1. Let _envRec_ be the [declarative environment record](#sec-10.2.1) for which the method was invoked.\n2. If _envRec_ has a binding for the name that is the value of _N_, return **true**.\n3. If it does not have such a binding, return **false**.\n\n# [10.2.1.1.2](#sec-10.2.1.1.2 \"link to this section\") CreateMutableBinding (N, D)\n\nThe concrete [Environment Record](#sec-10.2.1) method CreateMutableBinding for declarative environment records creates a new mutable binding for the name N that is initialised to the value **undefined**. A binding must not already exist in this [Environment Record](#sec-10.2.1) for N. If Boolean argument D is provided and has the value **true** the new binding is marked as being subject to deletion.\n\n1. Let _envRec_ be the [declarative environment record](#sec-10.2.1) for which the method was invoked.\n2. Assert: _envRec_ does not already have a binding for _N_.\n3. Create a mutable binding in _envRec_ for _N_ and set its bound value to **undefined**. If _D_ is true record that the newly created binding may be deleted by a subsequent DeleteBinding call.\n\n# [10.2.1.1.3](#sec-10.2.1.1.3 \"link to this section\") SetMutableBinding (N,V,S)\n\nThe concrete [Environment Record](#sec-10.2.1) method SetMutableBinding for declarative environment records attempts to change the bound value of the current binding of the identifier whose name is the value of the argument N to the value of argument V. A binding for N must already exist. If the binding is an immutable binding, a **TypeError** is thrown if S istrue.\n\n1. Let _envRec_ be the [declarative environment record](#sec-10.2.1) for which the method was invoked.\n2. Assert: _envRec_ must have a binding for _N_.\n3. If the binding for _N_ in _envRec_ is a mutable binding, change its bound value to _V_.\n4. Else this must be an attempt to change the value of an immutable binding so if _S_ if **true** throw a**TypeError** exception.\n\n# [10.2.1.1.4](#sec-10.2.1.1.4 \"link to this section\") GetBindingValue(N,S)\n\nThe concrete [Environment Record](#sec-10.2.1) method GetBindingValue for declarative environment records simply returns the value of its bound identifier whose name is the value of the argument N. The binding must already exist. If S is **true** and the binding is an uninitialised immutable binding throw a**ReferenceError** exception.\n\n1. Let _envRec_ be the [declarative environment record](#sec-10.2.1) for which the method was invoked.\n2. Assert: _envRec_ has a binding for _N_.\n3. If the binding for _N_ in _envRec_ is an uninitialised immutable binding, then  \n   1. If _S_ is **false**, return the value **undefined**, otherwise throw a **ReferenceError** exception.\n4. Else, return the value currently bound to _N_ in _envRec_.\n\n# [10.2.1.1.5](#sec-10.2.1.1.5 \"link to this section\") DeleteBinding (N)\n\nThe concrete [Environment Record](#sec-10.2.1) method DeleteBinding for declarative environment records can only delete bindings that have been explicitly designated as being subject to deletion.\n\n1. Let _envRec_ be the [declarative environment record](#sec-10.2.1) for which the method was invoked.\n2. If _envRec_ does not have a binding for the name that is the value of _N_, return **true**.\n3. If the binding for _N_ in _envRec_ is cannot be deleted, return **false**.\n4. Remove the binding for _N_ from _envRec_.\n5. Return **true**.\n\n# [10.2.1.1.6](#sec-10.2.1.1.6 \"link to this section\") ImplicitThisValue()\n\nDeclarative Environment Records always return **undefined** as their ImplicitThisValue.\n\n1. Return **undefined**.\n\n# [10.2.1.1.7](#sec-10.2.1.1.7 \"link to this section\") CreateImmutableBinding (N)\n\nThe concrete [Environment Record](#sec-10.2.1) method CreateImmutableBinding for declarative environment records creates a new immutable binding for the name N that is initialised to the value **undefined**. A binding must not already exist in this environment record for N.\n\n1. Let _envRec_ be the [declarative environment record](#sec-10.2.1) for which the method was invoked.\n2. Assert: _envRec_ does not already have a binding for _N_.\n3. Create an immutable binding in _envRec_ for _N_ and record that it is uninitialised.\n\n# [10.2.1.1.8](#sec-10.2.1.1.8 \"link to this section\") InitializeImmutableBinding (N,V)\n\nThe concrete [Environment Record](#sec-10.2.1) method InitializeImmutableBinding for declarative environment records is used to set the bound value of the current binding of the identifier whose name is the value of the argument N to the value of argument V. An uninitialised immutable binding for N must already exist.\n\n1. Let _envRec_ be the [declarative environment record](#sec-10.2.1) for which the method was invoked.\n2. Assert: _envRec_ must have an uninitialised immutable binding for N.\n3. Set the bound value for _N_ in _envRec_ to _V_.\n4. Record that the immutable binding for _N_ in _envRec_ has been initialised.\n\n# [10.2.1.2](#sec-10.2.1.2 \"link to this section\") Object Environment Records\n\nEach [object environment record](#sec-10.2.1) is associated with an object called its _binding object_. An [object environment record](#sec-10.2.1) binds the set of identifier names that directly correspond to the property names of its binding object. Property names that are not an IdentifierName are not included in the set of bound identifiers. Both own and inherited properties are included in the set regardless of the setting of their \\[\\[Enumerable\\]\\] attribute. Because properties can be dynamically added and deleted from objects, the set of identifiers bound by an [object environment record](#sec-10.2.1) may potentially change as a side-effect of any operation that adds or deletes properties. Any bindings that are created as a result of such a side-effect are considered to be a mutable binding even if the Writable attribute of the corresponding property has the value**false**. Immutable bindings do not exist for object environment records.\n\nObject environment records can be configured to provide their binding object as an implicit this value for use in function calls. This capability is used to specify the behaviour of With Statement ([12.10](#sec-12.10)) induced bindings. The capability is controlled by a provideThis Boolean value that is associated with each [object environment record](#sec-10.2.1). By default, the value of provideThis is **false** for any[object environment record](#sec-10.2.1).\n\nThe behaviour of the concrete specification methods for Object Environment Records is defined by the following algorithms.\n\n# [10.2.1.2.1](#sec-10.2.1.2.1 \"link to this section\") HasBinding(N)\n\nThe concrete [Environment Record](#sec-10.2.1) method HasBinding for object environment records determines if its associated binding object has a property whose name is the value of the argument N:\n\n1. Let _envRec_ be the [object environment record](#sec-10.2.1) for which the method was invoked.\n2. Let _bindings_ be the binding object for _envRec_.\n3. Return the result of calling the \\[\\[HasProperty\\]\\] internal method of _bindings_, passing _N_ as the property name.\n\n# [10.2.1.2.2](#sec-10.2.1.2.2 \"link to this section\") CreateMutableBinding (N, D)\n\nThe concrete [Environment Record](#sec-10.2.1) method CreateMutableBinding for object environment records creates in an environment record’s associated binding object a property whose name is the String value and initialises it to the value **undefined**. A property named N must not already exist in the binding object. If Boolean argument D is provided and has the value **true** the new property’s \\[\\[Configurable\\]\\] attribute is set to **true**, otherwise it is set to **false**.\n\n1. Let _envRec_ be the [object environment record](#sec-10.2.1) for which the method was invoked.\n2. Let _bindings_ be the binding object for _envRec_.\n3. Assert: The result of calling the \\[\\[HasProperty\\]\\] internal method of _bindings_, passing _N_ as the property name, is **false**.\n4. If D is **true** then let _configValue_ be **true** otherwise let _configValue_ be**false**.\n5. Call the \\[\\[DefineOwnProperty\\]\\] internal method of _bindings_, passing _N_, [Property Descriptor](#sec-8.10) {\\[\\[Value\\]\\]:**undefined**, \\[\\[Writable\\]\\]: **true**, \\[\\[Enumerable\\]\\]: **true** , \\[\\[Configurable\\]\\]: _configValue_}, and **true** as arguments.\n\n# [10.2.1.2.3](#sec-10.2.1.2.3 \"link to this section\") SetMutableBinding (N,V,S)\n\nThe concrete [Environment Record](#sec-10.2.1) method SetMutableBinding for object environment records attempts to set the value of the environment record’s associated binding object’s property whose name is the value of the argument N to the value of argument V. A property named N should already exist but if it does not or is not currently writable, error handling is determined by the value of the Boolean argumentS.\n\n1. Let _envRec_ be the [object environment record](#sec-10.2.1) for which the method was invoked.\n2. Let _bindings_ be the binding object for _envRec_.\n3. Call the \\[\\[Put\\]\\] internal method of _bindings_ with arguments _N_, _V_, and _S_.\n\n# [10.2.1.2.4](#sec-10.2.1.2.4 \"link to this section\") GetBindingValue(N,S)\n\nThe concrete [Environment Record](#sec-10.2.1) method GetBindingValue for object environment records returns the value of its associated binding object’s property whose name is the String value of the argument identifier N. The property should already exist but if it does not the result depends upon the value of theS argument:\n\n1. Let _envRec_ be the [object environment record](#sec-10.2.1) for which the method was invoked.\n2. Let _bindings_ be the binding object for _envRec_.\n3. Let _value_ be the result of calling the \\[\\[HasProperty\\]\\] internal method of _bindings_, passing _N_ as the property name.\n4. If _value_ is **false**, then  \n   1. If _S_ is **false**, return the value **undefined**, otherwise throw a **ReferenceError** exception.\n5. Return the result of calling the \\[\\[Get\\]\\] internal method of _bindings_, passing _N_ for the argument.\n\n# [10.2.1.2.5](#sec-10.2.1.2.5 \"link to this section\") DeleteBinding (N)\n\nThe concrete [Environment Record](#sec-10.2.1) method DeleteBinding for object environment records can only delete bindings that correspond to properties of the environment object whose \\[\\[Configurable\\]\\] attribute have the value **true**.\n\n1. Let _envRec_ be the [object environment record](#sec-10.2.1) for which the method was invoked.\n2. Let _bindings_ be the binding object for _envRec_.\n3. Return the result of calling the \\[\\[Delete\\]\\] internal method of _bindings_, passing _N_ and **false** as arguments.\n\n# [10.2.1.2.6](#sec-10.2.1.2.6 \"link to this section\") ImplicitThisValue()\n\nObject Environment Records return **undefined** as their ImplicitThisValue unless their provideThis flag is **true**.\n\n1. Let _envRec_ be the [object environment record](#sec-10.2.1) for which the method was invoked.\n2. If the _provideThis_ flag of _envRec_ is **true**, return the binding object for _envRec_.\n3. Otherwise, return **undefined**.\n\n# [10.2.2](#sec-10.2.2 \"link to this section\") Lexical Environment Operations\n\nThe following abstract operations are used in this specification to operate upon lexical environments:\n\n# [10.2.2.1](#sec-10.2.2.1 \"link to this section\") GetIdentifierReference (lex, name, strict)\n\nThe abstract operation GetIdentifierReference is called with a [Lexical Environment](#sec-10.2) lex, an identifier String name, and a Boolean flag strict. The value of lex may be **null**. When called, the following steps are performed:\n\n1. If _lex_ is the value **null**, then  \n   1. Return a value of type [Reference](#sec-8.7) whose base value is **undefined**, whose referenced name is _name_, and whose strict mode flag is _strict_.\n2. Let _envRec_ be _lex_’s environment record.\n3. Let _exists_ be the result of calling the HasBinding(_N_) concrete method of _envRec_ passing_name_ as the argument _N_.\n4. If _exists_ is `true`, then  \n   1. Return a value of type [Reference](#sec-8.7) whose base value is _envRec_, whose referenced name is _name_, and whose strict mode flag is _strict._\n5. Else  \n   1. Let _outer_ be the value of _lex’s_ [outer environment reference](#sec-10.2).  \n   2. Return the result of calling GetIdentifierReference passing _outer_, _name_, and _strict_ as arguments.\n\n# [10.2.2.2](#sec-10.2.2.2 \"link to this section\") NewDeclarativeEnvironment (E)\n\nWhen the abstract operation NewDeclarativeEnvironment is called with either a [Lexical Environment](#sec-10.2) or **null** as argument E the following steps are performed:\n\n1. Let _env_ be a new [Lexical Environment](#sec-10.2).\n2. Let _envRec_ be a new [declarative environment record](#sec-10.2.1) containing no bindings.\n3. Set _env’s_ environment record to be _envRec_.\n4. Set the [outer lexical environment reference](#sec-10.2) of _env_ to _E_.\n5. Return _env_.\n\n# [10.2.2.3](#sec-10.2.2.3 \"link to this section\") NewObjectEnvironment (O, E)\n\nWhen the abstract operation NewObjectEnvironment is called with an Object O and a [Lexical Environment](#sec-10.2) E (or **null)** as arguments, the following steps are performed:\n\n1. Let _env_ be a new [Lexical Environment](#sec-10.2).\n2. Let _envRec_ be a new [object environment record](#sec-10.2.1) containing _O_ as the binding object.\n3. Set _env’s_ environment record to be _envRec_.\n4. Set the [outer lexical environment reference](#sec-10.2) of _env_ to _E_.\n5. Return _env_.\n\n# [10.2.3](#sec-10.2.3 \"link to this section\") The Global Environment\n\nThe _global environment_ is a unique [Lexical Environment](#sec-10.2) which is created before any ECMAScript code is executed. The global environment’s [Environment Record](#sec-10.2.1) is an [object environment record](#sec-10.2.1) whose binding object is the global object ([15.1](#sec-15.1)). The global environment’s [outer environment reference](#sec-10.2) is **null**.\n\nAs ECMAScript code is executed, additional properties may be added to the global object and the initial properties may be modified.\n\n# [10.3](#sec-10.3 \"link to this section\") Execution Contexts\n\nWhen control is transferred to ECMAScript executable code, control is entering an _execution context_. Active execution contexts logically form a stack. The top execution context on this logical stack is the running execution context. A new execution context is created whenever control is transferred from the executable code associated with the currently running execution context to executable code that is not associated with that execution context. The newly created execution context is pushed onto the stack and becomes the running execution context.\n\nAn execution context contains whatever state is necessary to track the execution progress of its associated code. In addition, each execution context has the state components listed in Table 19.\n\nTable 19 —Execution Context State Components\n\n| Component           | Purpose                                                                                                                                                                       |\n| ------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| LexicalEnvironment  | Identifies the [Lexical Environment](#sec-10.2) used to resolve identifier references made by code within this execution context.                                             |\n| VariableEnvironment | Identifies the [Lexical Environment](#sec-10.2) whose environment record holds bindings created by VariableStatements and FunctionDeclarations within this execution context. |\n| ThisBinding         | The value associated with the this keyword within ECMAScript code associated with this execution context.                                                                     |\n\nThe LexicalEnvironment and VariableEnvironment components of an execution context are always Lexical Environments. When an execution context is created its LexicalEnvironment and VariableEnvironment components initially have the same value. The value of the VariableEnvironment component never changes while the value of the LexicalEnvironment component may change during execution of code within an execution context.\n\nIn most situations only the running execution context (the top of the execution context stack) is directly manipulated by algorithms within this specification. Hence when the terms “LexicalEnvironment”, “VariableEnvironment” and “ThisBinding” are used without qualification they are in reference to those components of the running execution context.\n\nAn execution context is purely a specification mechanism and need not correspond to any particular artefact of an ECMAScript implementation. It is impossible for an ECMAScript program to access an execution context.\n\n# [10.3.1](#sec-10.3.1 \"link to this section\") Identifier Resolution\n\nIdentifier resolution is the process of determining the binding of an Identifier using the [LexicalEnvironment](#sec-10.3) of the running execution context. During execution of ECMAScript code, the syntactic production PrimaryExpression : Identifier is evaluated using the following algorithm:\n\n1. Let _env_ be the running execution context’s [LexicalEnvironment](#sec-10.3).\n2. If the syntactic production that is being evaluated is contained in a [strict mode code](#sec-10.1.1), then let _strict_ be **true**, else let _strict_ be **false**.\n3. Return the result of calling [GetIdentifierReference](#sec-10.2.2.1) function passing _env_,_Identifier_, and _strict_ as arguments.\n\nThe result of evaluating an identifier is always a value of type [Reference](#sec-8.7) with its referenced name component equal to the Identifier String.\n\n# [10.4](#sec-10.4 \"link to this section\") Establishing an Execution Context\n\nEvaluation of global code or code using the eval function ([15.1.2.1](#sec-15.1.2.1)) establishes and enters a new execution context. Every invocation of an ECMAScript code function ([13.2.1](#sec-13.2.1)) also establishes and enters a new execution context, even if a function is calling itself recursively. Every return exits an execution context. A thrown exception may also exit one or more execution contexts.\n\nWhen control enters an execution context, the execution context’s [ThisBinding](#sec-10.3) is set, its [VariableEnvironment](#sec-10.3) and initial [LexicalEnvironment](#sec-10.3) are defined, and [declaration binding instantiation (10.5)](#sec-10.5) is performed. The exact manner in which these actions occur depend on the type of code being entered.\n\n# [10.4.1](#sec-10.4.1 \"link to this section\") Entering Global Code\n\nThe following steps are performed when control enters the execution context for global code:\n\n1. Initialise the execution context using the global code as described in [10.4.1.1](#sec-10.4.1.1).\n2. Perform [Declaration Binding Instantiation](#sec-10.5) as described in [10.5](#sec-10.5) using the global code.\n\n# [10.4.1.1](#sec-10.4.1.1 \"link to this section\") Initial Global Execution Context\n\nThe following steps are performed to initialise a global execution context for ECMAScript code C:\n\n1. Set the [VariableEnvironment](#sec-10.3) to [the Global Environment](#sec-10.2.3).\n2. Set the [LexicalEnvironment](#sec-10.3) to [the Global Environment](#sec-10.2.3).\n3. Set the [ThisBinding](#sec-10.3) to the global object.\n\n# [10.4.2](#sec-10.4.2 \"link to this section\") Entering Eval Code\n\nThe following steps are performed when control enters the execution context for eval code:\n\n1. If there is no calling context or if the eval code is not being evaluated by a direct call ([15.1.2.1.1](#sec-15.1.2.1.1)) to the eval function then,  \n   1. Initialise the execution context as if it was a global execution context using the eval code as _C_ as described in [10.4.1.1](#sec-10.4.1.1).\n2. Else,  \n   1. Set the [ThisBinding](#sec-10.3) to the same value as the [ThisBinding](#sec-10.3) of the calling execution context.  \n   2. Set the [LexicalEnvironment](#sec-10.3) to the same value as the [LexicalEnvironment](#sec-10.3) of the calling execution context.  \n   3. Set the [VariableEnvironment](#sec-10.3) to the same value as the [VariableEnvironment](#sec-10.3) of the calling execution context.\n3. If the eval code is [strict code](#sec-10.1.1), then  \n   1. Let _strictVarEnv_ be the result of calling [NewDeclarativeEnvironment](#sec-10.2.2.2) passing the [LexicalEnvironment](#sec-10.3) as the argument.  \n   2. Set the [LexicalEnvironment](#sec-10.3) to _strictVarEnv_.  \n   3. Set the [VariableEnvironment](#sec-10.3) to _strictVarEnv_.\n4. Perform [Declaration Binding Instantiation](#sec-10.5) as described in [10.5](#sec-10.5) using the eval code.\n\n# [10.4.2.1](#sec-10.4.2.1 \"link to this section\") Strict Mode Restrictions\n\nThe eval code cannot instantiate variable or function bindings in the variable environment of the calling context that invoked the eval if either the code of the calling context or the eval code is [strict code](#sec-10.1.1). Instead such bindings are instantiated in a new [VariableEnvironment](#sec-10.3) that is only accessible to the eval code.\n\n# [10.4.3](#sec-10.4.3 \"link to this section\") Entering Function Code\n\nThe following steps are performed when control enters the execution context for function code contained in function object F, a caller provided thisArg, and a caller provided argumentsList:\n\n1. If the function code is [strict code](#sec-10.1.1), set the [ThisBinding](#sec-10.3) to_thisArg_.\n2. Else if _thisArg_ is **null** or **undefined**, set the [ThisBinding](#sec-10.3) to the global object.\n3. Else if [Type](#sec-8)(_thisArg_) is not Object, set the [ThisBinding](#sec-10.3) to [ToObject](#sec-9.9)(_thisArg_).\n4. Else set the [ThisBinding](#sec-10.3) to _thisArg_.\n5. Let _localEnv_ be the result of calling [NewDeclarativeEnvironment](#sec-10.2.2.2) passing the value of the \\[\\[Scope\\]\\] internal property of _F_ as the argument.\n6. Set the [LexicalEnvironment](#sec-10.3) to _localEnv_.\n7. Set the [VariableEnvironment](#sec-10.3) to _localEnv_.\n8. Let _code_ be the value of _F_’s \\[\\[Code\\]\\] internal property.\n9. Perform [Declaration Binding Instantiation](#sec-10.5) using the function code _code_ and_argumentsList_ as described in [10.5](#sec-10.5).\n\n# [10.5](#sec-10.5 \"link to this section\") Declaration Binding Instantiation\n\nEvery execution context has an associated [VariableEnvironment](#sec-10.3). Variables and functions declared in ECMAScript code evaluated in an execution context are added as bindings in that [VariableEnvironment](#sec-10.3)’s [Environment Record](#sec-10.2.1). For function code, parameters are also added as bindings to that [Environment Record](#sec-10.2.1).\n\nWhich [Environment Record](#sec-10.2.1) is used to bind a declaration and its kind depends upon the type of ECMAScript code executed by the execution context, but the remainder of the behaviour is generic. On entering an execution context, bindings are created in the [VariableEnvironment](#sec-10.3) as follows using the caller providedcode and, if it is function code, argument [List](#sec-8.8) args:\n\n1. Let _env_ be the environment record component of the running execution context’s [VariableEnvironment](#sec-10.3).\n2. If _code_ is eval code, then let _configurableBindings_ be **true** else let _configurableBindings_ be**false**.\n3. If _code_ is [strict mode code](#sec-10.1.1), then let _strict_ be **true** else let_strict_ be **false**.\n4. If _code_ is function code, then  \n   1. Let _func_ be the function whose \\[\\[Call\\]\\] internal method initiated execution of _code_. Let _names_ be the value of _func_’s \\[\\[FormalParameters\\]\\] internal property.  \n   2. Let _argCount_ be the number of elements in _args_.  \n   3. Let _n_ be the number 0.  \n   4. For each String _argName_ in _names_, in list order do  \n         1. Let _n_ be the current value of _n_ plus 1.  \n         2. If _n_ is greater than _argCount_, let _v_ be **undefined** otherwise let _v_ be the value of the _n_’th element of _args_.  \n         3. Let _argAlreadyDeclared_ be the result of calling _env’s_ HasBinding concrete method passing_argName_ as the argument.  \n         4. If _argAlreadyDeclared_ is **false**, call _env’s_ CreateMutableBinding concrete method passing _argName_ as the argument.  \n         5. Call _env’s_ SetMutableBinding concrete method passing _argName_, _v_, and _strict_ as the arguments.\n5. For each _FunctionDeclaration_ _f_ in _code_, in source text order do  \n   1. Let _fn_ be the _Identifier_ in _FunctionDeclaration_ _f._  \n   2. Let _fo_ be the result of instantiating _FunctionDeclaration f_ as described in [Clause 13](#sec-13).  \n   3. Let _funcAlreadyDeclared_ be the result of calling _env’s_ HasBinding concrete method passing_fn_ as the argument.  \n   4. If _funcAlreadyDeclared_ is **false**, call _env’s_ CreateMutableBinding concrete method passing_fn_ and _configurableBindings_ as the arguments.  \n   5. Else if _env_ is the environment record component of [the global environment](#sec-10.2.3) then  \n         1. Let _go_ be the global object.  \n         2. Let _existingProp_ be the resulting of calling the \\[\\[GetProperty\\]\\] internal method of _go_ with argument _fn_.  \n         3. If _existingProp_ .\\[\\[Configurable\\]\\] is **true**, then  \n                  1. Call the \\[\\[DefineOwnProperty\\]\\] internal method of _go_, passing _fn_, [Property Descriptor](#sec-8.10) {\\[\\[Value\\]\\]: **undefined**, \\[\\[Writable\\]\\]: **true**, \\[\\[Enumerable\\]\\]: **true** , \\[\\[Configurable\\]\\]: _configurableBindings_ }, and **true** as arguments.  \n         4. Else if [IsAccessorDescriptor](#sec-8.10.1)(_existingProp_) or _existingProp_ does not have attribute values {\\[\\[Writable\\]\\]: **true**, \\[\\[Enumerable\\]\\]: **true**}, then  \n                  1. Throw a TypeError exception.  \n   6. Call _env’s_ SetMutableBinding concrete method passing _fn_, _fo_, and _strict_ as the arguments.\n6. Let _argumentsAlreadyDeclared_ be the result of calling _env’s_ HasBinding concrete method passing`\"arguments\"` as the argument.\n7. If _code_ is function code and _argumentsAlreadyDeclared_ is **false**, then  \n   1. Let _argsObj_ be the result of calling the abstract operation CreateArgumentsObject ([10.6](#sec-10.6)) passing _func, names, args,_ _env_ and _strict_ as arguments.  \n   2. If _strict_ is **true**, then  \n         1. Call _env_’s CreateImmutableBinding concrete method passing the String \"`arguments`\" as the argument.  \n         2. Call _env_’s InitializeImmutableBinding concrete method passing \"`arguments`\" and_argsObj_ as arguments.  \n   3. Else,  \n         1. Call _env_’s CreateMutableBinding concrete method passing the String \"`arguments`\" as the argument.  \n         2. Call _env_’s SetMutableBinding concrete method passing \"`arguments`\", _argsObj_, and**false** as arguments.\n8. For each _VariableDeclaration_ and _VariableDeclarationNoIn_ _d_ in _code_, in source text order do  \n   1. Let _dn_ be the _Identifier_ in _d._  \n   2. Let _varAlreadyDeclared_ be the result of calling _env’s_ HasBinding concrete method passing_dn_ as the argument.  \n   3. If _varAlreadyDeclared_ is **false**, then  \n         1. Call _env_’s CreateMutableBinding concrete method passing _dn_ and _configurableBindings_ as the arguments.  \n         2. Call _env_’s SetMutableBinding concrete method passing _dn_, **undefined**, and _strict_ as the arguments.\n\n# [10.6](#sec-10.6 \"link to this section\") Arguments Object\n\nWhen control enters an execution context for function code, an arguments object is created unless (as specified in [10.5](#sec-10.5)) the identifier `arguments` occurs as an Identifier in the function’s FormalParameterList or occurs as the Identifier of a VariableDeclaration or FunctionDeclaration contained in the function code.\n\nThe arguments object is created by calling the abstract operation CreateArgumentsObject with arguments func the function object whose code is to be evaluated, names a [List](#sec-8.8) containing the function’s formal parameter names, args the actual arguments passed to the \\[\\[Call\\]\\] internal method, env the variable environment for the function code, and strict a Boolean that indicates whether or not the function code is[strict code](#sec-10.1.1). When CreateArgumentsObject is called the following steps are performed:\n\n1. Let _len_ be the number of elements in _args_.\n2. Let _obj_ be the result of creating a new ECMAScript object.\n3. Set all the internal methods of _obj_ as specified in [8.12](#sec-8.12).\n4. Set the \\[\\[Class\\]\\] internal property of _obj_ to **\"Arguments**\".\n5. Let _Object_ be the standard built-in Object constructor ([15.2.2](#sec-15.2.2)).\n6. Set the \\[\\[Prototype\\]\\] internal property of _obj_ to the standard built-in Object prototype object ([15.2.4](#sec-15.2.4)).\n7. Call the \\[\\[DefineOwnProperty\\]\\] internal method on _obj_ passing **\"length\"**, the [Property Descriptor](#sec-8.10) {\\[\\[Value\\]\\]: _len_, \\[\\[Writable\\]\\]:**true**, \\[\\[Enumerable\\]\\]: **false**, \\[\\[Configurable\\]\\]: **true**}, and **false** as arguments.\n8. Let _map_ be the result of creating a new object as if by the expression `new Object()` where`Object` is the standard built-in constructor with that name\n9. Let _mappedNames_ be an empty [List](#sec-8.8).\n10. Let _indx_ \\= _len_ \\- 1.\n11. Repeat while _indx_ \\>= 0,  \n   1. Let _val_ be the element of _args_ at 0-origined list position _indx_.  \n   2. Call the \\[\\[DefineOwnProperty\\]\\] internal method on _obj_ passing [ToString](#sec-9.8)(_indx_), the property descriptor {\\[\\[Value\\]\\]: _val_, \\[\\[Writable\\]\\]: **true**, \\[\\[Enumerable\\]\\]: **true**, \\[\\[Configurable\\]\\]: **true**}, and **false** as arguments.  \n   3. If _indx_ is less than the number of elements in _names_, then  \n         1. Let _name_ be the element of _names_ at 0-origined list position _indx_.  \n         2. If _strict_ is **false** and _name_ is not an element of _mappedNames_, then  \n                  1. Add _name_ as an element of the list _mappedNames_.  \n                  2. Let _g_ be the result of calling the _MakeArgGetter_ abstract operation with arguments _name_ and _env_.  \n                  3. Let _p_ be the result of calling the _MakeArgSetter_ abstract operation with arguments _name_ and _env_.  \n                  4. Call the \\[\\[DefineOwnProperty\\]\\] internal method of _map_ passing [ToString](#sec-9.8)(_indx_), the [Property Descriptor](#sec-8.10) {\\[\\[Set\\]\\]:_p_, \\[\\[Get\\]\\]: _g,_ \\[\\[Configurable\\]\\]: **true**}, and **false** as arguments.  \n   4. Let _indx_ \\= _indx_ \\- 1\n12. If _mappedNames_ is not empty, then  \n   1. Set the \\[\\[ParameterMap\\]\\] internal property of _obj_ to _map_.  \n   2. Set the \\[\\[Get\\]\\], \\[\\[GetOwnProperty\\]\\], \\[\\[DefineOwnProperty\\]\\], and \\[\\[Delete\\]\\] internal methods of _obj_ to the definitions provided below.\n13. If _strict_ is **false**, then  \n   1. Call the \\[\\[DefineOwnProperty\\]\\] internal method on _obj_ passing \"`callee`\", the property descriptor {\\[\\[Value\\]\\]: _func_, \\[\\[Writable\\]\\]: **true**, \\[\\[Enumerable\\]\\]: **false**, \\[\\[Configurable\\]\\]: **true**}, and **false** as arguments.\n14. Else, _strict_ is **true** so  \n   1. Let _thrower_ be the \\[\\[ThrowTypeError\\]\\] function Object ([13.2.3](#sec-13.2.3)).  \n   2. Call the \\[\\[DefineOwnProperty\\]\\] internal method of _obj_ with arguments `\"caller\"`, PropertyDescriptor {\\[\\[Get\\]\\]: _thrower_, \\[\\[Set\\]\\]: _thrower_, \\[\\[Enumerable\\]\\]: **false**, \\[\\[Configurable\\]\\]: **false**}, and **false**.  \n   3. Call the \\[\\[DefineOwnProperty\\]\\] internal method of _obj_ with arguments `\"callee\"`, PropertyDescriptor {\\[\\[Get\\]\\]: _thrower_, \\[\\[Set\\]\\]: _thrower_, \\[\\[Enumerable\\]\\]: **false**, \\[\\[Configurable\\]\\]: **false**}, and **false**.\n15. Return _obj_\n\nThe abstract operation _MakeArgGetter_ called with String name and environment record env creates a function object that when executed returns the value bound for name in env. It performs the following steps:\n\n1. Let _body_ be the result of concatenating the Strings \"`return` \", _name_, and \"`;`\".\n2. Return the result of creating a function object as described in [13.2](#sec-13.2) using no_FormalParameterList_, _body_ for _FunctionBody_, _env_ as _Scope_, and **true** for_Strict_.\n\nThe abstract operation _MakeArgSetter_ called with String name and environment record env creates a function object that when executed sets the value bound for name in env. It performs the following steps:\n\n1. Let _param_ be the String _name_ concatenated with the String \"\\_arg\".\n2. Let _body_ be the String **\"<name> \\= <param>;\"** with **<name>** replaced by the value of _name_ and**<param>** replaced by the value of _param_.\n3. Return the result of creating a function object as described in [13.2](#sec-13.2) using a [List](#sec-8.8) containing the single String _param_ as _FormalParameterList_, _body_ for_FunctionBody_, _env_ as _Scope_, and **true** for _Strict_.\n\nThe \\[\\[Get\\]\\] internal method of an arguments object for a non-strict mode function with formal parameters when called with a property name P performs the following steps:\n\n1. Let _map_ be the value of the \\[\\[ParameterMap\\]\\] internal property of the arguments object.\n2. Let _isMapped_ be the result of calling the \\[\\[GetOwnProperty\\]\\] internal method of _map_ passing _P_ as the argument.\n3. If the value of _isMapped_ is **undefined**, then  \n   1. Let _v_ be the result of calling the default \\[\\[Get\\]\\] internal method ([8.12.3](#sec-8.12.3)) on the arguments object passing _P_ as the argument.  \n   2. If _P_ is `\"caller\"` and _v_ is a strict mode Function object, throw a **TypeError** exception.  \n   3. Return _v_.\n4. Else, _map_ contains a formal parameter mapping for _P_ so,  \n   1. Return the result of calling the \\[\\[Get\\]\\] internal method of _map_ passing _P_ as the argument.\n\nThe \\[\\[GetOwnProperty\\]\\] internal method of an arguments object for a non-strict mode function with formal parameters when called with a property name P performs the following steps:\n\n1. Let _desc_ be the result of calling the default \\[\\[GetOwnProperty\\]\\] internal method ([8.12.1](#sec-8.12.1)) on the arguments object passing _P_ as the argument.\n2. If _desc_ is **undefined** then return _desc_.\n3. Let _map_ be the value of the \\[\\[ParameterMap\\]\\] internal property of the arguments object.\n4. Let _isMapped_ be the result of calling the \\[\\[GetOwnProperty\\]\\] internal method of _map_ passing _P_ as the argument.\n5. If the value of _isMapped_ is not **undefined**, then  \n   1. Set _desc_.\\[\\[Value\\]\\] to the result of calling the \\[\\[Get\\]\\] internal method of _map_ passing _P_ as the argument.\n6. Return _desc_.\n\nThe \\[\\[DefineOwnProperty\\]\\] internal method of an arguments object for a non-strict mode function with formal parameters when called with a property name P, [Property Descriptor](#sec-8.10) Desc, and Boolean flag Throw performs the following steps:\n\n1. Let _map_ be the value of the \\[\\[ParameterMap\\]\\] internal property of the arguments object.\n2. Let _isMapped_ be the result of calling the \\[\\[GetOwnProperty\\]\\] internal method of _map_ passing _P_ as the argument.\n3. Let _allowed_ be the result of calling the default \\[\\[DefineOwnProperty\\]\\] internal method ([8.12.9](#sec-8.12.9)) on the arguments object passing _P_, _Desc_, and **false** as the arguments.\n4. If _allowed_ is **false**, then  \n   1. If _Throw_ is **true** then throw a **TypeError** exception, otherwise return **false**.\n5. If the value of _isMapped_ is not **undefined**, then  \n   1. If [IsAccessorDescriptor](#sec-8.10.1)(_Desc_) is **true**, then  \n         1. Call the \\[\\[Delete\\]\\] internal method of _map_ passing _P_, and **false** as the arguments.  \n   2. Else  \n         1. If _Desc_.\\[\\[Value\\]\\] is present, then  \n                  1. Call the \\[\\[Put\\]\\] internal method of _map_ passing _P_, _Desc_.\\[\\[Value\\]\\], and _Throw_ as the arguments.  \n         2. If _Desc_.\\[\\[Writable\\]\\] is present and its value is **false**, then  \n                  1. Call the \\[\\[Delete\\]\\] internal method of _map_ passing _P_ and **false** as arguments.\n6. Return **true**.\n\nThe \\[\\[Delete\\]\\] internal method of an arguments object for a non-strict mode function with formal parameters when called with a property name P and Boolean flag Throw performs the following steps:\n\n1. Let _map_ be the value of the \\[\\[ParameterMap\\]\\] internal property of the arguments object.\n2. Let _isMapped_ be the result of calling the \\[\\[GetOwnProperty\\]\\] internal method of _map_ passing _P_ as the argument.\n3. Let _result_ be the result of calling the default \\[\\[Delete\\]\\] internal method ([8.12.7](#sec-8.12.7)) on the arguments object passing _P_ and _Throw_ as the arguments.\n4. If _result_ is **true** and the value of _isMapped_ is not **undefined**, then  \n   1. Call the \\[\\[Delete\\]\\] internal method of _map_ passing _P_, and **false** as the arguments.\n5. Return _result_.\n\nNOTE 1 For non-strict mode functions the array index (defined in [15.4](#sec-15.4)) named data properties of an arguments object whose numeric name values are less than the number of formal parameters of the corresponding function object initially share their values with the corresponding argument bindings in the function’s execution context. This means that changing the property changes the corresponding value of the argument binding and vice-versa. This correspondence is broken if such a property is deleted and then redefined or if the property is changed into an accessor property. For strict mode functions, the values of the arguments object’s properties are simply a copy of the arguments passed to the function and there is no dynamic linkage between the property values and the formal parameter values.\n\nNOTE 2 The ParameterMap object and its property values are used as a device for specifying the arguments object correspondence to argument bindings. The ParameterMap object and the objects that are the values of its properties are not directly accessible from ECMAScript code. An ECMAScript implementation does not need to actually create or use such objects to implement the specified semantics.\n\nNOTE 3 Arguments objects for strict mode functions define non-configurable accessor properties named \"`caller`\" and \"`callee`\" which throw a **TypeError** exception on access. The \"`callee`\" property has a more specific meaning for non-strict mode functions and a \"`caller`\" property has historically been provided as an implementation-defined extension by some ECMAScript implementations. The strict mode definition of these properties exists to ensure that neither of them is defined in any other manner by conforming ECMAScript implementations."}