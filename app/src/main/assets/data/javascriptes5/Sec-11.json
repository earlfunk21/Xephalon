{"lang":"JavascriptES5","category":"","fullPath":"","title":"11 Expressions11.1 Primary Expressions11.1.1 The this Keyword11.1.2 Identifier Reference11.1.3 Literal Reference11.1.4 Array Initialiser11.1.5 Object Initialiser11.1.6 The Grouping Operator11.2 Left-Hand-Side Expressions11.2.1 Property Accessors11.2.2 The new Operator11.2.3 Function Calls11.2.4 Argument Lists11.2.5 Function Expressions11.3 Postfix Expressions11.3.1 Postfix Increment\n          Operator11.3.2 Postfix Decrement\n          Operator11.4 Unary Operators11.4.1 The delete Operator11.4.2 The void Operator11.4.3 The typeof Operator11.4.4 Prefix Increment Operator11.4.5 Prefix Decrement Operator11.4.6 Unary + Operator11.4.7 Unary - Operator11.4.8 Bitwise NOT Operator ( ~ )11.4.9 Logical NOT Operator ( ! )11.5 Multiplicative Operators11.5.1 Applying the * Operator11.5.2 Applying the / Operator11.5.3 Applying the % Operator11.6 Additive Operators11.6.1 The Addition operator ( + )11.6.2 The Subtraction Operator (\n          - )11.6.3 Applying the Additive\n          Operators to Numbers11.7 Bitwise Shift Operators11.7.1 The Left Shift Operator (\n          << )11.7.2 The Signed Right Shift\n          Operator ( >> )11.7.3 The Unsigned Right Shift\n          Operator ( >>> )11.8 Relational Operators11.8.1 The Less-than Operator ( < )11.8.2 The Greater-than Operator (\n          > )11.8.3 The Less-than-or-equal\n          Operator ( <= )11.8.4 The Greater-than-or-equal\n          Operator ( >= )11.8.5 The Abstract Relational\n          Comparison Algorithm11.8.6 The instanceof operator11.8.7 The in operator11.9 Equality Operators11.9.1 The Equals Operator ( == )11.9.2 The Does-not-equals Operator (\n          != )11.9.3 The Abstract Equality\n          Comparison Algorithm11.9.4 The Strict Equals Operator (\n          === )11.9.5 The Strict Does-not-equal\n          Operator ( !== )11.9.6 The Strict Equality Comparison\n          Algorithm11.10 Binary Bitwise Operators11.11 Binary Logical Operators11.12 Conditional Operator ( ? : )11.13 Assignment Operators11.13.1 Simple Assignment ( = )11.13.2 Compound Assignment ( op= )11.14 Comma Operator ( , )","markdown":"# [11](#sec-11 \"link to this section\") Expressions\n\n# [11.1](#sec-11.1 \"link to this section\") Primary Expressions\n\n## Syntax\n\nPrimaryExpression :\n\n`this`\n\nIdentifier\n\nLiteral\n\nArrayLiteral\n\nObjectLiteral\n\n`(` Expression `)`\n\n# [11.1.1](#sec-11.1.1 \"link to this section\") The this Keyword\n\nThe `this` keyword evaluates to the value of the [ThisBinding](#sec-10.3) of the current execution context.\n\n# [11.1.2](#sec-11.1.2 \"link to this section\") Identifier Reference\n\nAn Identifier is evaluated by performing [Identifier Resolution as specified in 10.3.1](#sec-10.3.1). The result of evaluating an Identifier is always a value of type [Reference](#sec-8.7).\n\n# [11.1.3](#sec-11.1.3 \"link to this section\") Literal Reference\n\nA Literal is evaluated as described in [7.8](#sec-7.8).\n\n# [11.1.4](#sec-11.1.4 \"link to this section\") Array Initialiser\n\nAn array initialiser is an expression describing the initialisation of an Array object, written in a form of a literal. It is a list of zero or more expressions, each of which represents an array element, enclosed in square brackets. The elements need not be literals; they are evaluated each time the array initialiser is evaluated.\n\nArray elements may be elided at the beginning, middle or end of the element list. Whenever a comma in the element list is not preceded by an AssignmentExpression (i.e., a comma at the beginning or after another comma), the missing array element contributes to the length of the Array and increases the index of subsequent elements. Elided array elements are not defined. If an element is elided at the end of an array, that element does not contribute to the length of the Array.\n\n## Syntax\n\nArrayLiteral :\n\n`[` Elisionopt `]`\n\n`[` ElementList `]`\n\n`[` ElementList `,` Elisionopt `]`\n\nElementList :\n\nElisionopt AssignmentExpression\n\nElementList `,` Elisionopt AssignmentExpression\n\nElision :\n\n`,`\n\nElision `,`\n\n## Semantics\n\nThe production ArrayLiteral : `[` Elisionopt `]` is evaluated as follows:\n\n1. Let _array_ be the result of creating a new object as if by the expression `new Array()` where`Array` is the standard built-in constructor with that name.\n2. Let _pad_ be the result of evaluating _Elision_; if not present, use the numeric value zero.\n3. Call the \\[\\[Put\\]\\] internal method of _array_ with arguments \"**length**\", _pad_, and **false**.\n4. Return _array_.\n\nThe production ArrayLiteral : `[` ElementList `]` is evaluated as follows:\n\n1. Return the result of evaluating _ElementList_.\n\nThe production ArrayLiteral : `[` ElementList `,` Elisionopt `]` is evaluated as follows:\n\n1. Let _array_ be the result of evaluating _ElementList_.\n2. Let _pad_ be the result of evaluating _Elision_; if not present, use the numeric value zero.\n3. Let _len_ be the result of calling the \\[\\[Get\\]\\] internal method of _array_ with argument \"**length**\".\n4. Call the \\[\\[Put\\]\\] internal method of _array_ with arguments \"**length**\", [ToUint32](#sec-9.6)(_pad_+_len_), and **false**.\n5. Return _array_.\n\nThe production ElementList : Elisionopt AssignmentExpression is evaluated as follows:\n\n1. Let _array_ be the result of creating a new object as if by the expression `new Array()` where`Array` is the standard built-in constructor with that name.\n2. Let _firstIndex_ be the result of evaluating _Elision_; if not present, use the numeric value zero.\n3. Let _initResult_ be the result of evaluating _AssignmentExpression_.\n4. Let _initValue_ be [GetValue](#sec-8.7.1)(_initResult_).\n5. Call the \\[\\[DefineOwnProperty\\]\\] internal method of _array_ with arguments [ToString](#sec-9.8)(_firstIndex)_, the [Property Descriptor](#sec-8.10) { \\[\\[Value\\]\\]:_initValue_, \\[\\[Writable\\]\\]: **true**, \\[\\[Enumerable\\]\\]: **true**, \\[\\[Configurable\\]\\]: **true**}, and**false**.\n6. Return _array_.\n\nThe production ElementList : ElementList `,` Elisionopt AssignmentExpression is evaluated as follows:\n\n1. Let _array_ be the result of evaluating _ElementList_.\n2. Let _pad_ be the result of evaluating _Elision_; if not present, use the numeric value zero.\n3. Let _initResult_ be the result of evaluating _AssignmentExpression_.\n4. Let _initValue_ be [GetValue](#sec-8.7.1)(_initResult_).\n5. Let _len_ be the result of calling the \\[\\[Get\\]\\] internal method of _array_ with argument \"**length**\".\n6. Call the \\[\\[DefineOwnProperty\\]\\] internal method of _array_ with arguments [ToString](#sec-9.8)([ToUint32](#sec-9.6)((_pad_+_len_)) and the [Property Descriptor](#sec-8.10) { \\[\\[Value\\]\\]:_initValue_, \\[\\[Writable\\]\\]: **true**, \\[\\[Enumerable\\]\\]: **true**, \\[\\[Configurable\\]\\]: **true**}, and**false**.\n7. Return _array_.\n\nThe production Elision : `,` is evaluated as follows:\n\n1. Return the numeric value 1.\n\nThe production Elision : Elision `,` is evaluated as follows:\n\n1. Let _preceding_ be the result of evaluating _Elision_.\n2. Return _preceding_+1.\n\nNOTE \\[\\[DefineOwnProperty\\]\\] is used to ensure that own properties are defined for the array even if the standard built-in Array prototype object has been modified in a manner that would preclude the creation of new own properties using \\[\\[Put\\]\\].\n\n# [11.1.5](#sec-11.1.5 \"link to this section\") Object Initialiser\n\nAn object initialiser is an expression describing the initialisation of an Object, written in a form resembling a literal. It is a list of zero or more pairs of property names and associated values, enclosed in curly braces. The values need not be literals; they are evaluated each time the object initialiser is evaluated.\n\n## Syntax\n\nObjectLiteral :\n\n`{` `}`\n\n`{` PropertyNameAndValueList `}`\n\n`{` PropertyNameAndValueList `,` `}`\n\nPropertyNameAndValueList :\n\nPropertyAssignment\n\nPropertyNameAndValueList `,` PropertyAssignment\n\nPropertyAssignment :\n\nPropertyName `:` AssignmentExpression\n\n`get` PropertyName `(` `)` `{` FunctionBody `}`\n\n`set` PropertyName `(` PropertySetParameterList `)` `{` FunctionBody `}`\n\nPropertyName :\n\nIdentifierName\n\nStringLiteral\n\nNumericLiteral\n\nPropertySetParameterList :\n\nIdentifier\n\n## Semantics\n\nThe production ObjectLiteral : `{` `}` is evaluated as follows:\n\n1. Return a new object created as if by the expression `new Object()` where `Object` is the standard built-in constructor with that name.\n\nThe productions ObjectLiteral : `{` PropertyNameAndValueList `}` and  \nObjectLiteral : `{` PropertyNameAndValueList ,**}** are evaluated as follows:\n\n1. Return the result of evaluating _PropertyNameAndValueList_.\n\nThe production PropertyNameAndValueList : PropertyAssignment is evaluated as follows:\n\n1. Let _obj_ be the result of creating a new object as if by the expression `new Object()` where`Object` is the standard built-in constructor with that name.\n2. Let _propId_ be the result of evaluating _PropertyAssignment_.\n3. Call the \\[\\[DefineOwnProperty\\]\\] internal method of _obj_ with arguments _propId_.name,_propId_.descriptor, and **false**.\n4. Return _obj_.\n\nThe production  \nPropertyNameAndValueList : PropertyNameAndValueList `,` PropertyAssignment  \nis evaluated as follows:\n\n1. Let _obj_ be the result of evaluating _PropertyNameAndValueList_.\n2. Let _propId_ be the result of evaluating _PropertyAssignment_.\n3. Let _previous_ be the result of calling the \\[\\[GetOwnProperty\\]\\] internal method of _obj_ with argument_propId_.name.\n4. If _previous_ is not **undefined** then throw a **SyntaxError** exception if any of the following conditions are true  \n   1. This production is contained in [strict code](#sec-10.1.1) and [IsDataDescriptor](#sec-8.10.2)(_previous_) is **true** and [IsDataDescriptor](#sec-8.10.2)(_propId_.descriptor) is **true**.  \n   2. [IsDataDescriptor](#sec-8.10.2)(_previous_) is **true** and [IsAccessorDescriptor](#sec-8.10.1)(_propId_.descriptor) is **true.**  \n   3. [IsAccessorDescriptor](#sec-8.10.1)(_previous_) is **true** and [IsDataDescriptor](#sec-8.10.2)(_propId_.descriptor) is **true**.  \n   4. [IsAccessorDescriptor](#sec-8.10.1)(_previous_) is **true** and [IsAccessorDescriptor](#sec-8.10.1)(_propId_.descriptor) is **true** and either both_previous_ and _propId_.descriptor have \\[\\[Get\\]\\] fields or both _previous_ and_propId_.descriptor have \\[\\[Set\\]\\] fields\n5. Call the \\[\\[DefineOwnProperty\\]\\] internal method of _obj_ with arguments _propId_.name,_propId_.descriptor, and **false**.\n6. Return _obj_.\n\nIf the above steps would throw a **SyntaxError** then an implementation must treat the error as an early error ([Clause 16](#sec-16)).\n\nThe production PropertyAssignment : PropertyName `:` AssignmentExpression is evaluated as follows:\n\n1. Let _propName_ be the result of evaluating _PropertyName_.\n2. Let _exprValue_ be the result of evaluating _AssignmentExpression_.\n3. Let _propValue_ be [GetValue](#sec-8.7.1)(_exprValue_).\n4. Let _desc_ be the [Property Descriptor](#sec-8.10){\\[\\[Value\\]\\]: _propValue_, \\[\\[Writable\\]\\]:**true**, \\[\\[Enumerable\\]\\]: **true**, \\[\\[Configurable\\]\\]: **true**}\n5. Return [Property Identifier](#sec-8.10) (_propName_, _desc_).\n\nThe production PropertyAssignment : `get` PropertyName `(` `)` `{` FunctionBody `}` is evaluated as follows:\n\n1. Let _propName_ be the result of evaluating _PropertyName_.\n2. Let _closure_ be the result of creating a new Function object as specified in [13.2](#sec-13.2) with an empty parameter list and body specified by _FunctionBody_. Pass in the [LexicalEnvironment](#sec-10.3) of the running execution context as the _Scope_. Pass in **true** as the _Strict_ flag if the _PropertyAssignment_ is contained in [strict code](#sec-10.1.1) or if its _FunctionBody_ is [strict code](#sec-10.1.1).\n3. Let _desc_ be the [Property Descriptor](#sec-8.10){\\[\\[Get\\]\\]: _closure_, \\[\\[Enumerable\\]\\]:**true**, \\[\\[Configurable\\]\\]: **true**}\n4. Return [Property Identifier](#sec-8.10) (_propName_, _desc_).\n\nThe production PropertyAssignment : `set` PropertyName `(` PropertySetParameterList `)` `{` FunctionBody `}` is evaluated as follows:\n\n1. Let _propName_ be the result of evaluating _PropertyName_.\n2. Let _closure_ be the result of creating a new Function object as specified in [13.2](#sec-13.2) with parameters specified by _PropertySetParameterList_ and body specified by _FunctionBody_. Pass in the [LexicalEnvironment](#sec-10.3) of the running execution context as the _Scope_. Pass in **true** as the _Strict_ flag if the _PropertyAssignment_ is contained in [strict code](#sec-10.1.1) or if its _FunctionBody_ is [strict code](#sec-10.1.1).\n3. Let _desc_ be the [Property Descriptor](#sec-8.10){\\[\\[Set\\]\\]: _closure_, \\[\\[Enumerable\\]\\]:**true**, \\[\\[Configurable\\]\\]: **true**}\n4. Return [Property Identifier](#sec-8.10) (_propName_, _desc_).\n\nIt is a **SyntaxError** if the Identifier `\"eval\"` or the Identifier `\"arguments\"` occurs as the Identifier in a PropertySetParameterList of a PropertyAssignment that is contained in [strict code](#sec-10.1.1) or if its _FunctionBody_ is [strict code](#sec-10.1.1).\n\nThe production PropertyName : IdentifierName is evaluated as follows:\n\n1. Return the String value containing the same sequence of characters as the _IdentifierName_.\n\nThe production PropertyName : StringLiteral is evaluated as follows:\n\n1. Return the SV of the _StringLiteral_.\n\nThe production PropertyName : NumericLiteral is evaluated as follows:\n\n1. Let _nbr_ be the result of forming the value of the _NumericLiteral_.\n2. Return [ToString](#sec-9.8)(_nbr_).\n\n# [11.1.6](#sec-11.1.6 \"link to this section\") The Grouping Operator\n\nThe production PrimaryExpression : `(` Expression `)` is evaluated as follows:\n\n1. Return the result of evaluating _Expression_. This may be of type [Reference](#sec-8.7).\n\nNOTE This algorithm does not apply [GetValue](#sec-8.7.1) to the result of evaluating Expression. The principal motivation for this is so that operators such as `delete` and`typeof` may be applied to parenthesised expressions.\n\n# [11.2](#sec-11.2 \"link to this section\") Left-Hand-Side Expressions\n\n## Syntax\n\nMemberExpression :\n\nPrimaryExpression\n\nFunctionExpression\n\nMemberExpression `[` Expression `]`\n\nMemberExpression `.` IdentifierName\n\n`new` MemberExpression Arguments\n\nNewExpression :\n\nMemberExpression\n\n`new` NewExpression\n\nCallExpression :\n\nMemberExpression Arguments\n\nCallExpression Arguments\n\nCallExpression `[` Expression `]`\n\nCallExpression `.` IdentifierName\n\nArguments :\n\n`(` `)`\n\n`(` ArgumentList `)`\n\nArgumentList :\n\nAssignmentExpression\n\nArgumentList `,` AssignmentExpression\n\nLeftHandSideExpression :\n\nNewExpression\n\nCallExpression\n\n# [11.2.1](#sec-11.2.1 \"link to this section\") Property Accessors\n\nProperties are accessed by name, using either the dot notation:\n\nMemberExpression `.` IdentifierName  \nCallExpression `.` IdentifierName\n\nor the bracket notation:\n\nMemberExpression `[` Expression `]`  \nCallExpression `[` Expression `]`\n\nThe dot notation is explained by the following syntactic conversion:\n\nMemberExpression `.` IdentifierName\n\nis identical in its behaviour to\n\nMemberExpression `[` <identifier-name-string> `]`\n\nand similarly\n\nCallExpression `.` IdentifierName\n\nis identical in its behaviour to\n\nCallExpression `[` <identifier-name-string> `]`\n\nwhere <identifier-name-string> is a string literal containing the same sequence of characters after processing of Unicode escape sequences as the IdentifierName.\n\nThe production MemberExpression : MemberExpression `[` Expression `]` is evaluated as follows:\n\n1. Let _baseReference_ be the result of evaluating _MemberExpression_.\n2. Let _baseValue_ be [GetValue](#sec-8.7.1)(_baseReference_).\n3. Let _propertyNameReference_ be the result of evaluating _Expression_.\n4. Let _propertyNameValue_ be [GetValue](#sec-8.7.1)(_propertyNameReference_).\n5. Call [CheckObjectCoercible](#sec-9.10)(_baseValue_).\n6. Let _propertyNameString_ be [ToString](#sec-9.8)(_propertyNameValue_).\n7. If the syntactic production that is being evaluated is contained in [strict mode code](#sec-10.1.1), let_strict_ be **true**, else let _strict_ be **false**.\n8. Return a value of type [Reference](#sec-8.7) whose base value is _baseValue_ and whose referenced name is _propertyNameString_, and whose strict mode flag is _strict_.\n\nThe production CallExpression : CallExpression `[` Expression `]` is evaluated in exactly the same manner, except that the contained CallExpression is evaluated in step 1.\n\n# [11.2.2](#sec-11.2.2 \"link to this section\") The new Operator\n\nThe production NewExpression : `new` NewExpression is evaluated as follows:\n\n1. Let _ref_ be the result of evaluating _NewExpression_.\n2. Let _constructor_ be [GetValue](#sec-8.7.1)(_ref_).\n3. If [Type](#sec-8)(_constructor_) is not Object, throw a **TypeError** exception.\n4. If _constructor_ does not implement the \\[\\[Construct\\]\\] internal method, throw a **TypeError** exception.\n5. Return the result of calling the \\[\\[Construct\\]\\] internal method on _constructor_, providing no arguments (that is, an empty list of arguments).\n\nThe production MemberExpression : `new` MemberExpression Arguments is evaluated as follows:\n\n1. Let _ref_ be the result of evaluating _MemberExpression_.\n2. Let _constructor_ be [GetValue](#sec-8.7.1)(_ref_).\n3. Let _argList_ be the result of evaluating _Arguments_, producing an internal list of argument values ([11.2.4](#sec-11.2.4)).\n4. If [Type](#sec-8)(_constructor_) is not Object, throw a **TypeError** exception.\n5. If _constructor_ does not implement the \\[\\[Construct\\]\\] internal method, throw a **TypeError** exception.\n6. Return the result of calling the \\[\\[Construct\\]\\] internal method on _constructor_, providing the list_argList_ as the argument values.\n\n# [11.2.3](#sec-11.2.3 \"link to this section\") Function Calls\n\nThe production CallExpression : MemberExpression Arguments is evaluated as follows:\n\n1. Let _ref_ be the result of evaluating _MemberExpression_.\n2. Let _func_ be [GetValue](#sec-8.7.1)(_ref_).\n3. Let _argList_ be the result of evaluating _Arguments_, producing an internal list of argument values ([see 11.2.4](#sec-11.2.4)).\n4. If [Type](#sec-8)(_func_) is not Object, throw a **TypeError** exception.\n5. If [IsCallable](#sec-9.11)(_func_) is **false**, throw a **TypeError** exception.\n6. If [Type](#sec-8)(_ref_) is [Reference](#sec-8.7), then  \n   1. If [IsPropertyReference](#sec-8.7)(_ref_) is **true**, then  \n         1. Let _thisValue_ be [GetBase](#sec-8.7)(_ref_).  \n   2. Else, the base of _ref_ is an [Environment Record](#sec-10.2.1)  \n         1. Let _thisValue_ be the result of calling the ImplicitThisValue concrete method of [GetBase](#sec-8.7)(_ref_).\n7. Else, [Type](#sec-8)(_ref_) is not [Reference](#sec-8.7).  \n   1. Let _thisValue_ be **undefined**.\n8. Return the result of calling the \\[\\[Call\\]\\] internal method on _func_, providing _thisValue_ as the**this** value and providing the list _argList_ as the argument values.\n\nThe production CallExpression : CallExpression Arguments is evaluated in exactly the same manner, except that the contained CallExpression is evaluated in step 1.\n\nNOTE The returned result will never be of type [Reference](#sec-8.7) iffunc is a native ECMAScript object. Whether calling a host object can return a value of type [Reference](#sec-8.7) is implementation-dependent. If a value of type [Reference](#sec-8.7) is returned, it must be a non-strict Property [Reference](#sec-8.7).\n\n# [11.2.4](#sec-11.2.4 \"link to this section\") Argument Lists\n\nThe evaluation of an argument list produces a [List](#sec-8.8) of values ([see 8.8](#sec-8.8)).\n\nThe production Arguments : `(` `)` is evaluated as follows:\n\n1. Return an empty [List](#sec-8.8).\n\nThe production Arguments : `(` ArgumentList `)` is evaluated as follows:\n\n1. Return the result of evaluating _ArgumentList_.\n\nThe production ArgumentList : AssignmentExpression is evaluated as follows:\n\n1. Let _ref_ be the result of evaluating _AssignmentExpression_.\n2. Let _arg_ be [GetValue](#sec-8.7.1)(_ref_).\n3. Return a [List](#sec-8.8) whose sole item is _arg_.\n\nThe production ArgumentList : ArgumentList `,` AssignmentExpression is evaluated as follows:\n\n1. Let _precedingArgs_ be the result of evaluating _ArgumentList_.\n2. Let _ref_ be the result of evaluating _AssignmentExpression_.\n3. Let _arg_ be [GetValue](#sec-8.7.1)(_ref_).\n4. Return a [List](#sec-8.8) whose length is one greater than the length of _precedingArgs_ and whose items are the items of _precedingArgs_, in order, followed at the end by _arg_ which is the last item of the new list.\n\n# [11.2.5](#sec-11.2.5 \"link to this section\") Function Expressions\n\nThe production MemberExpression : FunctionExpression is evaluated as follows:\n\n1. Return the result of evaluating _FunctionExpression_.\n\n# [11.3](#sec-11.3 \"link to this section\") Postfix Expressions\n\n## Syntax\n\nPostfixExpression :\n\nLeftHandSideExpression\n\nLeftHandSideExpression \\[no LineTerminator here\\] `++`\n\nLeftHandSideExpression \\[no LineTerminator here\\] `--`\n\n# [11.3.1](#sec-11.3.1 \"link to this section\") Postfix Increment Operator\n\nThe production PostfixExpression : LeftHandSideExpression \\[no _LineTerminator_ here\\] `++` is evaluated as follows:\n\n1. Let _lhs_ be the result of evaluating _LeftHandSideExpression_.\n2. Throw a **SyntaxError** exception if the following conditions are all true:  \n   * [Type](#sec-8)(_lhs_) is [Reference](#sec-8.7) is **true**  \n   * [IsStrictReference](#sec-8.7)(_lhs_) is **true**  \n   * [Type](#sec-8)([GetBase](#sec-8.7)(_lhs_)) is [Environment Record](#sec-10.2.1)  \n   * [GetReferencedName](#sec-8.7)(_lhs_) is either `\"eval\"` or `\"arguments\"`\n1. Let _oldValue_ be [ToNumber](#sec-9.3)([GetValue](#sec-8.7.1)(_lhs_)).\n2. Let _newValue_ be the result of adding the value `1` to _oldValue_, using the same rules as for the `+` operator ([see 11.6.3](#sec-11.6.3)).\n3. Call [PutValue](#sec-8.7.2)(_lhs_, _newValue_).\n4. Return _oldValue_.\n\n# [11.3.2](#sec-11.3.2 \"link to this section\") Postfix Decrement Operator\n\nThe production PostfixExpression : LeftHandSideExpression \\[no LineTerminator here\\] `--` is evaluated as follows:\n\n1. Let _lhs_ be the result of evaluating _LeftHandSideExpression_.\n2. Throw a **SyntaxError** exception if the following conditions are all true:  \n   * [Type](#sec-8)(_lhs_) is [Reference](#sec-8.7) is **true**  \n   * [IsStrictReference](#sec-8.7)(_lhs_) is **true**  \n   * [Type](#sec-8)([GetBase](#sec-8.7)(_lhs_)) is [Environment Record](#sec-10.2.1)  \n   * [GetReferencedName](#sec-8.7)(_lhs_) is either `\"eval\"` or `\"arguments\"`\n1. Let _oldValue_ be [ToNumber](#sec-9.3)([GetValue](#sec-8.7.1)(_lhs_)).\n2. Let _newValue_ be the result of subtracting the value `1` from _oldValue_, using the same rules as for the `-` operator ([11.6.3](#sec-11.6.3)).\n3. Call [PutValue](#sec-8.7.2)(_lhs_, _newValue_).\n4. Return _oldValue_.\n\n# [11.4](#sec-11.4 \"link to this section\") Unary Operators\n\n## Syntax\n\nUnaryExpression :\n\nPostfixExpression\n\n`delete` UnaryExpression\n\n`void` UnaryExpression\n\n`typeof` UnaryExpression\n\n`++` UnaryExpression\n\n`--` UnaryExpression\n\n`+` UnaryExpression\n\n`-` UnaryExpression\n\n`~` UnaryExpression\n\n`!` UnaryExpression\n\n# [11.4.1](#sec-11.4.1 \"link to this section\") The delete Operator\n\nThe production UnaryExpression : `delete` UnaryExpression is evaluated as follows:\n\n1. Let _ref_ be the result of evaluating _UnaryExpression_.\n2. If [Type](#sec-8)(_ref_) is not [Reference](#sec-8.7), return **true**.\n3. If [IsUnresolvableReference](#sec-8.7)(_ref_) then,  \n   1. If [IsStrictReference](#sec-8.7)(_ref_) is **true**, throw a **SyntaxError** exception.  \n   2. Else, return **true**.\n4. If [IsPropertyReference](#sec-8.7)(_ref_) is **true**, then  \n   1. Return the result of calling the \\[\\[Delete\\]\\] internal method on [ToObject](#sec-9.9)([GetBase](#sec-8.7)(_ref)_) providing [GetReferencedName](#sec-8.7)(_ref_) and [IsStrictReference](#sec-8.7)(_ref_) as the arguments.\n5. Else, _ref_ is a [Reference](#sec-8.7) to an [Environment Record](#sec-10.2.1) binding, so  \n   1. If [IsStrictReference](#sec-8.7)(_ref_) is **true**, throw a **SyntaxError** exception.  \n   2. Let _bindings_ be [GetBase](#sec-8.7)(_ref_).  \n   3. Return the result of calling the DeleteBinding concrete method of _bindings_, providing [GetReferencedName](#sec-8.7)(_ref_) as the argument.\n\nNOTE When a `delete` operator occurs within [strict mode code](#sec-10.1.1), a **SyntaxError** exception is thrown if its UnaryExpression is a direct reference to a variable, function argument, or function name. In addition, if a `delete` operator occurs within [strict mode code](#sec-10.1.1) and the property to be deleted has the attribute { \\[\\[Configurable\\]\\]: **false** }, a **TypeError** exception is thrown.\n\n# [11.4.2](#sec-11.4.2 \"link to this section\") The void Operator\n\nThe production UnaryExpression : `void` UnaryExpression is evaluated as follows:\n\n1. Let _expr_ be the result of evaluating _UnaryExpression_.\n2. Call [GetValue](#sec-8.7.1)(_expr_).\n3. Return **undefined**.\n\nNOTE [GetValue](#sec-8.7.1) must be called even though its value is not used because it may have observable side-effects.\n\n# [11.4.3](#sec-11.4.3 \"link to this section\") The typeof Operator\n\nThe production UnaryExpression : `typeof` UnaryExpression is evaluated as follows:\n\n1. Let _val_ be the result of evaluating _UnaryExpression_.\n2. If [Type](#sec-8)(_val_) is [Reference](#sec-8.7), then  \n   1. If [IsUnresolvableReference](#sec-8.7)(_val_) is **true**, return`\"undefined\"`.  \n   2. Let _val_ be [GetValue](#sec-8.7.1)(_val_).\n3. Return a String determined by [Type](#sec-8)(_val_) according to Table 20.\n\nTable 20 — typeof Operator Results\n\n| **Type of** val                                         | Result                                                                                  |\n| ------------------------------------------------------- | --------------------------------------------------------------------------------------- |\n| Undefined                                               | \"undefined\"                                                                             |\n| Null                                                    | \"object\"                                                                                |\n| Boolean                                                 | \"boolean\"                                                                               |\n| Number                                                  | \"number\"                                                                                |\n| String                                                  | \"string\"                                                                                |\n| Object (native and does not implement \\[\\[Call\\]\\])     | \"object\"                                                                                |\n| Object (native or host and does implement \\[\\[Call\\]\\]) | \"function\"                                                                              |\n| Object (host and does not implement \\[\\[Call\\]\\])       | Implementation-defined except may not be \"undefined\", \"boolean\", \"number\", or \"string\". |\n\n# [11.4.4](#sec-11.4.4 \"link to this section\") Prefix Increment Operator\n\nThe production UnaryExpression : `++` UnaryExpression is evaluated as follows:\n\n1. Let _expr_ be the result of evaluating UnaryExpression.\n2. Throw a **SyntaxError** exception if the following conditions are all true:  \n   * [Type](#sec-8)(_expr_) is [Reference](#sec-8.7) is **true**  \n   * [IsStrictReference](#sec-8.7)(_expr_) is **true**  \n   * [Type](#sec-8)([GetBase](#sec-8.7)(_expr_)) is [Environment Record](#sec-10.2.1)  \n   * [GetReferencedName](#sec-8.7)(_expr_) is either `\"eval\"` or `\"arguments\"`\n1. Let _oldValue_ be [ToNumber](#sec-9.3)([GetValue](#sec-8.7.1)(_expr_)).\n2. Let _newValue_ be the result of adding the value `1` to _oldValue_, using the same rules as for the `+` operator ([see 11.6.3](#sec-11.6.3)).\n3. Call [PutValue](#sec-8.7.2)(_expr_, _newValue_).\n4. Return _newValue_.\n\n# [11.4.5](#sec-11.4.5 \"link to this section\") Prefix Decrement Operator\n\nThe production UnaryExpression : `--` UnaryExpression is evaluated as follows:\n\n1. Let _expr_ be the result of evaluating UnaryExpression.\n2. Throw a **SyntaxError** exception if the following conditions are all true:  \n   * [Type](#sec-8)(_expr_) is [Reference](#sec-8.7) is **true**  \n   * [IsStrictReference](#sec-8.7)(_expr_) is **true**  \n   * [Type](#sec-8)([GetBase](#sec-8.7)(_expr_)) is [Environment Record](#sec-10.2.1)  \n   * [GetReferencedName](#sec-8.7)(_expr_) is either `\"eval\"` or `\"arguments\"`\n1. Let _oldValue_ be [ToNumber](#sec-9.3)([GetValue](#sec-8.7.1)(_expr_)).\n2. Let _newValue_ be the result of subtracting the value `1` from _oldValue_, using the same rules as for the `-` operator ([see 11.6.3](#sec-11.6.3)).\n3. Call [PutValue](#sec-8.7.2)(_expr_, _newValue_).\n4. Return _newValue_.\n\n# [11.4.6](#sec-11.4.6 \"link to this section\") Unary + Operator\n\nThe unary + operator converts its operand to Number type.\n\nThe production UnaryExpression : `+` UnaryExpression is evaluated as follows:\n\n1. Let _expr_ be the result of evaluating UnaryExpression.\n2. Return [ToNumber](#sec-9.3)([GetValue](#sec-8.7.1)(_expr_)).\n\n# [11.4.7](#sec-11.4.7 \"link to this section\") Unary \\- Operator\n\nThe unary `-` operator converts its operand to Number type and then negates it. Note that negating **+0** produces **−0**, and negating **−0** produces **+0**.\n\nThe production UnaryExpression : `-` UnaryExpression is evaluated as follows:\n\n1. Let _expr_ be the result of evaluating UnaryExpression.\n2. Let _oldValue_ be [ToNumber](#sec-9.3)([GetValue](#sec-8.7.1)(_expr_)).\n3. If _oldValue_ is **NaN**, return **NaN**.\n4. Return the result of negating _oldValue_; that is, compute a Number with the same magnitude but opposite sign.\n\n# [11.4.8](#sec-11.4.8 \"link to this section\") Bitwise NOT Operator ( \\~ )\n\nThe production UnaryExpression : `~` UnaryExpression is evaluated as follows:\n\n1. Let _expr_ be the result of evaluating _UnaryExpression_.\n2. Let _oldValue_ be [ToInt32](#sec-9.5)([GetValue](#sec-8.7.1)(_expr_)).\n3. Return the result of applying bitwise complement to _oldValue_. The result is a signed 32-bit integer.\n\n# [11.4.9](#sec-11.4.9 \"link to this section\") Logical NOT Operator ( ! )\n\nThe production UnaryExpression : `!` UnaryExpression is evaluated as follows:\n\n1. Let _expr_ be the result of evaluating _UnaryExpression_.\n2. Let _oldValue_ be [ToBoolean](#sec-9.2)([GetValue](#sec-8.7.1)(_expr_)).\n3. If _oldValue_ is **true**, return **false**.\n4. Return **true**.\n\n# [11.5](#sec-11.5 \"link to this section\") Multiplicative Operators\n\n## Syntax\n\nMultiplicativeExpression :\n\nUnaryExpression\n\nMultiplicativeExpression `*` UnaryExpression\n\nMultiplicativeExpression `/` UnaryExpression\n\nMultiplicativeExpression `%` UnaryExpression\n\n## Semantics\n\nThe production MultiplicativeExpression : MultiplicativeExpression `@` UnaryExpression , where @ stands for one of the operators in the above definitions, is evaluated as follows:\n\n1. Let _left_ be the result of evaluating MultiplicativeExpression.\n2. Let _leftValue_ be [GetValue](#sec-8.7.1)(_left_).\n3. Let _right_ be the result of evaluating UnaryExpression.\n4. Let _rightValue_ be [GetValue](#sec-8.7.1)(_right_).\n5. Let _leftNum_ be [ToNumber](#sec-9.3)(_leftValue_).\n6. Let _rightNum_ be [ToNumber](#sec-9.3)(_rightValue_).\n7. Return the result of applying the specified operation (\\*, /, or %) to _leftNum_ and _rightNum_. See the Notes below [11.5.1](#sec-11.5.1), [11.5.2](#sec-11.5.2), 11.5.3.\n\n# [11.5.1](#sec-11.5.1 \"link to this section\") Applying the \\* Operator\n\nThe `*` operator performs multiplication, producing the product of its operands. Multiplication is commutative. Multiplication is not always associative in ECMAScript, because of finite precision.\n\nThe result of a floating-point multiplication is governed by the rules of IEEE 754 binary double-precision arithmetic:\n\n* If either operand is **NaN**, the result is **NaN**.\n* The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.\n* Multiplication of an infinity by a zero results in **NaN**.\n* Multiplication of an infinity by an infinity results in an infinity. The sign is determined by the rule already stated above.\n* Multiplication of an infinity by a finite nonzero value results in a signed infinity. The sign is determined by the rule already stated above.\n* In the remaining cases, where neither an infinity or NaN is involved, the product is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent, the result is then an infinity of appropriate sign. If the magnitude is too small to represent, the result is then a zero of appropriate sign. The ECMAScript language requires support of gradual underflow as defined by IEEE 754.\n\n# [11.5.2](#sec-11.5.2 \"link to this section\") Applying the / Operator\n\nThe `/` operator performs division, producing the quotient of its operands. The left operand is the dividend and the right operand is the divisor. ECMAScript does not perform integer division. The operands and result of all division operations are double-precision floating-point numbers. The result of division is determined by the specification of IEEE 754 arithmetic:\n\n* If either operand is **NaN**, the result is **NaN**.\n* The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.\n* Division of an infinity by an infinity results in **NaN**.\n* Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated above.\n* Division of an infinity by a nonzero finite value results in a signed infinity. The sign is determined by the rule already stated above.\n* Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated above.\n* Division of a zero by a zero results in **NaN**; division of zero by any other finite value results in zero, with the sign determined by the rule already stated above.\n* Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule already stated above.\n* In the remaining cases, where neither an infinity, nor a zero, nor **NaN** is involved, the quotient is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent, the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent, the operation underflows and the result is a zero of the appropriate sign. The ECMAScript language requires support of gradual underflow as defined by IEEE 754.\n\n# [11.5.3](#sec-11.5.3 \"link to this section\") Applying the % Operator\n\nThe `%` operator yields the remainder of its operands from an implied division; the left operand is the dividend and the right operand is the divisor.\n\nNOTE In C and C++, the remainder operator accepts only integral operands; in ECMAScript, it also accepts floating-point operands.\n\nThe result of a floating-point remainder operation as computed by the `%` operator is not the same as the “remainder” operation defined by IEEE 754\\. The IEEE 754 “remainder” operation computes the remainder from a rounding division, not a truncating division, and so its behaviour is not analogous to that of the usual integer remainder operator. Instead the ECMAScript language defines `%` on floating-point operations to behave in a manner analogous to that of the Java integer remainder operator; this may be compared with the C library function fmod.\n\nThe result of an ECMAScript floating-point remainder operation is determined by the rules of IEEE arithmetic:\n\n* If either operand is **NaN**, the result is **NaN**.  \n   * The sign of the result equals the sign of the dividend.  \n   * If the dividend is an infinity, or the divisor is a zero, or both, the result is **NaN**.  \n   * If the dividend is finite and the divisor is an infinity, the result equals the dividend.  \n   * If the dividend is a zero and the divisor is nonzero and finite, the result is the same as the dividend.  \n   * In the remaining cases, where neither an infinity, nor a zero, nor **NaN** is involved, the floating-point remainder r from a dividend n and a divisor d is defined by the mathematical relation r = n − (d × q) where q is an integer that is negative only if n/d is negative and positive only if n/d is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of n and d. r is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode.\n\n# [11.6](#sec-11.6 \"link to this section\") Additive Operators\n\n## Syntax\n\nAdditiveExpression :\n\nMultiplicativeExpression\n\nAdditiveExpression `+` MultiplicativeExpression\n\nAdditiveExpression `-` MultiplicativeExpression\n\n# [11.6.1](#sec-11.6.1 \"link to this section\") The Addition operator ( + )\n\nThe addition operator either performs string concatenation or numeric addition.\n\nThe production AdditiveExpression : AdditiveExpression `+` MultiplicativeExpression is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating AdditiveExpression.\n2. Let _lval_ be [GetValue](#sec-8.7.1)(_lref_).\n3. Let _rref_ be the result of evaluating MultiplicativeExpression.\n4. Let _rval_ be [GetValue](#sec-8.7.1)(_rref_).\n5. Let _lprim_ be [ToPrimitive](#sec-9.1)(_lval_).\n6. Let _rprim_ be [ToPrimitive](#sec-9.1)(_rval_).\n7. If [Type](#sec-8)(_lprim_) is String or [Type](#sec-8)(_rprim_) is String, then  \n   1. Return the String that is the result of concatenating [ToString](#sec-9.8)(_lprim_) followed by [ToString](#sec-9.8)(_rprim_)\n8. Return the result of applying the addition operation to [ToNumber](#sec-9.3)(_lprim_) and [ToNumber](#sec-9.3)(_rprim_). See the Note below [11.6.3](#sec-11.6.3).\n\nNOTE 1 No hint is provided in the calls to [ToPrimitive](#sec-9.1) in steps 5 and 6\\. All native ECMAScript objects except Date objects handle the absence of a hint as if the hint Number were given; Date objects handle the absence of a hint as if the hint String were given. Host objects may handle the absence of a hint in some other manner.\n\nNOTE 2 Step 7 differs from step 3 of the comparison algorithm for the relational operators ([11.8.5](#sec-11.8.5)), by using the logical-or operation instead of the logical-and operation.\n\n# [11.6.2](#sec-11.6.2 \"link to this section\") The Subtraction Operator (\\- )\n\nThe production AdditiveExpression : AdditiveExpression `-` MultiplicativeExpression is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating AdditiveExpression.\n2. Let _lval_ be [GetValue](#sec-8.7.1)(_lref_).\n3. Let _rref_ be the result of evaluating MultiplicativeExpression.\n4. Let _rval_ be [GetValue](#sec-8.7.1)(_rref_).\n5. Let _lnum_ be [ToNumber](#sec-9.3)(_lval_).\n6. Let _rnum_ be [ToNumber](#sec-9.3)(_rval_).\n7. Return the result of applying the subtraction operation to _lnum_ and _rnum_. See the note below [11.6.3](#sec-11.6.3).\n\n# [11.6.3](#sec-11.6.3 \"link to this section\") Applying the Additive Operators to Numbers\n\nThe `+` operator performs addition when applied to two operands of numeric type, producing the sum of the operands. The `-` operator performs subtraction, producing the difference of two numeric operands.\n\nAddition is a commutative operation, but not always associative.\n\nThe result of an addition is determined using the rules of IEEE 754 binary double-precision arithmetic:\n\n* If either operand is **NaN**, the result is **NaN**.\n* The sum of two infinities of opposite sign is **NaN**.\n* The sum of two infinities of the same sign is the infinity of that sign.\n* The sum of an infinity and a finite value is equal to the infinite operand.\n* The sum of two negative zeroes is **−0**. The sum of two positive zeroes, or of two zeroes of opposite sign, is **+0**.\n* The sum of a zero and a nonzero finite value is equal to the nonzero operand.\n* The sum of two nonzero finite values of the same magnitude and opposite sign is **+0**.\n* In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, and the operands have the same sign or have different magnitudes, the sum is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent, the operation overflows and the result is then an infinity of appropriate sign. The ECMAScript language requires support of gradual underflow as defined by IEEE 754.\n\nThe `-` operator performs subtraction when applied to two operands of numeric type, producing the difference of its operands; the left operand is the minuend and the right operand is the subtrahend. Given numeric operandsa and b, it is always the case that _a–b_ produces the same result as _a +(–b)_.\n\n# [11.7](#sec-11.7 \"link to this section\") Bitwise Shift Operators\n\n## Syntax\n\nShiftExpression :\n\nAdditiveExpression\n\nShiftExpression `<<` AdditiveExpression\n\nShiftExpression `>>` AdditiveExpression\n\nShiftExpression `>>>` AdditiveExpression\n\n# [11.7.1](#sec-11.7.1 \"link to this section\") The Left Shift Operator (<< )\n\nPerforms a bitwise left shift operation on the left operand by the amount specified by the right operand.\n\nThe production ShiftExpression : ShiftExpression `<<` AdditiveExpression is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating _ShiftExpression_.\n2. Let _lval_ be [GetValue](#sec-8.7.1)(_lref_).\n3. Let _rref_ be the result of evaluating _AdditiveExpression_.\n4. Let _rval_ be [GetValue](#sec-8.7.1)(_rref_).\n5. Let _lnum_ be [ToInt32](#sec-9.5)(_lval_).\n6. Let _rnum_ be [ToUint32](#sec-9.6)(_rval_).\n7. Let _shiftCount_ be the result of masking out all but the least significant 5 bits of _rnum_, that is, compute _rnum_ & 0x1F.\n8. Return the result of left shifting _lnum_ by _shiftCount_ bits. The result is a signed 32-bit integer.\n\n# [11.7.2](#sec-11.7.2 \"link to this section\") The Signed Right Shift Operator ( \\>> )\n\nPerforms a sign-filling bitwise right shift operation on the left operand by the amount specified by the right operand.\n\nThe production ShiftExpression : ShiftExpression `>>` AdditiveExpression is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating _ShiftExpression_.\n2. Let _lval_ be [GetValue](#sec-8.7.1)(_lref_).\n3. Let _rref_ be the result of evaluating _AdditiveExpression_.\n4. Let _rval_ be [GetValue](#sec-8.7.1)(_rref_).\n5. Let _lnum_ be [ToInt32](#sec-9.5)(_lval_).\n6. Let _rnum_ be [ToUint32](#sec-9.6)(_rval_).\n7. Let _shiftCount_ be the result of masking out all but the least significant 5 bits of _rnum_, that is, compute _rnum_ & 0x1F.\n8. Return the result of performing a sign-extending right shift of _lnum_ by _shiftCount_ bits. The most significant bit is propagated. The result is a signed 32-bit integer.\n\n# [11.7.3](#sec-11.7.3 \"link to this section\") The Unsigned Right Shift Operator ( \\>>> )\n\nPerforms a zero-filling bitwise right shift operation on the left operand by the amount specified by the right operand.\n\nThe production ShiftExpression : ShiftExpression `>>>` AdditiveExpression is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating _ShiftExpression_.\n2. Let _lval_ be [GetValue](#sec-8.7.1)(_lref_).\n3. Let _rref_ be the result of evaluating _AdditiveExpression_.\n4. Let _rval_ be [GetValue](#sec-8.7.1)(_rref_).\n5. Let _lnum_ be [ToUint32](#sec-9.6)(_lval_).\n6. Let _rnum_ be [ToUint32](#sec-9.6)(_rval_).\n7. Let _shiftCount_ be the result of masking out all but the least significant 5 bits of _rnum_, that is, compute _rnum_ & 0x1F.\n8. Return the result of performing a zero-filling right shift of _lnum_ by _shiftCount_ bits. Vacated bits are filled with zero. The result is an unsigned 32-bit integer.\n\n# [11.8](#sec-11.8 \"link to this section\") Relational Operators\n\n## Syntax\n\nRelationalExpression :\n\nShiftExpression\n\nRelationalExpression `<` ShiftExpression\n\nRelationalExpression `>` ShiftExpression\n\nRelationalExpression `<=` ShiftExpression\n\nRelationalExpression `>=` ShiftExpression\n\nRelationalExpression `instanceof` ShiftExpression\n\nRelationalExpression `in` ShiftExpression\n\nRelationalExpressionNoIn :\n\nShiftExpression\n\nRelationalExpressionNoIn `<` ShiftExpression\n\nRelationalExpressionNoIn `>` ShiftExpression\n\nRelationalExpressionNoIn `<=` ShiftExpression\n\nRelationalExpressionNoIn `>=` ShiftExpression\n\nRelationalExpressionNoIn `instanceof` ShiftExpression\n\nNOTE The “NoIn” variants are needed to avoid confusing the in operator in a relational expression with the in operator in a for statement.\n\n## Semantics\n\nThe result of evaluating a relational operator is always of type Boolean, reflecting whether the relationship named by the operator holds between its two operands.\n\nThe RelationalExpressionNoIn productions are evaluated in the same manner as the RelationalExpression productions except that the contained RelationalExpressionNoIn is evaluated instead of the contained RelationalExpression.\n\n# [11.8.1](#sec-11.8.1 \"link to this section\") The Less-than Operator ( < )\n\nThe production RelationalExpression : RelationalExpression `<` ShiftExpression is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating _RelationalExpression_.\n2. Let _lval_ be [GetValue](#sec-8.7.1)(_lref_).\n3. Let _rref_ be the result of evaluating _ShiftExpression_.\n4. Let _rval_ be [GetValue](#sec-8.7.1)(_rref_).\n5. Let _r_ be the result of performing abstract relational comparison _lval_ < _rval_. ([see 11.8.5](#sec-11.8.5))\n6. If _r_ is **undefined**, return **false**. Otherwise, return _r_.\n\n# [11.8.2](#sec-11.8.2 \"link to this section\") The Greater-than Operator (\\> )\n\nThe production RelationalExpression **:** RelationalExpression `>` ShiftExpression is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating _RelationalExpression_.\n2. Let _lval_ be [GetValue](#sec-8.7.1)(_lref_).\n3. Let _rref_ be the result of evaluating _ShiftExpression_.\n4. Let _rval_ be [GetValue](#sec-8.7.1)(_rref_).\n5. Let _r_ be the result of performing abstract relational comparison _rval_ < _lval_ with_LeftFirst_ equal to **false**. ([see 11.8.5](#sec-11.8.5)).\n6. If _r_ is **undefined**, return **false**. Otherwise, return _r_.\n\n# [11.8.3](#sec-11.8.3 \"link to this section\") The Less-than-or-equal Operator ( <= )\n\nThe production RelationalExpression **:** RelationalExpression `<=` ShiftExpression is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating _RelationalExpression_.\n2. Let _lval_ be [GetValue](#sec-8.7.1)(_lref_).\n3. Let _rref_ be the result of evaluating _ShiftExpression_.\n4. Let _rval_ be [GetValue](#sec-8.7.1)(_rref_).\n5. Let _r_ be the result of performing abstract relational comparison _rval_ < _lval_ with_LeftFirst_ equal to **false**. ([see 11.8.5](#sec-11.8.5)).\n6. If _r_ is **true** or **undefined**, return **false**. Otherwise, return **true**.\n\n# [11.8.4](#sec-11.8.4 \"link to this section\") The Greater-than-or-equal Operator ( \\>= )\n\nThe production RelationalExpression **:** RelationalExpression `>=` ShiftExpression is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating _RelationalExpression_.\n2. Let _lval_ be [GetValue](#sec-8.7.1)(_lref_).\n3. Let _rref_ be the result of evaluating _ShiftExpression_.\n4. Let _rval_ be [GetValue](#sec-8.7.1)(_rref_).\n5. Let _r_ be the result of performing abstract relational comparison _lval_ < _rval_. ([see 11.8.5](#sec-11.8.5))\n6. If _r_ is **true** or **undefined**, return **false**. Otherwise, return **true**.\n\n# [11.8.5](#sec-11.8.5 \"link to this section\") The Abstract Relational Comparison Algorithm\n\nThe comparison x < y, where x and y are values, produces **true**,**false**, or **undefined** (which indicates that at least one operand is **NaN**). In addition to x andy the algorithm takes a Boolean flag named LeftFirst as a parameter. The flag is used to control the order in which operations with potentially visible side-effects are performed upon x andy. It is necessary because ECMAScript specifies left to right evaluation of expressions. The default value ofLeftFirst is **true** and indicates that the x parameter corresponds to an expression that occurs to the left of the y parameter’s corresponding expression. If LeftFirst is **false**, the reverse is the case and operations must be performed upon y before x. Such a comparison is performed as follows:\n\n1. If the _LeftFirst_ flag is **true**, then  \n   1. Let _px_ be the result of calling [ToPrimitive](#sec-9.1)(_x_, hint Number).  \n   2. Let _py_ be the result of calling [ToPrimitive](#sec-9.1)(_y_, hint Number).\n2. Else the order of evaluation needs to be reversed to preserve left to right evaluation  \n   1. Let _py_ be the result of calling [ToPrimitive](#sec-9.1)(_y_, hint Number).  \n   2. Let _px_ be the result of calling [ToPrimitive](#sec-9.1)(_x_, hint Number).\n3. If it is not the case that both [Type](#sec-8)(_px_) is String and [Type](#sec-8)(_py_) is String, then  \n   1. Let _nx_ be the result of calling [ToNumber](#sec-9.3)(_px_). Because _px_ and _py_ are primitive values evaluation order is not important.  \n   2. Let _ny_ be the result of calling [ToNumber](#sec-9.3)(_py_).  \n   3. If _nx_ is **NaN**, return **undefined**.  \n   4. If _ny_ is **NaN**, return **undefined**.  \n   5. If _nx_ and _ny_ are the same Number value, return **false**.  \n   6. If _nx_ is **+0** and _ny_ is **−0**, return **false**.  \n   7. If _nx_ is **−0** and _ny_ is **+0**, return **false**.  \n   8. If _nx_ is **+∞**, return **false**.  \n   9. If _ny_ is **+∞**, return **true**.  \n   10. If _ny_ is **−∞**, return **false**.  \n   11. If _nx_ is **−∞**, return **true**.  \n   12. If the mathematical value of _nx_ is less than the mathematical value of _ny_ —note that these mathematical values are both finite and not both zero—return **true**. Otherwise, return**false**.\n4. Else, both _px_ and _py_ are Strings  \n   1. If _py_ is a prefix of _px_, return **false**. (A String value _p_ is a prefix of String value_q_ if _q_ can be the result of concatenating _p_ and some other String _r_. Note that any String is a prefix of itself, because _r_ may be the empty String.)  \n   2. If _px_ is a prefix of _py_, return **true**.  \n   3. Let _k_ be the smallest nonnegative integer such that the character at position _k_ within _px_ is different from the character at position _k_ within _py_. (There must be such a _k_, for neither String is a prefix of the other.)  \n   4. Let _m_ be the integer that is the code unit value for the character at position _k_ within_px_.  \n   5. Let _n_ be the integer that is the code unit value for the character at position _k_ within_py_.  \n   6. If _m_ < _n_, return **true**. Otherwise, return **false**.\n\nNOTE 1 Step 3 differs from step 7 in the algorithm for the addition operator `+` ([11.6.1](#sec-11.6.1)) in using and instead of or.\n\nNOTE 2 The comparison of Strings uses a simple lexicographic ordering on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore String values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalised form. Also, note that for strings containing supplementary characters, lexicographic ordering on sequences of UTF-16 code unit values differs from that on sequences of code point values.\n\n# [11.8.6](#sec-11.8.6 \"link to this section\") The instanceof operator\n\nThe production RelationalExpression : RelationalExpression `instanceof` ShiftExpression is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating _RelationalExpression_.\n2. Let _lval_ be [GetValue](#sec-8.7.1)(_lref_).\n3. Let _rref_ be the result of evaluating _ShiftExpression_.\n4. Let _rval_ be [GetValue](#sec-8.7.1)(_rref_).\n5. If [Type](#sec-8)(_rval_) is not Object, throw a **TypeError** exception.\n6. If _rval_ does not have a \\[\\[HasInstance\\]\\] internal method, throw a **TypeError** exception.\n7. Return the result of calling the \\[\\[HasInstance\\]\\] internal method of _rval_ with argument _lval_.\n\n# [11.8.7](#sec-11.8.7 \"link to this section\") The in operator\n\nThe production RelationalExpression : RelationalExpression `in` ShiftExpression is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating _RelationalExpression_.\n2. Let _lval_ be [GetValue](#sec-8.7.1)(_lref_).\n3. Let _rref_ be the result of evaluating _ShiftExpression_.\n4. Let _rval_ be [GetValue](#sec-8.7.1)(_rref_).\n5. If [Type](#sec-8)(_rval_) is not Object, throw a **TypeError** exception.\n6. Return the result of calling the \\[\\[HasProperty\\]\\] internal method of _rval_ with argument [ToString](#sec-9.8)(_lval_).\n\n# [11.9](#sec-11.9 \"link to this section\") Equality Operators\n\n## Syntax\n\nEqualityExpression :\n\nRelationalExpression\n\nEqualityExpression `==` RelationalExpression\n\nEqualityExpression `!=` RelationalExpression\n\nEqualityExpression `===` RelationalExpression\n\nEqualityExpression `!==` RelationalExpression\n\nEqualityExpressionNoIn :\n\nRelationalExpressionNoIn\n\nEqualityExpressionNoIn `==` RelationalExpressionNoIn\n\nEqualityExpressionNoIn `!=` RelationalExpressionNoIn\n\nEqualityExpressionNoIn `===` RelationalExpressionNoIn\n\nEqualityExpressionNoIn `!==` RelationalExpressionNoIn\n\n## Semantics\n\nThe result of evaluating an equality operator is always of type Boolean, reflecting whether the relationship named by the operator holds between its two operands.\n\nThe EqualityExpressionNoIn productions are evaluated in the same manner as the EqualityExpression productions except that the contained EqualityExpressionNoIn andRelationalExpressionNoIn are evaluated instead of the contained EqualityExpression and RelationalExpression, respectively.\n\n# [11.9.1](#sec-11.9.1 \"link to this section\") The Equals Operator ( \\== )\n\nThe production EqualityExpression : EqualityExpression `==` RelationalExpression is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating _EqualityExpression_.\n2. Let _lval_ be [GetValue](#sec-8.7.1)(_lref_).\n3. Let _rref_ be the result of evaluating _RelationalExpression_.\n4. Let _rval_ be [GetValue](#sec-8.7.1)(_rref_).\n5. Return the result of performing abstract equality comparison _rval_ \\== _lval_. ([see 11.9.3](#sec-11.9.3)).\n\n# [11.9.2](#sec-11.9.2 \"link to this section\") The Does-not-equals Operator (!= )\n\nThe production EqualityExpression **:** EqualityExpression `!=` RelationalExpression is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating _EqualityExpression_.\n2. Let _lval_ be [GetValue](#sec-8.7.1)(_lref_).\n3. Let _rref_ be the result of evaluating _RelationalExpression_.\n4. Let _rval_ be [GetValue](#sec-8.7.1)(_rref_).\n5. Let _r_ be the result of performing abstract equality comparison _rval_ \\== _lval_. ([see 11.9.3](#sec-11.9.3)).\n6. If _r_ is **true**, return **false**. Otherwise, return **true**.\n\n# [11.9.3](#sec-11.9.3 \"link to this section\") The Abstract Equality Comparison Algorithm\n\nThe comparison x \\== y, where x and y are values, produces **true** or**false**. Such a comparison is performed as follows:\n\n1. If [Type](#sec-8)(_x_) is the same as [Type](#sec-8)(_y_), then  \n   1. If [Type](#sec-8)(_x_) is Undefined, return **true**.  \n   2. If [Type](#sec-8)(_x_) is Null, return **true**.  \n   3. If [Type](#sec-8)(_x_) is Number, then  \n         1. If _x_ is **NaN**, return **false**.  \n         2. If _y_ is **NaN**, return **false**.  \n         3. If _x_ is the same Number value as _y_, return **true**.  \n         4. If _x_ is **+0** and _y_ is **−0**, return **true**.  \n         5. If _x_ is **−0** and _y_ is **+0**, return **true**.  \n         6. Return **false**.  \n   4. If [Type](#sec-8)(_x_) is String, then return **true** if _x_ and _y_ are exactly the same sequence of characters (same length and same characters in corresponding positions). Otherwise, return**false**.  \n   5. If [Type](#sec-8)(_x_) is Boolean, return **true** if _x_ and _y_ are both**true** or both **false**. Otherwise, return **false**.  \n   6. Return **true** if _x_ and _y_ refer to the same object. Otherwise, return **false**.\n2. If _x_ is **null** and _y_ is **undefined**, return **true**.\n3. If _x_ is **undefined** and _y_ is **null**, return **true**.\n4. If [Type](#sec-8)(_x_) is Number and [Type](#sec-8)(_y_) is String,  \nreturn the result of the comparison _x_ \\== [ToNumber](#sec-9.3)(_y_).\n5. If [Type](#sec-8)(_x_) is String and [Type](#sec-8)(_y_) is Number,  \nreturn the result of the comparison [ToNumber](#sec-9.3)(_x_) == _y_.\n6. If [Type](#sec-8)(_x_) is Boolean, return the result of the comparison [ToNumber](#sec-9.3)(_x_) == _y_.\n7. If [Type](#sec-8)(_y_) is Boolean, return the result of the comparison _x_ \\== [ToNumber](#sec-9.3)(_y_).\n8. If [Type](#sec-8)(_x_) is either String or Number and [Type](#sec-8)(_y_) is Object,  \nreturn the result of the comparison _x_ \\== [ToPrimitive](#sec-9.1)(_y_).\n9. If [Type](#sec-8)(_x_) is Object and [Type](#sec-8)(_y_) is either String or Number,  \nreturn the result of the comparison [ToPrimitive](#sec-9.1)(_x_) == _y_.\n10. Return **false**.\n\nNOTE 1 Given the above definition of equality:\n\n* String comparison can be forced by: `\"\" + a == \"\" + b`.\n* Numeric comparison can be forced by: `+a == +b`.\n* Boolean comparison can be forced by: `!a == !b`.\n\nNOTE 2 The equality operators maintain the following invariants:\n\n* `A` `!=` `B` is equivalent to `!(A` `==` `B)`.\n* `A` `==` `B` is equivalent to `B` `==` `A`, except in the order of evaluation of `A` and `B`.\n\nNOTE 3 The equality operator is not always transitive. For example, there might be two distinct String objects, each representing the same String value; each String object would be considered equal to the String value by the `==` operator, but the two String objects would not be equal to each other. For Example:\n\n* `new String(\"a\")` `==` `\"a\"` and `\"a\"` `==` `new String(\"a\")`are both **true**.\n* `new String(\"a\")` `==` `new String(\"a\")` is **false**.\n\nNOTE 4 Comparison of Strings uses a simple equality test on sequences of code unit values. There is no attempt to use the more complex, semantically oriented definitions of character or string equality and collating order defined in the Unicode specification. Therefore Strings values that are canonically equal according to the Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalised form.\n\n# [11.9.4](#sec-11.9.4 \"link to this section\") The Strict Equals Operator (\\=== )\n\nThe production EqualityExpression **:** EqualityExpression `===` RelationalExpression is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating _EqualityExpression_.\n2. Let _lval_ be [GetValue](#sec-8.7.1)(_lref_).\n3. Let _rref_ be the result of evaluating _RelationalExpression_.\n4. Let _rval_ be [GetValue](#sec-8.7.1)(_rref_).\n5. Return the result of performing the strict equality comparison _rval_ \\=== _lval_. (See [11.9.6](#sec-11.9.6))\n\n# [11.9.5](#sec-11.9.5 \"link to this section\") The Strict Does-not-equal Operator ( !== )\n\nThe production EqualityExpression **:** EqualityExpression `!==` RelationalExpression is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating _EqualityExpression_.\n2. Let _lval_ be [GetValue](#sec-8.7.1)(_lref_).\n3. Let _rref_ be the result of evaluating _RelationalExpression_.\n4. Let _rval_ be [GetValue](#sec-8.7.1)(_rref_).\n5. Let _r_ be the result of performing strict equality comparison _rval_ \\=== _lval_. (See [11.9.6](#sec-11.9.6))\n6. If _r_ is **true**, return **false**. Otherwise, return **true**.\n\n# [11.9.6](#sec-11.9.6 \"link to this section\") The Strict Equality Comparison Algorithm\n\nThe comparison x \\=== y, where x and y are values, produces **true** or**false**. Such a comparison is performed as follows:\n\n1. If [Type](#sec-8)(_x_) is different from [Type](#sec-8)(_y_), return**false**.\n2. If [Type](#sec-8)(_x_) is Undefined, return **true**.\n3. If [Type](#sec-8)(_x_) is Null, return **true**.\n4. If [Type](#sec-8)(_x_) is Number, then  \n   1. If _x_ is **NaN**, return **false**.  \n   2. If _y_ is **NaN**, return **false**.  \n   3. If _x_ is the same Number value as _y_, return **true**.  \n   4. If _x_ is **+0** and _y_ is **−0**, return **true**.  \n   5. If _x_ is **−0** and _y_ is **+0**, return **true**.  \n   6. Return **false**.\n5. If [Type](#sec-8)(_x_) is String, then return **true** if _x_ and _y_ are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return**false**.\n6. If [Type](#sec-8)(_x_) is Boolean, return **true** if _x_ and _y_ are both **true** or both **false**; otherwise, return **false**.\n7. Return **true** if _x_ and _y_ refer to the same object. Otherwise, return **false**.\n\nNOTE This algorithm differs from [the SameValue Algorithm (9.12)](#sec-9.12) in its treatment of signed zeroes and NaNs.\n\n# [11.10](#sec-11.10 \"link to this section\") Binary Bitwise Operators\n\n## Syntax\n\nBitwiseANDExpression :\n\nEqualityExpression\n\nBitwiseANDExpression `&` EqualityExpression\n\nBitwiseANDExpressionNoIn :\n\nEqualityExpressionNoIn\n\nBitwiseANDExpressionNoIn `&` EqualityExpressionNoIn\n\nBitwiseXORExpression :\n\nBitwiseANDExpression\n\nBitwiseXORExpression `^` BitwiseANDExpression\n\nBitwiseXORExpressionNoIn :\n\nBitwiseANDExpressionNoIn\n\nBitwiseXORExpressionNoIn `^` BitwiseANDExpressionNoIn\n\nBitwiseORExpression :\n\nBitwiseXORExpression\n\nBitwiseORExpression `|` BitwiseXORExpression\n\nBitwiseORExpressionNoIn :\n\nBitwiseXORExpressionNoIn\n\nBitwiseORExpressionNoIn `|` BitwiseXORExpressionNoIn\n\n## Semantics\n\nThe production A **:** _A @ B_, where @ is one of the bitwise operators in the productions above, is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating _A_.\n2. Let _lval_ be [GetValue](#sec-8.7.1)(_lref_).\n3. Let _rref_ be the result of evaluating _B_.\n4. Let _rval_ be [GetValue](#sec-8.7.1)(_rref_).\n5. Let _lnum_ be [ToInt32](#sec-9.5)(_lval_).\n6. Let _rnum_ be [ToInt32](#sec-9.5)(_rval_).\n7. Return the result of applying the bitwise operator @ to _lnum_ and _rnum_. The result is a signed 32 bit integer.\n\n# [11.11](#sec-11.11 \"link to this section\") Binary Logical Operators\n\n## Syntax\n\nLogicalANDExpression :\n\nBitwiseORExpression\n\nLogicalANDExpression `&&` BitwiseORExpression\n\nLogicalANDExpressionNoIn :\n\nBitwiseORExpressionNoIn\n\nLogicalANDExpressionNoIn `&&` BitwiseORExpressionNoIn\n\nLogicalORExpression :\n\nLogicalANDExpression\n\nLogicalORExpression `||` LogicalANDExpression\n\nLogicalORExpressionNoIn :\n\nLogicalANDExpressionNoIn\n\nLogicalORExpressionNoIn `||` LogicalANDExpressionNoIn\n\n## Semantics\n\nThe production LogicalANDExpression : LogicalANDExpression `&&` BitwiseORExpression is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating _LogicalANDExpression_.\n2. Let _lval_ be [GetValue](#sec-8.7.1)(_lref_).\n3. If [ToBoolean](#sec-9.2)(_lval_) is **false**, return _lval_.\n4. Let _rref_ be the result of evaluating _BitwiseORExpression_.\n5. Return [GetValue](#sec-8.7.1)(_rref_).\n\nThe production LogicalORExpression : LogicalORExpression `||` LogicalANDExpression is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating _LogicalORExpression_.\n2. Let _lval_ be [GetValue](#sec-8.7.1)(_lref_).\n3. If [ToBoolean](#sec-9.2)(_lval_) is **true**, return _lval_.\n4. Let _rref_ be the result of evaluating _LogicalANDExpression_.\n5. Return [GetValue](#sec-8.7.1)(_rref_).\n\nThe LogicalANDExpressionNoIn and LogicalORExpressionNoIn productions are evaluated in the same manner as the LogicalANDExpression and LogicalORExpression productions except that the contained LogicalANDExpressionNoIn,BitwiseORExpressionNoIn and LogicalORExpressionNoIn are evaluated instead of the contained LogicalANDExpression, BitwiseORExpression and LogicalORExpression, respectively.\n\nNOTE The value produced by a `&&` or `||` operator is not necessarily of type Boolean. The value produced will always be the value of one of the two operand expressions.\n\n# [11.12](#sec-11.12 \"link to this section\") Conditional Operator ( ? : )\n\n## Syntax\n\nConditionalExpression :\n\nLogicalORExpression\n\nLogicalORExpression `?` AssignmentExpression `:` AssignmentExpression\n\nConditionalExpressionNoIn :\n\nLogicalORExpressionNoIn\n\nLogicalORExpressionNoIn `?` AssignmentExpression `:` AssignmentExpressionNoIn\n\n## Semantics\n\nThe production ConditionalExpression : LogicalORExpression `?` AssignmentExpression `:` AssignmentExpression is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating _LogicalORExpression_.\n2. If [ToBoolean](#sec-9.2)([GetValue](#sec-8.7.1)(_lref_)) is **true**, then  \n   1. Let _trueRef_ be the result of evaluating the first _AssignmentExpression_.  \n   2. Return [GetValue](#sec-8.7.1)(_trueRef_).\n3. Else  \n   1. Let _falseRef_ be the result of evaluating the second _AssignmentExpression_.  \n   2. Return [GetValue](#sec-8.7.1)(_falseRef_).\n\nThe ConditionalExpressionNoIn production is evaluated in the same manner as the ConditionalExpression production except that the contained LogicalORExpressionNoIn,AssignmentExpression and AssignmentExpressionNoIn are evaluated instead of the contained LogicalORExpression, first AssignmentExpression and second AssignmentExpression, respectively.\n\nNOTE The grammar for a ConditionalExpression in ECMAScript is a little bit different from that in C and Java, which each allow the second subexpression to be an Expression but restrict the third expression to be a ConditionalExpression. The motivation for this difference in ECMAScript is to allow an assignment expression to be governed by either arm of a conditional and to eliminate the confusing and fairly useless case of a comma expression as the centre expression.\n\n# [11.13](#sec-11.13 \"link to this section\") Assignment Operators\n\n## Syntax\n\nAssignmentExpression :\n\nConditionalExpression\n\nLeftHandSideExpression `=` AssignmentExpression\n\nLeftHandSideExpression AssignmentOperator AssignmentExpression\n\nAssignmentExpressionNoIn :\n\nConditionalExpressionNoIn\n\nLeftHandSideExpression `=` AssignmentExpressionNoIn\n\nLeftHandSideExpression AssignmentOperator AssignmentExpressionNoIn\n\nAssignmentOperator : one of\n\n| \\*= | /= | %= | += | \\-= | <<= | \\>>= | \\>>>= | &= | ^= | \\|= |\n| --- | -- | -- | -- | --- | --- | ---- | ----- | -- | -- | --- |\n\n## Semantics\n\nThe AssignmentExpressionNoIn productions are evaluated in the same manner as the AssignmentExpression productions except that the contained ConditionalExpressionNoIn and AssignmentExpressionNoIn are evaluated instead of the contained ConditionalExpression and AssignmentExpression, respectively.\n\n# [11.13.1](#sec-11.13.1 \"link to this section\") Simple Assignment ( \\= )\n\nThe production AssignmentExpression : LeftHandSideExpression `=` AssignmentExpression is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating _LeftHandSideExpression_.\n2. Let _rref_ be the result of evaluating _AssignmentExpression_.\n3. Let _rval_ be [GetValue](#sec-8.7.1)(_rref_).\n4. Throw a **SyntaxError** exception if the following conditions are all true:  \n   * [Type](#sec-8)(_lref_) is [Reference](#sec-8.7) is **true**  \n   * [IsStrictReference](#sec-8.7)(_lref_) is **true**  \n   * [Type](#sec-8)([GetBase](#sec-8.7)(_lref_)) is [Environment Record](#sec-10.2.1)  \n   * [GetReferencedName](#sec-8.7)(_lref_) is either `\"eval\"` or `\"arguments\"`\n1. Call [PutValue](#sec-8.7.2)(_lref_, _rval_).\n2. Return _rval_.\n\nNOTE When an assignment occurs within [strict mode code](#sec-10.1.1), its LeftHandSide must not evaluate to an unresolvable reference. If it does a **ReferenceError** exception is thrown upon assignment. The LeftHandSide also may not be a reference to a data property with the attribute value {\\[\\[Writable\\]\\]:**false**}, to an accessor property with the attribute value {\\[\\[Set\\]\\]:**undefined**}, nor to a non-existent property of an object whose \\[\\[Extensible\\]\\] internal property has the value **false**. In these cases a **TypeError** exception is thrown.\n\n# [11.13.2](#sec-11.13.2 \"link to this section\") Compound Assignment ( op= )\n\nThe production AssignmentExpression : LeftHandSideExpression AssignmentOperator AssignmentExpression , where AssignmentOperator is @`=` and @ represents one of the operators indicated above, is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating _LeftHandSideExpression_.\n2. Let _lval_ be [GetValue](#sec-8.7.1)(_lref_).\n3. Let _rref_ be the result of evaluating _AssignmentExpression_.\n4. Let _rval_ be [GetValue](#sec-8.7.1)(_rref_).\n5. Let _r_ be the result of applying operator @ to _lval_ and _rval_.\n6. Throw a **SyntaxError** exception if the following conditions are all true:  \n   * [Type](#sec-8)(_lref_) is [Reference](#sec-8.7) is **true**  \n   * [IsStrictReference](#sec-8.7)(_lref_) is **true**  \n   * [Type](#sec-8)([GetBase](#sec-8.7)(_lref_)) is [Environment Record](#sec-10.2.1)  \n   * [GetReferencedName](#sec-8.7)(lref) is either `\"eval\"` or `\"arguments\"`\n1. Call [PutValue](#sec-8.7.2)(_lref_, _r_).\n2. Return _r_.\n\nNOTE See NOTE 11.13.1.\n\n# [11.14](#sec-11.14 \"link to this section\") Comma Operator ( , )\n\n## Syntax\n\nExpression :\n\nAssignmentExpression\n\nExpression `,` AssignmentExpression\n\nExpressionNoIn :\n\nAssignmentExpressionNoIn\n\nExpressionNoIn `,` AssignmentExpressionNoIn\n\n## Semantics\n\nThe production Expression : Expression `,` AssignmentExpression is evaluated as follows:\n\n1. Let _lref_ be the result of evaluating _Expression_.\n2. Call [GetValue](#sec-8.7.1)(_lref_).\n3. Let _rref_ be the result of evaluating _AssignmentExpression_.\n4. Return [GetValue](#sec-8.7.1)(_rref_).\n\nThe ExpressionNoIn production is evaluated in the same manner as the Expression production except that the contained ExpressionNoIn and AssignmentExpressionNoIn are evaluated instead of the contained Expression and AssignmentExpression, respectively.\n\nNOTE [GetValue](#sec-8.7.1) must be called even though its value is not used because it may have observable side-effects."}