{"lang":"JavascriptES5","category":"","fullPath":"","title":"12 Statements12.1 Block12.2 Variable Statement12.2.1 Strict Mode Restrictions12.3 Empty Statement12.4 Expression Statement12.5 The if Statement12.6 Iteration Statements12.6.1 The do-while Statement12.6.2 The while Statement12.6.3 The for Statement12.6.4 The for-in Statement12.7 The continue Statement12.8 The break Statement12.9 The return Statement12.10 The with Statement12.10.1 Strict Mode\n          Restrictions12.11 The switch Statement12.12 Labelled Statements12.13 The throw Statement12.14 The try Statement12.14.1 Strict Mode\n          Restrictions12.15 The debugger statement","markdown":"# [12](#sec-12 \"link to this section\") Statements\n\n## Syntax\n\nStatement :\n\nBlock\n\nVariableStatement\n\nEmptyStatement\n\nExpressionStatement\n\nIfStatement\n\nIterationStatement\n\nContinueStatement\n\nBreakStatement\n\nReturnStatement\n\nWithStatement\n\nLabelledStatement\n\nSwitchStatement\n\nThrowStatement\n\nTryStatement\n\nDebuggerStatement\n\n## Semantics\n\nA Statement can be part of a LabelledStatement, which itself can be part of aLabelledStatement, and so on. The labels introduced this way are collectively referred to as the “current label set” when describing the semantics of individual statements. A LabelledStatement has no semantic meaning other than the introduction of a label to a _label set_. The label set of an IterationStatement or a SwitchStatement initially contains the single element **empty**. The label set of any other statement is initially empty.\n\nThe result of evaluating a Statement is always a [Completion](#sec-8.9) value.\n\nNOTE Several widely used implementations of ECMAScript are known to support the use of FunctionDeclaration as a Statement. However there are significant and irreconcilable variations among the implementations in the semantics applied to such FunctionDeclarations. Because of these irreconcilable differences, the use of a FunctionDeclaration as a Statement results in code that is not reliably portable among implementations. It is recommended that ECMAScript implementations either disallow this usage of FunctionDeclaration or issue a warning when such a usage is encountered. Future editions of ECMAScript may define alternative portable means for declaring functions in a Statement context.\n\n# [12.1](#sec-12.1 \"link to this section\") Block\n\n## Syntax\n\nBlock :\n\n`{` StatementListopt `}`\n\nStatementList :\n\nStatement\n\nStatementList Statement\n\n## Semantics\n\nThe production Block : `{` `}` is evaluated as follows:\n\n1. Return (**normal**, **empty**, **empty**).\n\nThe production Block : `{` StatementList `}` is evaluated as follows:\n\n1. Return the result of evaluating _StatementList_.\n\nThe production StatementList : Statement is evaluated as follows:\n\n1. Let _s_ be the result of evaluating _Statement_.\n2. If an exception was thrown, return (throw, _V_, empty) where _V_ is the exception. (Execution now proceeds as if no exception were thrown.)\n3. Return _s_.\n\nThe production StatementList : StatementList Statement is evaluated as follows:\n\n1. Let _sl_ be the result of evaluating _StatementList_.\n2. If _sl_ is an [abrupt completion](#sec-8.9), return _sl_.\n3. Let _s_ be the result of evaluating _Statement_.\n4. If an exception was thrown, return (throw, _V_, empty) where _V_ is the exception. (Execution now proceeds as if no exception were thrown.)\n5. If _s_.value is empty, let _V_ \\= _sl_.value, otherwise let_V_ \\= _s_.value.\n6. Return (_s_.type, _V_, _s_.target).\n\nNOTE Steps 5 and 6 of the above algoritm ensure that the value of a StatementList is the value of the last value producing _Statement_ in the StatementList. For example, the following calls to the `eval` function all return the value 1:\n\neval(\"1;;;;;\")\n\neval(\"1;{}\")\n\neval(\"1;var a;\")\n\n# [12.2](#sec-12.2 \"link to this section\") Variable Statement\n\n## Syntax\n\nVariableStatement :\n\n`var` VariableDeclarationList `;`\n\nVariableDeclarationList :\n\nVariableDeclaration\n\nVariableDeclarationList `,` VariableDeclaration\n\nVariableDeclarationListNoIn :\n\nVariableDeclarationNoIn\n\nVariableDeclarationListNoIn `,` VariableDeclarationNoIn\n\nVariableDeclaration :\n\nIdentifier Initialiseropt\n\nVariableDeclarationNoIn :\n\nIdentifier InitialiserNoInopt\n\nInitialiser :\n\n`=` AssignmentExpression\n\nInitialiserNoIn :\n\n`=` AssignmentExpressionNoIn\n\nA variable statement declares variables that are created as defined in [10.5](#sec-10.5). Variables are initialised to **undefined** when created. A variable with an Initialiser is assigned the value of its AssignmentExpression when the VariableStatement is executed, not when the variable is created.\n\n## Semantics\n\nThe production VariableStatement : `var` VariableDeclarationList `;` is evaluated as follows:\n\n1. Evaluate _VariableDeclarationList_.\n2. Return (normal, empty, empty).\n\nThe production VariableDeclarationList `:VariableDeclaration` is evaluated as follows:\n\n1. Evaluate _VariableDeclaration_.\n\nThe production VariableDeclarationList : VariableDeclarationList `,` VariableDeclaration is evaluated as follows:\n\n1. Evaluate _VariableDeclarationList_.\n2. Evaluate _VariableDeclaration_.\n\nThe production VariableDeclaration : Identifier is evaluated as follows:\n\n1. Return a String value containing the same sequence of characters as in the _Identifier_.\n\nThe production VariableDeclaration : Identifier Initialiser is evaluated as follows:\n\n1. Let _lhs_ be the result of evaluating _Identifier_ as described in [11.1.2](#sec-11.1.2).\n2. Let _rhs_ be the result of evaluating _Initialiser_.\n3. Let _value_ be [GetValue](#sec-8.7.1)(_rhs_).\n4. Call [PutValue](#sec-8.7.2)(_lhs_, _value_).\n5. Return a String value containing the same sequence of characters as in the _Identifier_.\n\nNOTE The String value of a VariableDeclaration is used in the evaluation of for-in statements ([12.6.4](#sec-12.6.4)).\n\nIf a VariableDeclaration is nested within a with statement and the Identifier in the VariableDeclaration is the same as a property name of the binding object of the with statement’s [object environment record](#sec-10.2.1), then step 4 will assign value to the property instead of to the [VariableEnvironment](#sec-10.3) binding of the Identifier.\n\nThe production Initialiser : `=` AssignmentExpression is evaluated as follows:\n\n1. Return the result of evaluating _AssignmentExpression_.\n\nThe VariableDeclarationListNoIn, VariableDeclarationNoIn and InitialiserNoIn productions are evaluated in the same manner as the VariableDeclarationList, VariableDeclaration and Initialiser productions except that the contained VariableDeclarationListNoIn, VariableDeclarationNoIn, InitialiserNoIn and AssignmentExpressionNoIn are evaluated instead of the contained VariableDeclarationList, VariableDeclaration, Initialiser and AssignmentExpression, respectively.\n\n# [12.2.1](#sec-12.2.1 \"link to this section\") Strict Mode Restrictions\n\nIt is a **SyntaxError** if a VariableDeclaration or VariableDeclarationNoIn occurs within [strict code](#sec-10.1.1) and its Identifier is either `\"eval\"` **or \"arguments\"**.\n\n# [12.3](#sec-12.3 \"link to this section\") Empty Statement\n\n## Syntax\n\nEmptyStatement :\n\n`;`\n\n## Semantics\n\nThe production EmptyStatement : `;` is evaluated as follows:\n\n1. Return (normal, empty, empty).\n\n# [12.4](#sec-12.4 \"link to this section\") Expression Statement\n\n## Syntax\n\nExpressionStatement :\n\n\\[lookahead ∉ {`{`, `function`}\\] Expression `;`\n\nNOTE An ExpressionStatement cannot start with an opening curly brace because that might make it ambiguous with a Block. Also, an ExpressionStatement cannot start with the `function` keyword because that might make it ambiguous with a FunctionDeclaration.\n\n## Semantics\n\nThe production ExpressionStatement : \\[lookahead ∉ {`{`, `function`}\\] Expression `;` is evaluated as follows:\n\n1. Let _exprRef_ be the result of evaluating _Expression_.\n2. Return (normal, [GetValue](#sec-8.7.1)(_exprRef_), empty).\n\n# [12.5](#sec-12.5 \"link to this section\") The if Statement\n\n## Syntax\n\nIfStatement :\n\n`if` `(` Expression `)` Statement `else` Statement\n\n`if` `(` Expression `)` Statement\n\nEach `else` for which the choice of associated `if` is ambiguous shall be associated with the nearest possible **if** that would otherwise have no corresponding `else`.\n\n## Semantics\n\nThe production IfStatement : `if` `(` Expression `)` Statement `else` Statement is evaluated as follows:\n\n1. Let _exprRef_ be the result of evaluating _Expression_.\n2. If [ToBoolean](#sec-9.2)([GetValue](#sec-8.7.1)(_exprRef_)) is **true**, then  \n   1. Return the result of evaluating the first _Statement_.\n3. Else,  \n   1. Return the result of evaluating the second _Statement_.\n\nThe production IfStatement : `if` `(` Expression `)` Statement is evaluated as follows:\n\n1. Let _exprRef_ be the result of evaluating _Expression_.\n2. If [ToBoolean](#sec-9.2)([GetValue](#sec-8.7.1)(_exprRef_)) is **false**, return (normal, empty, empty).\n3. Return the result of evaluating _Statement_.\n\n# [12.6](#sec-12.6 \"link to this section\") Iteration Statements\n\n## Syntax\n\nIterationStatement :\n\n`do` Statement `while` `(` Expression `);`\n\n`while` `(` Expression `)` Statement\n\n`for` `(` ExpressionNoInopt `;` Expressionopt `;` Expressionopt `)` Statement\n\n`for` `(` `var` VariableDeclarationListNoIn `;` Expressionopt `;` Expressionopt `)` Statement\n\n`for` `(` LeftHandSideExpression `in` Expression `)` Statement\n\n`for` `(` `var` VariableDeclarationNoIn `in` Expression `)` Statement\n\n# [12.6.1](#sec-12.6.1 \"link to this section\") The do\\-while Statement\n\nThe production `do` Statement `while` `(` Expression `);` is evaluated as follows:\n\n1. Let _V_ \\= empty.\n2. Let _iterating_ be **true**.\n3. Repeat, while _iterating_ is **true**  \n   1. Let _stmt_ be the result of evaluating _Statement_.  \n   2. If _stmt_.value is not empty, let _V_ \\=_stmt_.value_._  \n   3. If _stmt_.type is not continue || _stmt_.target is not in the current label set, then  \n         1. If _stmt_.type is break and _stmt_.target is in the current label set, return (normal, _V_, empty).  \n         2. If _stmt_ is an [abrupt completion](#sec-8.9), return _stmt_.  \n   4. Let _exprRef_ be the result of evaluating _Expression_.  \n   5. If [ToBoolean](#sec-9.2)([GetValue](#sec-8.7.1)(_exprRef_)) is **false**, set_iterating_ to **false**.\n4. Return (normal, _V_, empty);\n\n# [12.6.2](#sec-12.6.2 \"link to this section\") The while Statement\n\nThe production IterationStatement : `while` `(` Expression `)` Statement is evaluated as follows:\n\n1. Let _V_ \\= empty.\n2. Repeat  \n   1. Let _exprRef_ be the result of evaluating _Expression_.  \n   2. If [ToBoolean](#sec-9.2)([GetValue](#sec-8.7.1)(_exprRef_)) is **false**, return (normal, _V_, empty).  \n   3. Let _stmt_ be the result of evaluating _Statement_.  \n   4. If _stmt_.value is not empty, let _V_ \\=_stmt_.value.  \n   5. If _stmt_.type is not continue || _stmt_.target is not in the current label set, then  \n         1. If _stmt_.type is break and _stmt_.target is in the current label set, then  \n                  1. Return (normal, _V_, empty).  \n         2. If _stmt_ is an [abrupt completion](#sec-8.9), return _stmt_.\n\n# [12.6.3](#sec-12.6.3 \"link to this section\") The for Statement\n\nThe production  \nIterationStatement : `for` `(` ExpressionNoInopt `;` Expressionopt `;` Expressionopt `)` Statement  \nis evaluated as follows:\n\n1. If _ExpressionNoIn_ is present, then.  \n   1. Let _exprRef_ be the result of evaluating _ExpressionNoIn_.  \n   2. Call [GetValue](#sec-8.7.1)(_exprRef_). (This value is not used but the call may have side-effects.)\n2. Let _V_ \\= empty.\n3. Repeat  \n   1. If the first _Expression_ is present, then  \n         1. Let _testExprRef_ be the result of evaluating the first _Expression_.  \n         2. If [ToBoolean](#sec-9.2)([GetValue](#sec-8.7.1)(_testExprRef_)) is **false**, return (normal, _V_, empty).  \n   2. Let _stmt_ be the result of evaluating _Statement_.  \n   3. If _stmt_.value is not empty, let _V_ \\=_stmt_.value  \n   4. If _stmt_.type is break and _stmt_.target is in the current label set, return (**normal**, _V_, **empty**).  \n   5. If _stmt_.type is not continue || _stmt_.target is not in the current label set, then  \n         1. If _stmt_ is an [abrupt completion](#sec-8.9), return _stmt_.  \n   6. If the second _Expression_ is present, then  \n         1. Let _incExprRef_ be the result of evaluating the second _Expressio_n.  \n         2. Call [GetValue](#sec-8.7.1)(_incExprRef_). (This value is not used.)\n\nThe production  \nIterationStatement : `for` `(` `var` VariableDeclarationListNoIn `;` Expressionopt `;` Expressionopt `)` Statement  \nis evaluated as follows:\n\n1. Evaluate _VariableDeclarationListNoIn_.\n2. Let V = empty.\n3. Repeat  \n   1. If the first _Expression_ is present, then  \n         1. Let _testExprRef_ be the result of evaluating the first _Expression_.  \n         2. If [ToBoolean](#sec-9.2)([GetValue](#sec-8.7.1)(_testExprRef_)) is **false**, then return (normal, V, empty).  \n   2. Let _stmt_ be the result of evaluating _Statement_.  \n   3. If _stmt_.value is not empty, let V = _stmt_.value.  \n   4. If _stmt_.type is break and _stmt_.target is in the current label set, return (**normal**, V, **empty**).  \n   5. If _stmt_.type is not continue || _stmt_.target is not in the current label set, then  \n         1. If _stmt_ is an [abrupt completion](#sec-8.9), return _stmt_.  \n   6. If the second _Expression_ is present, then.  \n         1. Let _incExprRef_ be the result of evaluating the second _Expression_.  \n         2. Call [GetValue](#sec-8.7.1)(_incExprRef_). (This value is not used.)\n\n# [12.6.4](#sec-12.6.4 \"link to this section\") The for\\-in Statement\n\nThe production IterationStatement : `for` `(` LeftHandSideExpression `in` Expression `)` Statement is evaluated as follows:\n\n1. Let _exprRef_ be the result of evaluating the _Expression_.\n2. Let _experValue_ be [GetValue](#sec-8.7.1)(_exprRef_).\n3. If _experValue_ is **null** or **undefined**, return (normal,empty, empty).\n4. Let _obj_ be [ToObject](#sec-9.9)(_experValue_).\n5. Let _V_ \\= empty.\n6. Repeat  \n   1. Let _P_ be the name of the next property of _obj_ whose \\[\\[Enumerable\\]\\] attribute is **true**. If there is no such property, return (normal, _V_, empty).  \n   2. Let _lhsRef_ be the result of evaluating the _LeftHandSideExpression_ ( it may be evaluated repeatedly).  \n   3. Call [PutValue](#sec-8.7.2)(_lhsRef_, _P_).  \n   4. Let _stmt_ be the result of evaluating _Statement_.  \n   5. If _stmt_.value is not empty, let _V_ \\=_stmt_.value.  \n   6. If _stmt_.type is break and _stmt_.target is in the current label set, return (normal, _V_, empty).  \n   7. If _stmt_.type is not **continue** || _stmt_.target is not in the current label set, then  \n         1. If _stmt_ is an [abrupt completion](#sec-8.9), return _stmt_.\n\nThe production  \nIterationStatement : `for` `(` `var` VariableDeclarationNoIn `in` Expression `)` Statement  \nis evaluated as follows:\n\n1. Let _varName_ be the result of evaluating _VariableDeclarationNoIn_.\n2. Let _exprRef_ be the result of evaluating the _Expression_.\n3. Let _experValue_ be [GetValue](#sec-8.7.1)(_exprRef_).\n4. If _experValue_ is **null** or **undefined**, return (normal,empty, empty).\n5. Let _obj_ be [ToObject](#sec-9.9)(_experValue_).\n6. Let _V_ \\= empty.\n7. Repeat  \n   1. Let _P_ be the name of the next property of _obj_ whose \\[\\[Enumerable\\]\\] attribute is **true**. If there is no such property, return (normal, _V_, empty).  \n   2. Let _varRef_ be the result of evaluating _varName_ as if it were an Identifier [Reference](#sec-8.7) ([11.1.2](#sec-11.1.2)); it may be evaluated repeatedly.  \n   3. Call [PutValue](#sec-8.7.2)(_varRef_, _P_).  \n   4. Let _stmt_ be the result of evaluating _Statement_.  \n   5. If _stmt_.value is not empty, let _V_ \\=_stmt_.value.  \n   6. If _stmt_.type is break and _stmt_.target is in the current label set, return (normal, _V_, empty).  \n   7. If _stmt_.type is not continue || _stmt_.target is not in the current label set, then  \n         1. If _stmt_ is an [abrupt completion](#sec-8.9), return _stmt_.\n\nThe mechanics and order of enumerating the properties (step 6.a in the first algorithm, step 7.a in the second) is not specified. Properties of the object being enumerated may be deleted during enumeration. If a property that has not yet been visited during enumeration is deleted, then it will not be visited. If new properties are added to the object being enumerated during enumeration, the newly added properties are not guaranteed to be visited in the active enumeration. A property name must not be visited more than once in any enumeration.\n\nEnumerating the properties of an object includes enumerating properties of its prototype, and the prototype of the prototype, and so on, recursively; but a property of a prototype is not enumerated if it is “shadowed” because some previous object in the prototype chain has a property with the same name. The values of \\[\\[Enumerable\\]\\] attributes are not considered when determining if a property of a prototype object is shadowed by a previous object on the prototype chain.\n\nNOTE See NOTE 11.13.1.\n\n# [12.7](#sec-12.7 \"link to this section\") The continue Statement\n\n## Syntax\n\nContinueStatement :\n\n`continue` `;`\n\n`continue` \\[no LineTerminator here\\] Identifier `;`\n\n## Semantics\n\nA program is considered syntactically incorrect if either of the following is true:\n\n* The program contains a `continue` statement without the optional _Identifier_, which is not nested, directly or indirectly (but not crossing function boundaries), within an _IterationStatement_.\n* The program contains a `continue` statement with the optional _Identifier_, where _Identifier_ does not appear in the label set of an enclosing (but not crossing function boundaries) _IterationStatement_.\n\nA ContinueStatement without an Identifier is evaluated as follows:\n\n1. Return (continue, empty, empty).\n\nA ContinueStatement with the optional Identifier is evaluated as follows:\n\n1. Return (continue, empty,_Identifier_).\n\n# [12.8](#sec-12.8 \"link to this section\") The break Statement\n\n## Syntax\n\nBreakStatement :\n\n`break` `;`\n\n`break` \\[no LineTerminator here\\] Identifier `;`\n\n## Semantics\n\nA program is considered syntactically incorrect if either of the following is true:\n\n* The program contains a `break` statement without the optional _Identifier_, which is not nested, directly or indirectly (but not crossing function boundaries), within an _IterationStatement_ or a_SwitchStatement_.\n* The program contains a `break` statement with the optional _Identifier_, where _Identifier_ does not appear in the label set of an enclosing (but not crossing function boundaries) _Statement_.\n\nA BreakStatement without an Identifier is evaluated as follows:\n\n1. Return (break, empty, empty).\n\nA BreakStatement with an Identifier is evaluated as follows:\n\n1. Return (break, empty,_Identifier_).\n\n# [12.9](#sec-12.9 \"link to this section\") The return Statement\n\n## Syntax\n\nReturnStatement :\n\n`return` `;`\n\n`return` \\[no LineTerminator here\\] Expression `;`\n\n## Semantics\n\nAn ECMAScript program is considered syntactically incorrect if it contains a `return` statement that is not within a FunctionBody. A `return` statement causes a function to cease execution and return a value to the caller. If Expression is omitted, the return value is **undefined**. Otherwise, the return value is the value of Expression.\n\nA ReturnStatement is evaluated as follows:\n\n1. If the _Expression_ is not present, return (return, undefined, empty).\n2. Let _exprRef_ be the result of evaluating _Expression_.\n3. Return (return, [GetValue](#sec-8.7.1)(_exprRef_), empty).\n\n# [12.10](#sec-12.10 \"link to this section\") The with Statement\n\n## Syntax\n\nWithStatement :\n\n`with` `(` Expression `)` Statement\n\nThe `with` statement adds an [object environment record](#sec-10.2.1) for a computed object to the [lexical environment](#sec-10.2) of the current execution context. It then executes a statement using this augmented[lexical environment](#sec-10.2). Finally, it restores the original [lexical environment](#sec-10.2).\n\n## Semantics\n\nThe production WithStatement : `with` `(` Expression `)` Statement is evaluated as follows:\n\n1. Let _val_ be the result of evaluating _Expression_.\n2. Let _obj_ be [ToObject](#sec-9.9)([GetValue](#sec-8.7.1)(_val_)).\n3. Let _oldEnv_ be the running execution context’s [LexicalEnvironment](#sec-10.3).\n4. Let _newEnv_ be the result of calling [NewObjectEnvironment](#sec-10.2.2.3) passing _obj_ and_oldEnv_ as the arguments.\n5. Set the _provideThis_ flag of _newEnv_ to **true**.\n6. Set the running execution context’s [LexicalEnvironment](#sec-10.3) to _newEnv_.\n7. Let _C_ be the result of evaluating _Statement_ but if an exception is thrown during the evaluation, let_C_ be (throw, _V_, empty), where _V_ is the exception. (Execution now proceeds as if no exception were thrown.)\n8. Set the running execution context’s [Lexical Environment](#sec-10.2) to _oldEnv_.\n9. Return _C_.\n\nNOTE No matter how control leaves the embedded Statement, whether normally or by some form of [abrupt completion](#sec-8.9) or exception, the [LexicalEnvironment](#sec-10.3) is always restored to its former state.\n\n# [12.10.1](#sec-12.10.1 \"link to this section\") Strict Mode Restrictions\n\nStrict mode code may not include a WithStatement. The occurrence of a WithStatement in such a context is treated as a **SyntaxError**.\n\n# [12.11](#sec-12.11 \"link to this section\") The switch Statement\n\n## Syntax\n\nSwitchStatement :\n\n`switch` `(` Expression `)` CaseBlock\n\nCaseBlock :\n\n`{` CaseClausesopt `}`\n\n`{` CaseClausesopt DefaultClause CaseClausesopt `}`\n\nCaseClauses :\n\nCaseClause\n\nCaseClauses CaseClause\n\nCaseClause :\n\n`case` Expression `:` StatementListopt\n\nDefaultClause :\n\n`default` `:` StatementListopt\n\n## Semantics\n\nThe production SwitchStatement : `switch` `(` Expression `)` CaseBlock is evaluated as follows:\n\n1. Let _exprRef_ be the result of evaluating _Expression_.\n2. Let _R_ be the result of evaluating _CaseBlock_, passing it [GetValue](#sec-8.7.1)(_exprRef_) as a parameter.\n3. If _R_.type is break and _R_.target is in the current label set, return (normal, _R_.value, empty).\n4. Return _R_.\n\nThe production CaseBlock : `{` CaseClausesopt `}` is given an input parameter,input, and is evaluated as follows:\n\n1. Let _V_ \\= empty.\n2. Let _A_ be the list of _CaseClause_ items in source text order.\n3. Let _searching_ be **true**.\n4. Repeat, while _searching_ is **true**  \n   1. Let _C_ be the next _CaseClause_ in _A_. If there is no such _CaseClause_, return (normal, _V_, empty).  \n   2. Let _clauseSelector_ be the result of evaluating _C_.  \n   3. If _input_ is equal to _clauseSelector_ as defined by the \\=== operator, then  \n         1. Set _searching_ to **false**.  \n         2. If _C_ has a _StatementList_, then  \n                  1. Evaluate _C_’s _StatementList_ and let _R_ be the result.  \n                  2. If _R_ is an [abrupt completion](#sec-8.9), then return _R_.  \n                  3. Let _V_ \\= _R_.value.\n5. Repeat  \n   1. Let _C_ be the next _CaseClause_ in _A_. If there is no such _CaseClause_, return **(**normal, _V_, empty).  \n   2. If _C_ has a _StatementList_, then  \n         1. Evaluate _C_’s _StatementList_ and let _R_ be the result.  \n         2. If _R_.value is not empty, then let _V_ \\=_R_.value.  \n         3. If _R_ is an [abrupt completion](#sec-8.9), then return _(R_.type, _V_,_R_.target).\n\nThe production CaseBlock : `{` CaseClausesopt DefaultClause CaseClausesopt `}` is given an input parameter, input, and is evaluated as follows:\n\n1. Let _V_ \\= empty.\n2. Let _A_ be the list of _CaseClause_ items in the first _CaseClauses_, in source text order.\n3. Let _B_ be the list of _CaseClause_ items in the second _CaseClauses_, in source text order.\n4. Let _found_ be **false**.\n5. Repeat letting _C_ be in order each _CaseClause_ in _A_  \n   1. If _found_ is **false**, then  \n         1. Let _clauseSelector_ be the result of evaluating _C_.  \n         2. If _input_ is equal to _clauseSelector_ as defined by the \\=== operator, then set _found_ to **true**.  \n   2. If _found_ is **true**, then  \n         1. If _C_ has a _StatementList_, then  \n                  1. Evaluate _C_’s _StatementList_ and let _R_ be the result.  \n                  2. If _R_.value is not empty, then let _V_ \\=_R_.value.  \n                  3. _R_ is an [abrupt completion](#sec-8.9), then return _(R_.type, _V_,_R_.target).\n6. Let _foundInB_ be **false**.\n7. If _found_ is **false**, then  \n   1. Repeat, while _foundInB_ is **false** and all elements of _B_ have not been processed  \n         1. Let _C_ be the next _CaseClause_ in _B_.  \n         2. Let _clauseSelector_ be the result of evaluating _C_.  \n         3. If _input_ is equal to _clauseSelector_ as defined by the \\=== operator, then  \n                  1. Set _foundInB_ to **true**.  \n                  2. If _C_ has a _StatementList_, then  \n                              1. Evaluate _C_’s _StatementList_ and let _R_ be the result.  \n                              2. If _R_.value is not empty, then let _V_ \\=_R_.value.  \n                              3. _R_ is an [abrupt completion](#sec-8.9), then return _(R_.type, _V_,_R_.target).\n8. If _foundInB_ is **false** and the _DefaultClause_ has a _StatementList_, then  \n   1. Evaluate the _DefaultClause’s_ _StatementList_ and let _R_ be the result.  \n   2. If _R_.value is not empty, then let _V_ \\=_R_.value.  \n   3. If _R_ is an [abrupt completion](#sec-8.9), then return (_R_.type, _V_,_R_.target).\n9. Repeat (Note that if step 7.a.i has been performed this loop does not start at the beginning of _B_)  \n   1. Let _C_ be the next _CaseClause_ in _B_. If there is no such _CaseClause_, return (normal, _V_, empty).  \n   2. If _C_ has a _StatementList_, then  \n         1. Evaluate _C_’s _StatementList_ and let _R_ be the result.  \n         2. If _R_.value is not empty, then let _V_ \\=_R_.value.  \n         3. If _R_ is an [abrupt completion](#sec-8.9), then return (_R_.type, _V_,_R_.target).\n\nThe production CaseClause : `case` Expression `:` StatementListopt is evaluated as follows:\n\n1. Let _exprRef_ be the result of evaluating _Expression_.\n2. Return [GetValue](#sec-8.7.1)(_exprRef_).\n\nNOTE Evaluating CaseClause does not execute the associated StatementList. It simply evaluates the Expression and returns the value, which theCaseBlock algorithm uses to determine which StatementList to start executing.\n\n# [12.12](#sec-12.12 \"link to this section\") Labelled Statements\n\n## Syntax\n\nLabelledStatement :\n\nIdentifier `:` Statement\n\n## Semantics\n\nA Statement may be prefixed by a label. Labelled statements are only used in conjunction with labelled `break` and `continue` statements. ECMAScript has no `goto` statement.\n\nAn ECMAScript program is considered syntactically incorrect if it contains a LabelledStatement that is enclosed by a LabelledStatement with the same Identifier as label. This does not apply to labels appearing within the body of a FunctionDeclaration that is nested, directly or indirectly, within a labelled statement.\n\nThe production Identifier : Statement is evaluated by adding Identifier to the label set of Statement and then evaluating Statement. If the LabelledStatement itself has a non-empty label set, these labels are also added to the label set of Statement before evaluating it. If the result of evaluating Statement is (**break**, V, L) where L is equal to Identifier, the production results in (**normal**, V, **empty**).\n\nPrior to the evaluation of a LabelledStatement, the contained Statement is regarded as possessing an empty label set, unless it is an IterationStatement or a SwitchStatement, in which case it is regarded as possessing a label set consisting of the single element,**empty**.\n\n# [12.13](#sec-12.13 \"link to this section\") The throw Statement\n\n## Syntax\n\nThrowStatement :\n\n`throw` \\[no LineTerminator here\\] Expression `;`\n\n## Semantics\n\nThe production ThrowStatement : `throw` \\[no LineTerminator here\\] Expression `;` is evaluated as follows:\n\n1. Let _exprRef_ be the result of evaluating _Expression_.\n2. Return (throw, [GetValue](#sec-8.7.1)(_exprRef_), empty).\n\n# [12.14](#sec-12.14 \"link to this section\") The try Statement\n\n## Syntax\n\nTryStatement :\n\n`try` Block Catch\n\n`try` Block Finally\n\n`try` Block Catch Finally\n\nCatch :\n\n`catch` `(` Identifier `)` Block\n\nFinally :\n\n`finally` Block\n\nThe `try` statement encloses a block of code in which an exceptional condition can occur, such as a runtime error or a `throw` statement. The `catch` clause provides the exception-handling code. When a catch clause catches an exception, its Identifier is bound to that exception.\n\n## Semantics\n\nThe production TryStatement : `try` Block Catch is evaluated as follows:\n\n1. Let _B_ be the result of evaluating _Block_.\n2. If _B_.type is not throw, return _B_.\n3. Return the result of evaluating _Catch_ with parameter _B_.value.\n\nThe production TryStatement : `try` Block Finally is evaluated as follows:\n\n1. Let _B_ be the result of evaluating _Block_.\n2. Let _F_ be the result of evaluating _Finally_.\n3. If _F_.type is normal, return _B_.\n4. Return _F_.\n\nThe production TryStatement : `try` Block Catch Finally is evaluated as follows:\n\n1. Let _B_ be the result of evaluating _Block_.\n2. If _B_.type is throw, then  \n   1. Let _C_ be the result of evaluating _Catch_ with parameter _B_.value.\n3. Else, _B_.type is not throw**,**  \n   1. Let _C_ be _B_.\n4. Let _F_ be the result of evaluating _Finally_.\n5. If _F_.type is normal, return _C_.\n6. Return _F_.\n\nThe production Catch : `catch` `(` Identifier `)` Block is evaluated as follows:\n\n1. Let _C_ be the parameter that has been passed to this production.\n2. Let _oldEnv_ be the running execution context’s [LexicalEnvironment](#sec-10.3).\n3. Let _catchEnv_ be the result of calling [NewDeclarativeEnvironment](#sec-10.2.2.2) passing _oldEnv_ as the argument.\n4. Call the CreateMutableBinding concrete method of _catchEnv_ passing the _Identifier_ String value as the argument.\n5. Call the SetMutableBinding concrete method of _catchEnv_ passing the _Identifier_, _C_, and **false** as arguments. Note that the last argument is immaterial in this situation.\n6. Set the running execution context’s [LexicalEnvironment](#sec-10.3) to _catchEnv_.\n7. Let _B_ be the result of evaluating _Block_.\n8. Set the running execution context’s [LexicalEnvironment](#sec-10.3) to _oldEnv_.\n9. Return _B_.\n\nNOTE No matter how control leaves the Block the [LexicalEnvironment](#sec-10.3) is always restored to its former state.\n\nThe production Finally : `finally` Block is evaluated as follows:\n\n1. Return the result of evaluating _Block_.\n\n# [12.14.1](#sec-12.14.1 \"link to this section\") Strict Mode Restrictions\n\nIt is a **SyntaxError** if a TryStatement with a Catch occurs within[strict code](#sec-10.1.1) and the Identifier of the Catch production is either `\"eval\"` **or \"arguments\"**.\n\n# [12.15](#sec-12.15 \"link to this section\") The debugger statement\n\n## Syntax\n\nDebuggerStatement :\n\n`debugger` `;`\n\n## Semantics\n\nEvaluating the DebuggerStatement production may allow an implementation to cause a breakpoint when run under a debugger. If a debugger is not present or active this statement has no observable effect.\n\nThe production DebuggerStatement : `debugger` `;` is evaluated as follows:\n\n1. If an implementation defined debugging facility is available and enabled, then  \n   1. Perform an implementation defined debugging action.  \n   2. Let _result_ be an implementation defined [Completion](#sec-8.9) value.\n2. Else  \n   1. Let _result_ be (normal, empty, empty).\n3. Return _result_."}