{"lang":"JavascriptES5","category":"","fullPath":"","title":"9 Type Conversion and Testing9.1 ToPrimitive9.2 ToBoolean9.3 ToNumber9.3.1 ToNumber Applied to the String\n          Type9.4 ToInteger9.5 ToInt32: (Signed 32 Bit Integer)9.6 ToUint32: (Unsigned 32 Bit\n        Integer)9.7 ToUint16: (Unsigned 16 Bit\n        Integer)9.8 ToString9.8.1 ToString Applied to the Number\n          Type9.9 ToObject9.10 CheckObjectCoercible9.11 IsCallable9.12 The SameValue Algorithm","markdown":"# [9](#sec-9 \"link to this section\") Type Conversion and Testing\n\nThe ECMAScript runtime system performs automatic type conversion as needed. To clarify the semantics of certain constructs it is useful to define a set of conversion abstract operations. These abstract operations are not a part of the language; they are defined here to aid the specification of the semantics of the language. The conversion abstract operations are polymorphic; that is, they can accept a value of any ECMAScript language type, but not of specification types.\n\n# [9.1](#sec-9.1 \"link to this section\") ToPrimitive\n\nThe abstract operation ToPrimitive takes an input argument and an optional argument PreferredType. The abstract operation ToPrimitive converts its input argument to a non-Object type. If an object is capable of converting to more than one primitive type, it may use the optional hint PreferredType to favour that type. Conversion occurs according to Table 10:\n\nTable 10 — ToPrimitive Conversions\n\n| Input Type | Result                                                                                                                                                                                                                                                                                                                                                |\n| ---------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Undefined  | The result equals the input argument (no conversion).                                                                                                                                                                                                                                                                                                 |\n| Null       | The result equals the input argument (no conversion).                                                                                                                                                                                                                                                                                                 |\n| Boolean    | The result equals the input argument (no conversion).                                                                                                                                                                                                                                                                                                 |\n| Number     | The result equals the input argument (no conversion).                                                                                                                                                                                                                                                                                                 |\n| String     | The result equals the input argument (no conversion).                                                                                                                                                                                                                                                                                                 |\n| Object     | Return a default value for the Object. The default value of an object is retrieved by calling the \\[\\[DefaultValue\\]\\] internal method of the object, passing the optional hint PreferredType. The behaviour of the \\[\\[DefaultValue\\]\\] internal method is defined by this specification for all native ECMAScript objects in [8.12.8](#sec-8.12.8). |\n\n# [9.2](#sec-9.2 \"link to this section\") ToBoolean\n\nThe abstract operation ToBoolean converts its argument to a value of type Boolean according to Table 11:\n\nTable 11 — ToBoolean Conversions\n\n| Argument Type | Result                                                                                                              |\n| ------------- | ------------------------------------------------------------------------------------------------------------------- |\n| Undefined     | **false**                                                                                                           |\n| Null          | **false**                                                                                                           |\n| Boolean       | The result equals the input argument (no conversion).                                                               |\n| Number        | The result is **false** if the argument is **+0**, **−0**, or **NaN**; otherwise the result is **true**.            |\n| String        | The result is **false** if the argument is the empty String (its length is zero); otherwise the result is **true**. |\n| Object        | **true**                                                                                                            |\n\n# [9.3](#sec-9.3 \"link to this section\") ToNumber\n\nThe abstract operation ToNumber converts its argument to a value of type Number according to Table 12:\n\nTable 12 — To Number Conversions\n\n| Argument Type | Result                                                                                                                              |\n| ------------- | ----------------------------------------------------------------------------------------------------------------------------------- |\n| Undefined     | **NaN**                                                                                                                             |\n| Null          | **+0**                                                                                                                              |\n| Boolean       | The result is **1** if the argument is **true**. The result is **+0** if the argument is **false**.                                 |\n| Number        | The result equals the input argument (no conversion).                                                                               |\n| String        | See grammar and note below.                                                                                                         |\n| Object        | Apply the following steps: Let _primValue_ be [ToPrimitive](#sec-9.1)(_input argument_, hint Number). Return ToNumber(_primValue_). |\n\n# [9.3.1](#sec-9.3.1 \"link to this section\") ToNumber Applied to the String Type\n\n[ToNumber](#sec-9.3) applied to Strings applies the following grammar to the input String. If the grammar cannot interpret the String as an expansion of StringNumericLiteral, then the result of [ToNumber](#sec-9.3) is **NaN**.\n\n## Syntax\n\nStringNumericLiteral :::\n\nStrWhiteSpaceopt\n\nStrWhiteSpaceopt StrNumericLiteral StrWhiteSpaceopt\n\nStrWhiteSpace :::\n\nStrWhiteSpaceChar StrWhiteSpaceopt\n\nStrWhiteSpaceChar :::\n\nWhiteSpace\n\nLineTerminator\n\nStrNumericLiteral :::\n\nStrDecimalLiteral\n\nHexIntegerLiteral\n\nStrDecimalLiteral :::\n\nStrUnsignedDecimalLiteral\n\n`+` StrUnsignedDecimalLiteral\n\n`-` StrUnsignedDecimalLiteral\n\nStrUnsignedDecimalLiteral :::\n\nInfinity\n\nDecimalDigits `.` DecimalDigitsopt ExponentPartopt\n\n`.` DecimalDigits ExponentPartopt\n\nDecimalDigits ExponentPartopt\n\nDecimalDigits :::\n\nDecimalDigit\n\nDecimalDigits DecimalDigit\n\nDecimalDigit ::: one of\n\n`0` `1` `2` `3` `4` `5` `6` `7` `8` `9`\n\nExponentPart :::\n\nExponentIndicator SignedInteger\n\nExponentIndicator ::: one of\n\n`e` `E`\n\nSignedInteger :::\n\nDecimalDigits\n\n`+` DecimalDigits\n\n`-` DecimalDigits\n\nHexIntegerLiteral :::\n\n`0x` HexDigit\n\n`0X` HexDigit\n\nHexIntegerLiteral HexDigit\n\nHexDigit ::: one of\n\n`0` `1` `2` `3` `4` `5` `6` `7` `8` `9` `a` `b` `c` `d` `e` `f` `A` `B` `C` `D` `E` `F`\n\nSome differences should be noted between the syntax of a StringNumericLiteral and a NumericLiteral ([see 7.8.3](#sec-7.8.3)):\n\n* A StringNumericLiteral may be preceded and/or followed by white space and/or line terminators.\n* A StringNumericLiteral that is decimal may have any number of leading `0` digits.\n* A StringNumericLiteral that is decimal may be preceded by `+` or `-` to indicate its sign.\n* A StringNumericLiteral that is empty or contains only white space is converted to**+0**.\n\nThe conversion of a String to a Number value is similar overall to the determination of the Number value for a numeric literal ([see 7.8.3](#sec-7.8.3)), but some of the details are different, so the process for converting a String numeric literal to a value of Number type is given here in full. This value is determined in two steps: first, a mathematical value (MV) is derived from the String numeric literal; second, this mathematical value is rounded as described below.\n\n* The MV of StringNumericLiteral ::: \\[empty\\] is 0.\n* The MV of StringNumericLiteral ::: StrWhiteSpace is 0.\n* The MV of StringNumericLiteral ::: StrWhiteSpaceopt StrNumericLiteral StrWhiteSpaceopt is the MV of StrNumericLiteral, no matter whether white space is present or not.\n* The MV of StrNumericLiteral ::: StrDecimalLiteral is the MV of StrDecimalLiteral.\n* The MV of StrNumericLiteral ::: HexIntegerLiteral is the MV of HexIntegerLiteral.\n* The MV of StrDecimalLiteral ::: StrUnsignedDecimalLiteral is the MV of StrUnsignedDecimalLiteral.\n* The MV of StrDecimalLiteral ::: `+` StrUnsignedDecimalLiteral is the MV of StrUnsignedDecimalLiteral.\n* The MV of StrDecimalLiteral ::: `-` StrUnsignedDecimalLiteral is the negative of the MV of StrUnsignedDecimalLiteral. (Note that if the MV of StrUnsignedDecimalLiteral is 0, the negative of this MV is also 0\\. The rounding rule described below handles the conversion of this signless mathematical zero to a floating-point **+0** or **−0** as appropriate.)\n* The MV of StrUnsignedDecimalLiteral ::: Infinity is 1010000 (a value so large that it will round to **+∞**).\n* The MV of StrUnsignedDecimalLiteral ::: DecimalDigits `.` is the MV of DecimalDigits.\n* The MV of StrUnsignedDecimalLiteral ::: DecimalDigits `.` DecimalDigits is the MV of the first DecimalDigits plus (the MV of the second DecimalDigits times 10−_n_), where n is the number of characters in the second DecimalDigits.\n* The MV of StrUnsignedDecimalLiteral ::: DecimalDigits `.` ExponentPart is the MV of_DecimalDigits_ times 10_e_, where _e_ is the MV of _ExponentPart_.\n* The MV of StrUnsignedDecimalLiteral ::: DecimalDigits `.` DecimalDigits ExponentPart is (the MV of the first _DecimalDigits_ plus (the MV of the second_DecimalDigits_ times 10−_n_)) times 10_e_, where _n_ is the number of characters in the second _DecimalDigit_s and _e_ is the MV of _ExponentPart_.\n* The MV of StrUnsignedDecimalLiteral ::: `.` DecimalDigits is the MV of _DecimalDigits_ times 10−_n_, where _n_ is the number of characters in _DecimalDigit_s.\n* The MV of StrUnsignedDecimalLiteral ::: `.` DecimalDigits ExponentPart is the MV of_DecimalDigits_ times 10_e_−_n_, where _n_ is the number of characters in_DecimalDigit_s and _e_ is the MV of _ExponentPart_.\n* The MV of StrUnsignedDecimalLiteral ::: DecimalDigits is the MV of _DecimalDigits_.\n* The MV of StrUnsignedDecimalLiteral ::: DecimalDigits ExponentPart is the MV of _DecimalDigits_ times 10_e_, where _e_ is the MV of _ExponentPart_.\n* The MV of DecimalDigits ::: DecimalDigit is the MV of _DecimalDigit_.\n* The MV of DecimalDigits ::: DecimalDigits DecimalDigit is (the MV of _DecimalDigits_ times 10) plus the MV of _DecimalDigit_.\n* The MV of ExponentPart ::: ExponentIndicator SignedInteger is the MV of _SignedInteger_.\n* The MV of SignedInteger ::: DecimalDigits is the MV of _DecimalDigits_.\n* The MV of SignedInteger ::: `+` DecimalDigits is the MV of _DecimalDigits_.\n* The MV of SignedInteger ::: `-` DecimalDigits is the negative of the MV of _DecimalDigits_.\n* The MV of DecimalDigit ::: `0` or of HexDigit ::: `0` is 0.\n* The MV of DecimalDigit ::: `1` or of HexDigit ::: `1` is 1.\n* The MV of DecimalDigit ::: `2` or of HexDigit ::: `2` is 2.\n* The MV of DecimalDigit ::: `3` or of HexDigit ::: `3` is 3.\n* The MV of DecimalDigit ::: `4` or of HexDigit ::: `4` is 4.\n* The MV of DecimalDigit ::: `5` or of HexDigit ::: `5` is 5.\n* The MV of DecimalDigit ::: `6` or of HexDigit ::: `6` is 6.\n* The MV of DecimalDigit ::: `7` or of HexDigit ::: `7` is 7.\n* The MV of DecimalDigit ::: `8` or of HexDigit ::: `8` is 8.\n* The MV of DecimalDigit ::: `9` or of HexDigit ::: `9` is 9.\n* The MV of HexDigit ::: `a` or of HexDigit ::: `A` is 10.\n* The MV of HexDigit ::: `b` or of HexDigit ::: `B` is 11.\n* The MV of HexDigit ::: `c` or of HexDigit ::: `C` is 12.\n* The MV of HexDigit ::: `d` or of HexDigit ::: `D` is 13.\n* The MV of HexDigit ::: `e` or of HexDigit ::: `E` is 14.\n* The MV of HexDigit ::: `f` or of HexDigit ::: `F` is 15.\n* The MV of HexIntegerLiteral ::: `0x` HexDigit is the MV of _HexDigit_.\n* The MV of HexIntegerLiteral ::: `0X` HexDigit is the MV of _HexDigit_.\n* The MV of HexIntegerLiteral ::: HexIntegerLiteral HexDigit is (the MV of _HexIntegerLiteral_ times 16) plus the MV of _HexDigit_.\n\nOnce the exact MV for a String numeric literal has been determined, it is then rounded to a value of the Number type. If the MV is 0, then the rounded value is +0 unless the first non white space character in the String numeric literal is ‘`-`’, in which case the rounded value is −0\\. Otherwise, the rounded value must be the Number value for the MV (in the sense defined in [8.5](#sec-8.5)), unless the literal includes a StrUnsignedDecimalLiteral and the literal has more than 20 significant digits, in which case the Number value may be either the Number value for the MV of a literal produced by replacing each significant digit after the 20th with a 0 digit or the Number value for the MV of a literal produced by replacing each significant digit after the 20th with a 0 digit and then incrementing the literal at the 20th digit position. A digit is _significant_ if it is not part of an ExponentPart and\n\n* it is not **0**; or\n* there is a nonzero digit to its left and there is a nonzero digit, not in the ExponentPart, to its right.\n\n# [9.4](#sec-9.4 \"link to this section\") ToInteger\n\nThe abstract operation ToInteger converts its argument to an integral numeric value. This abstract operation functions as follows:\n\n1. Let _number_ be the result of calling [ToNumber](#sec-9.3) on the input argument.\n2. If _number_ is **NaN**, return **+0**.\n3. If _number_ is **+0**, **−0**, **+∞,** or **−∞**, return _number_.\n4. Return the result of computing [sign](#sec-5.2)(_number_) × [floor](#sec-5.2)([abs](#sec-5.2)(_number_)).\n\n# [9.5](#sec-9.5 \"link to this section\") ToInt32: (Signed 32 Bit Integer)\n\nThe abstract operation ToInt32 converts its argument to one of 232 integer values in the range −231 through 231−1, inclusive. This abstract operation functions as follows:\n\n1. Let _number_ be the result of calling [ToNumber](#sec-9.3) on the input argument.\n2. If _number_ is **NaN**, **+0**, **−0**, **+∞**, or **−∞**, return**+0**.\n3. Let _posInt_ be [sign](#sec-5.2)(_number_) \\* [floor](#sec-5.2)([abs](#sec-5.2)(_number_)).\n4. Let _int32bit_ be _posInt_ [modulo](#sec-5.2) 232; that is, a finite integer value k of Number type with positive sign and less than 232 in magnitude such that the mathematical difference of_posInt_ and k is mathematically an integer multiple of 232.\n5. If _int32bit_ is greater than or equal to 231, return _int32bit_ − 232, otherwise return _int32bit_.\n\nNOTE Given the above definition of ToInt32:\n\n* The ToInt32 abstract operation is idempotent: if applied to a result that it produced, the second application leaves that value unchanged.\n* ToInt32([ToUint32](#sec-9.6)(x)) is equal to ToInt32(_x_) for all values of x. (It is to preserve this latter property that +**∞** and −**∞** are mapped to **+0**.)\n* ToInt32 maps **−0** to **+0**.\n\n# [9.6](#sec-9.6 \"link to this section\") ToUint32: (Unsigned 32 Bit Integer)\n\nThe abstract operation ToUint32 converts its argument to one of 232 integer values in the range 0 through 232−1, inclusive. This abstraction operation functions as follows:\n\n1. Let _number_ be the result of calling [ToNumber](#sec-9.3) on the input argument.\n2. If _number_ is **NaN**, +0, −0, +**∞**, or −**∞**, return **+0**.\n3. Let _posInt_ be [sign](#sec-5.2)(_number_) × [floor](#sec-5.2)([abs](#sec-5.2)(_number_)).\n4. Let _int32bit_ be _posInt_ [modulo](#sec-5.2) 232; that is, a finite integer value k of Number type with positive sign and less than 232 in magnitude such that the mathematical difference of_posInt_ and k is mathematically an integer multiple of 232.\n5. Return _int32bit_.\n\nNOTE Given the above definition of ToUInt32:\n\n* Step 5 is the only difference between ToUint32 and [ToInt32](#sec-9.5).\n* The ToUint32 abstract operation is idempotent: if applied to a result that it produced, the second application leaves that value unchanged.\n* ToUint32([ToInt32](#sec-9.5)(_x_)) is equal toToUint32(_x_) for all values of x. (It is to preserve this latter property that **+∞** and **−∞** are mapped to **+0**.)\n* ToUint32 maps **−0** to **+0**.\n\n# [9.7](#sec-9.7 \"link to this section\") ToUint16: (Unsigned 16 Bit Integer)\n\nThe abstract operation ToUint16 converts its argument to one of 216 integer values in the range 0 through 216−1, inclusive. This abstract operation functions as follows:\n\n1. Let _number_ be the result of calling [ToNumber](#sec-9.3) on the input argument.\n2. If _number_ is **NaN**, +0, −0, +**∞**, or −**∞**, return **+0**.\n3. Let _posInt_ be [sign](#sec-5.2)(_number_) × [floor](#sec-5.2)([abs](#sec-5.2)(_number_)).\n4. Let _int16bit_ be _posInt_ [modulo](#sec-5.2) 216; that is, a finite integer value_k_ of Number type with positive sign and less than 216 in magnitude such that the mathematical difference of _posInt_ and _k_ is mathematically an integer multiple of 216.\n5. Return _int16bit_.\n\nNOTE Given the above definition of ToUint16:\n\n* The substitution of 216 for 232 in step 4 is the only difference between [ToUint32](#sec-9.6) and ToUint16.\n* ToUint16 maps **−0** to **+0**.\n\n# [9.8](#sec-9.8 \"link to this section\") ToString\n\nThe abstract operation ToString converts its argument to a value of type String according to Table 13:\n\nTable 13 — ToString Conversions\n\n| Argument Type | Result                                                                                                                                    |\n| ------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |\n| Undefined     | \"undefined\"                                                                                                                               |\n| Null          | \"null\"                                                                                                                                    |\n| Boolean       | If the argument is **true**, then the result is \"true\". If the argument is **false**, then the result is **\"false\".**                     |\n| Number        | See [9.8.1](#sec-9.8.1).                                                                                                                  |\n| String        | Return the input argument (no conversion)                                                                                                 |\n| Object        | Apply the following steps: 1\\. Let _primValue_ be [ToPrimitive](#sec-9.1)(input argument, hint String). 2\\. Return ToString(_primValue_). |\n\n# [9.8.1](#sec-9.8.1 \"link to this section\") ToString Applied to the Number Type\n\nThe abstract operation [ToString](#sec-9.8) converts a Number m to String format as follows:\n\n1. If _m_ is **NaN**, return the String `\"NaN\"`.\n2. If _m_ is **+0** or **−0**, return the String `\"0\"`.\n3. If _m_ is less than zero, return the String concatenation of the String `\"-\"` and [ToString](#sec-9.8)(−_m_).\n4. If _m_ is infinity, return the String `\"Infinity\"`.\n5. Otherwise, let _n_, _k_, and _s_ be integers such that _k_ ≥ 1, 10_k_−1 ≤ _s_ < 10_k_, the Number value for _s_ × 10_n−k_ is_m_, and _k_ is as small as possible. Note that _k_ is the number of digits in the decimal representation of _s_, that _s_ is not divisible by 10, and that the least significant digit of _s_ is not necessarily uniquely determined by these criteria.\n6. If _k_ ≤ _n_ ≤ 21, return the String consisting of the _k_ digits of the decimal representation of s (in order, with no leading zeroes), followed by _n−k_ occurrences of the character ‘`0`’.\n7. If 0 < n ≤ 21, return the String consisting of the most significant _n_ digits of the decimal representation of _s_, followed by a decimal point ‘`.`’, followed by the remaining_k−n_ digits of the decimal representation of _s_.\n8. If −6 < n ≤ 0, return the String consisting of the character ‘`0`’, followed by a decimal point ‘`.`’, followed by −_n_ occurrences of the character ‘`0`’, followed by the _k_ digits of the decimal representation of _s_.\n9. Otherwise, if _k_ \\= 1, return the String consisting of the single digit of _s_, followed by lowercase character ‘`e`’, followed by a plus sign ‘`+`’ or minus sign ‘`−`’ according to whether _n_−1 is positive or negative, followed by the decimal representation of the integer [abs](#sec-5.2)(_n_−1) (with no leading zeroes).\n10. Return the String consisting of the most significant digit of the decimal representation of _s_, followed by a decimal point ‘.’, followed by the remaining _k_−1 digits of the decimal representation of_s_, followed by the lowercase character ‘`e`’, followed by a plus sign ‘`+`’ or minus sign ‘`−`’ according to whether _n_−1 is positive or negative, followed by the decimal representation of the integer [abs](#sec-5.2)(_n_−1) (with no leading zeroes).\n\nNOTE 1 The following observations may be useful as guidelines for implementations, but are not part of the normative requirements of this Standard:\n\n* If x is any Number value other than **−0**, then [ToNumber](#sec-9.3)([ToString](#sec-9.8)(x)) is exactly the same Number value as x.\n* The least significant digit of s is not always uniquely determined by the requirements listed in step 5.\n\nNOTE 2 For implementations that provide more accurate conversions than required by the rules above, it is recommended that the following alternative version of step 5 be used as a guideline:\n\nOtherwise, let _n_, _k_, and _s_ be integers such that _k_ ≥ 1, 10_k_−1 ≤ _s_ < 10_k_, the Number value for _s_ × 10_n_−_k_ is_m_, and _k_ is as small as possible. If there are multiple possibilities for _s_, choose the value of_s_ for which _s_ × 10_n_−_k_ is closest in value to _m_. If there are two such possible values of _s_, choose the one that is even. Note that _k_ is the number of digits in the decimal representation of _s_ and that _s_ is not divisible by 10.\n\nNOTE 3 Implementers of ECMAScript may find useful the paper and code written by David M. Gay for binary-to-decimal conversion of floating-point numbers:\n\nGay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary Conversions. Numerical Analysis, Manuscript 90-10\\. AT&T Bell Laboratories (Murray Hill, New Jersey). November 30, 1990\\. Available as  \n<http://cm.bell-labs.com/cm/cs/doc/90/4-10.ps.g>z. Associated code available as  \n<http://cm.bell-labs.com/netlib/fp/dtoa.c.gz> and as  \n<http://cm.bell-labs.com/netlib/fp/g%5Ffmt.c.gz> and may also be found at the various `netlib` mirror sites.\n\n# [9.9](#sec-9.9 \"link to this section\") ToObject\n\nThe abstract operation ToObject converts its argument to a value of type Object according to Table 14:\n\nTable 14 — ToObject\n\n| Argument Type | Result                                                                                                                                                                      |\n| ------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| Undefined     | Throw a **TypeError** exception.                                                                                                                                            |\n| Null          | Throw a **TypeError** exception.                                                                                                                                            |\n| Boolean       | Create a new Boolean object whose \\[\\[PrimitiveValue\\]\\] internal property is set to the value of the argument. See [15.6](#sec-15.6) for a description of Boolean objects. |\n| Number        | Create a new Number object whose \\[\\[PrimitiveValue\\]\\] internal property is set to the value of the argument. See [15.7](#sec-15.7) for a description of Number objects.   |\n| String        | Create a new String object whose \\[\\[PrimitiveValue\\]\\] internal property is set to the value of the argument. See [15.5](#sec-15.5) for a description of String objects.   |\n| Object        | The result is the input argument (no conversion).                                                                                                                           |\n\n# [9.10](#sec-9.10 \"link to this section\") CheckObjectCoercible\n\nThe abstract operation CheckObjectCoercible throws an error if its argument is a value that cannot be converted to an Object using [ToObject](#sec-9.9). It is defined by Table 15:\n\nTable 15 — CheckObjectCoercible Results\n\n| Argument Type | Result                           |\n| ------------- | -------------------------------- |\n| Undefined     | Throw a **TypeError** exception. |\n| Null          | Throw a **TypeError** exception. |\n| Boolean       | Return                           |\n| Number        | Return                           |\n| String        | Return                           |\n| Object        | Return                           |\n\n# [9.11](#sec-9.11 \"link to this section\") IsCallable\n\nThe abstract operation IsCallable determines if its argument, which must be an ECMAScript language value, is a callable function Object according to Table 16:\n\nTable 16 — IsCallable Results\n\n| Argument Type | Result                                                                                                       |\n| ------------- | ------------------------------------------------------------------------------------------------------------ |\n| Undefined     | Return **false**.                                                                                            |\n| Null          | Return **false**.                                                                                            |\n| Boolean       | Return **false**.                                                                                            |\n| Number        | Return **false**.                                                                                            |\n| String        | Return **false**.                                                                                            |\n| Object        | If the argument object has a \\[\\[Call\\]\\] internal method, then return **true**, otherwise return **false**. |\n\n# [9.12](#sec-9.12 \"link to this section\") The SameValue Algorithm\n\nThe internal comparison abstract operation SameValue(x, y), where x and y are ECMAScript language values, produces **true** or **false**. Such a comparison is performed as follows:\n\n1. If [Type](#sec-8)(_x_) is different from [Type](#sec-8)(_y_), return **false**.\n2. If [Type](#sec-8)(_x_) is Undefined, return **true**.\n3. If [Type](#sec-8)(_x_) is Null, return **true**.\n4. If [Type](#sec-8)(_x_) is Number, then.  \n   1. If _x_ is NaN and _y_ is NaN, return **true**.  \n   2. If _x_ is +0 and _y_ is -0, return **false**.  \n   3. If _x_ is -0 and _y_ is +0, return **false**.  \n   4. If _x_ is the same Number value as _y_, return **true**.  \n   5. Return **false**.\n5. If [Type](#sec-8)(_x_) is String, then return **true** if _x_ and _y_ are exactly the same sequence of characters (same length and same characters in corresponding positions); otherwise, return**false**.\n6. If [Type](#sec-8)(_x_) is Boolean, return **true** if _x_ and _y_ are both **true** or both **false**; otherwise, return **false**.\n7. Return true if _x_ and _y_ refer to the same object. Otherwise, return **false**."}