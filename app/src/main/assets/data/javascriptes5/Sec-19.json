{"lang":"JavascriptES5","category":"","fullPath":"","title":"Annex C (informative) The Strict Mode of ECMAScript","markdown":"# [Annex C](#sec-C \"link to this section\") (informative) The Strict Mode of ECMAScript\n\n**The strict mode restriction and exceptions**\n\n* The identifiers \"`implements`\", \"`interface`\", \"`let`\", \"`package`\", \"`private`\", \"`protected`\", \"`public`\", \"`static`\", and \"`yield`\" are classified as _FutureReservedWord_ tokens within [strict mode code](#sec-10.1.1). (7.6.12).\n* A conforming implementation, when processing [strict mode code](#sec-10.1.1), may not extend the syntax of_NumericLiteral_ ([7.8.3](#sec-7.8.3)) to include _OctalIntegerLiteral_ as described in [B.1.1](#sec-B.1.1).\n* A conforming implementation, when processing [strict mode code (see 10.1.1)](#sec-10.1.1), may not extend the syntax of _EscapeSequence_ to include _OctalEscapeSequence_ as described in [B.1.2](#sec-B.1.2).\n* Assignment to an undeclared identifier or otherwise unresolvable reference does not create a property in the global object. When a simple assignment occurs within [strict mode code](#sec-10.1.1), its _LeftHandSide_ must not evaluate to an [unresolvable Reference](#sec-8.7). If it does a **ReferenceError** exception is thrown ([8.7.2](#sec-8.7.2)). The _LeftHandSide_ also may not be a reference to a data property with the attribute value {\\[\\[Writable\\]\\]:**false**}, to an accessor property with the attribute value {\\[\\[Set\\]\\]:**undefined**}, nor to a non-existent property of an object whose \\[\\[Extensible\\]\\] internal property has the value **false**. In these cases a`TypeError` exception is thrown ([11.13.1](#sec-11.13.1)).\n* The identifier `eval` or `arguments` may not appear as the _LeftHandSideExpression_ of an Assignment operator ([11.13](#sec-11.13)) or of a _PostfixExpression_ ([11.3](#sec-11.3)) or as the _UnaryExpression_ operated upon by a Prefix Increment ([11.4.4](#sec-11.4.4)) or a Prefix Decrement ([11.4.5](#sec-11.4.5)) operator.\n* Arguments objects for strict mode functions define non-configurable accessor properties named \"`caller`\" and \"`callee`\" which throw a **TypeError** exception on access ([10.6](#sec-10.6)).\n* Arguments objects for strict mode functions do not dynamically share their array indexed property values with the corresponding formal parameter bindings of their functions. ([10.6](#sec-10.6)).\n* For strict mode functions, if an arguments object is created the binding of the local identifier `arguments` to the arguments object is immutable and hence may not be the target of an assignment expression. ([10.5](#sec-10.5)).\n* It is a **SyntaxError** if [strict mode code](#sec-10.1.1) contains an _ObjectLiteral_ with more than one definition of any data property ([11.1.5](#sec-11.1.5)).\n* It is a **SyntaxError** if the _Identifier_ `\"eval\"` or the _Identifier_ `\"arguments\"` occurs as the _Identifier_ in a PropertySetParameterList of a PropertyAssignment that is contained in [strict code](#sec-10.1.1) or if its_FunctionBody_ is [strict code](#sec-10.1.1) ([11.1.5](#sec-11.1.5)).\n* Strict mode eval code cannot instantiate variables or functions in the variable environment of the caller to eval. Instead, a new variable environment is created and that environment is used for declaration binding instantiation for the eval code ([10.4.2](#sec-10.4.2)).\n* If **this** is evaluated within [strict mode code](#sec-10.1.1), then the **this** value is not coerced to an object. A **this** value of **null** or **undefined** is not converted to the global object and primitive values are not converted to wrapper objects. The **this** value passed via a function call (including calls made using`Function.prototype.apply` and **Function.prototype.call)** do not coerce the passed this value to an object ([10.4.3](#sec-10.4.3), [11.1.1](#sec-11.1.1), [15.3.4.3](#sec-15.3.4.3), [15.3.4.4](#sec-15.3.4.4)).\n* When a `delete` operator occurs within [strict mode code](#sec-10.1.1), a **SyntaxError** is thrown if its _UnaryExpression_ is a direct reference to a variable, function argument, or function name(11.4.1).\n* When a `delete` operator occurs within [strict mode code](#sec-10.1.1), a **TypeError** is thrown if the property to be deleted has the attribute { \\[\\[Configurable\\]\\]:**false** } ([11.4.1](#sec-11.4.1)).\n* It is a **SyntaxError** if a _VariableDeclaration_ or _VariableDeclarationNoIn_ occurs within [strict code](#sec-10.1.1) and its _Identifier_ is `eval` or `arguments` ([12.2.1](#sec-12.2.1)).\n* Strict mode code may not include a _WithStatement_. The occurrence of a _WithStatement_ in such a context is an**SyntaxError** ([12.10](#sec-12.10)).\n* It is a **SyntaxError** if a TryStatement with a Catch occurs within[strict code](#sec-10.1.1) and the Identifier of the Catch production is `eval` or `arguments` ([12.14.1](#sec-12.14.1))\n* It is a **SyntaxError** if the identifier `eval` or `arguments` appears within a FormalParameterList of a strict mode FunctionDeclaration or FunctionExpression ([13.1](#sec-13.1))\n* A strict mode function may not have two or more formal parameters that have the same name. An attempt to create such a function using a _FunctionDeclaration_, _FunctionExpression_, or `Function` constructor is a**SyntaxError** ([13.1](#sec-13.1), [15.3.2](#sec-15.3.2)).\n* An implementation may not extend, beyond that defined in this specification, the meanings within strict mode functions of properties named `caller` or `arguments` of function instances. ECMAScript code may not create or modify properties with these names on function objects that correspond to strict mode functions ([10.6](#sec-10.6), 13.2, 15.3.4.5.3).\n* It is a **SyntaxError** to use within [strict mode code](#sec-10.1.1) the identifiers `eval` or`arguments` as the _Identifier_ of a _FunctionDeclaration_ or _FunctionExpression_ or as a formal parameter name ([13.1](#sec-13.1)). Attempting to dynamically define such a strict mode function using the`Function` constructor ([15.3.2](#sec-15.3.2)) will throw a **SyntaxError** exception."}