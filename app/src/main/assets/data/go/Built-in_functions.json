{
  "lang": "Go",
  "title": "Built-in functions",
  "category": "",
  "fullPath": "/Built-in_functions",
  "markdown": "## Built-in functions\n\nBuilt-in functions are[predeclared](https://go.dev/ref/spec#Predeclared%5Fidentifiers). They are called like any other function but some of them accept a type instead of an expression as the first argument.\n\nThe built-in functions do not have standard Go types, so they can only appear in [call expressions](https://go.dev/ref/spec#Calls); they cannot be used as function values.\n\n### Close\n\nFor an argument `ch` with a [core type](https://go.dev/ref/spec#Core%5Ftypes)that is a [channel](https://go.dev/ref/spec#Channel%5Ftypes), the built-in function `close`records that no more values will be sent on the channel. It is an error if `ch` is a receive-only channel. Sending to or closing a closed channel causes a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics). Closing the nil channel also causes a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics). After calling `close`, and after any previously sent values have been received, receive operations will return the zero value for the channel's type without blocking. The multi-valued [receive operation](https://go.dev/ref/spec#Receive%5Foperator)returns a received value along with an indication of whether the channel is closed.\n\n### Length and capacity\n\nThe built-in functions `len` and `cap` take arguments of various types and return a result of type `int`. The implementation guarantees that the result always fits into an `int`.\n\nCall      Argument type    Result\n\nlen(s)    string type      string length in bytes\n          [n]T, *[n]T      array length (== n)\n          []T              slice length\n          map[K]T          map length (number of defined keys)\n          chan T           number of elements queued in channel buffer\n          type parameter   see below\n\ncap(s)    [n]T, *[n]T      array length (== n)\n          []T              slice capacity\n          chan T           channel buffer capacity\n          type parameter   see below\n\nIf the argument type is a [type parameter](https://go.dev/ref/spec#Type%5Fparameter%5Fdeclarations) `P`, the call `len(e)` (or `cap(e)` respectively) must be valid for each type in `P`'s type set. The result is the length (or capacity, respectively) of the argument whose type corresponds to the type argument with which `P` was[instantiated](https://go.dev/ref/spec#Instantiations).\n\nThe capacity of a slice is the number of elements for which there is space allocated in the underlying array. At any time the following relationship holds:\n\n0 <= len(s) <= cap(s)\n\nThe length of a `nil` slice, map or channel is 0\\. The capacity of a `nil` slice or channel is 0.\n\nThe expression `len(s)` is [constant](https://go.dev/ref/spec#Constants) if`s` is a string constant. The expressions `len(s)` and`cap(s)` are constants if the type of `s` is an array or pointer to an array and the expression `s` does not contain[channel receives](https://go.dev/ref/spec#Receive%5Foperator) or (non-constant)[function calls](https://go.dev/ref/spec#Calls); in this case `s` is not evaluated. Otherwise, invocations of `len` and `cap` are not constant and `s` is evaluated.\n\nconst (\n\tc1 = imag(2i)                    // imag(2i) = 2.0 is a constant\n\tc2 = len([10]float64{2})         // [10]float64{2} contains no function calls\n\tc3 = len([10]float64{c1})        // [10]float64{c1} contains no function calls\n\tc4 = len([10]float64{imag(2i)})  // imag(2i) is a constant and no function call is issued\n\tc5 = len([10]float64{imag(z)})   // invalid: imag(z) is a (non-constant) function call\n)\nvar z complex128\n\n### Allocation\n\nThe built-in function `new` takes a type `T`, allocates storage for a [variable](https://go.dev/ref/spec#Variables) of that type at run time, and returns a value of type `*T` [pointing](https://go.dev/ref/spec#Pointer%5Ftypes) to it. The variable is initialized as described in the section on[initial values](https://go.dev/ref/spec#The%5Fzero%5Fvalue).\n\nnew(T)\n\nFor instance\n\ntype S struct { a int; b float64 }\nnew(S)\n\nallocates storage for a variable of type `S`, initializes it (`a=0`, `b=0.0`), and returns a value of type `*S` containing the address of the location.\n\n### Making slices, maps and channels\n\nThe built-in function `make` takes a type `T`, optionally followed by a type-specific list of expressions. The [core type](https://go.dev/ref/spec#Core%5Ftypes) of `T` must be a slice, map or channel. It returns a value of type `T` (not `*T`). The memory is initialized as described in the section on[initial values](https://go.dev/ref/spec#The%5Fzero%5Fvalue).\n\nCall             Core type    Result\n\nmake(T, n)       slice        slice of type T with length n and capacity n\nmake(T, n, m)    slice        slice of type T with length n and capacity m\n\nmake(T)          map          map of type T\nmake(T, n)       map          map of type T with initial space for approximately n elements\n\nmake(T)          channel      unbuffered channel of type T\nmake(T, n)       channel      buffered channel of type T, buffer size n\n\nEach of the size arguments `n` and `m` must be of [integer type](https://go.dev/ref/spec#Numeric%5Ftypes), have a [type set](https://go.dev/ref/spec#Interface%5Ftypes) containing only integer types, or be an untyped [constant](https://go.dev/ref/spec#Constants). A constant size argument must be non-negative and [representable](https://go.dev/ref/spec#Representability)by a value of type `int`; if it is an untyped constant it is given type `int`. If both `n` and `m` are provided and are constant, then`n` must be no larger than `m`. For slices and channels, if `n` is negative or larger than `m` at run time, a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics) occurs.\n\ns := make([]int, 10, 100)       // slice with len(s) == 10, cap(s) == 100\ns := make([]int, 1e3)           // slice with len(s) == cap(s) == 1000\ns := make([]int, 1<<63)         // illegal: len(s) is not representable by a value of type int\ns := make([]int, 10, 0)         // illegal: len(s) > cap(s)\nc := make(chan int, 10)         // channel with a buffer size of 10\nm := make(map[string]int, 100)  // map with initial space for approximately 100 elements\n\nCalling `make` with a map type and size hint `n` will create a map with initial space to hold `n` map elements. The precise behavior is implementation-dependent.\n\n### Appending to and copying slices\n\nThe built-in functions `append` and `copy` assist in common slice operations. For both functions, the result is independent of whether the memory referenced by the arguments overlaps.\n\nThe [variadic](https://go.dev/ref/spec#Function%5Ftypes) function `append`appends zero or more values `x` to a slice `s`and returns the resulting slice of the same type as `s`. The [core type](https://go.dev/ref/spec#Core%5Ftypes) of `s` must be a slice of type `[]E`. The values `x` are passed to a parameter of type `...E`and the respective [parameter passing rules](https://go.dev/ref/spec#Passing%5Farguments%5Fto%5F...%5Fparameters) apply. As a special case, if the core type of `s` is `[]byte`,`append` also accepts a second argument with core type[bytestring](https://go.dev/ref/spec#Core%5Ftypes) followed by `...`. This form appends the bytes of the byte slice or string.\n\nappend(s S, x ...E) S  // core type of S is []E\n\nIf the capacity of `s` is not large enough to fit the additional values, `append` [allocates](https://go.dev/ref/spec#Allocation) a new, sufficiently large underlying array that fits both the existing slice elements and the additional values. Otherwise, `append` re-uses the underlying array.\n\ns0 := []int{0, 0}\ns1 := append(s0, 2)                // append a single element     s1 == []int{0, 0, 2}\ns2 := append(s1, 3, 5, 7)          // append multiple elements    s2 == []int{0, 0, 2, 3, 5, 7}\ns3 := append(s2, s0...)            // append a slice              s3 == []int{0, 0, 2, 3, 5, 7, 0, 0}\ns4 := append(s3[3:6], s3[2:]...)   // append overlapping slice    s4 == []int{3, 5, 7, 2, 3, 5, 7, 0, 0}\n\nvar t []interface{}\nt = append(t, 42, 3.1415, \"foo\")   //                             t == []interface{}{42, 3.1415, \"foo\"}\n\nvar b []byte\nb = append(b, \"bar\"...)            // append string contents      b == []byte{'b', 'a', 'r' }\n\nThe function `copy` copies slice elements from a source `src` to a destination `dst` and returns the number of elements copied. The [core types](https://go.dev/ref/spec#Core%5Ftypes) of both arguments must be slices with [identical](https://go.dev/ref/spec#Type%5Fidentity) element type. The number of elements copied is the minimum of`len(src)` and `len(dst)`. As a special case, if the destination's core type is `[]byte`,`copy` also accepts a source argument with core type[bytestring](https://go.dev/ref/spec#Core%5Ftypes). This form copies the bytes from the byte slice or string into the byte slice.\n\ncopy(dst, src []T) int\ncopy(dst []byte, src string) int\n\nExamples:\n\nvar a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}\nvar s = make([]int, 6)\nvar b = make([]byte, 5)\nn1 := copy(s, a[0:])            // n1 == 6, s == []int{0, 1, 2, 3, 4, 5}\nn2 := copy(s, s[2:])            // n2 == 4, s == []int{2, 3, 4, 5, 4, 5}\nn3 := copy(b, \"Hello, World!\")  // n3 == 5, b == []byte(\"Hello\")\n\n### Deletion of map elements\n\nThe built-in function `delete` removes the element with key`k` from a [map](https://go.dev/ref/spec#Map%5Ftypes) `m`. The value `k` must be [assignable](https://go.dev/ref/spec#Assignability)to the key type of `m`.\n\ndelete(m, k)  // remove element m[k] from map m\n\nIf the type of `m` is a [type parameter](https://go.dev/ref/spec#Type%5Fparameter%5Fdeclarations), all types in that type set must be maps, and they must all have identical key types.\n\nIf the map `m` is `nil` or the element `m[k]`does not exist, `delete` is a no-op.\n\n### Manipulating complex numbers\n\nThree functions assemble and disassemble complex numbers. The built-in function `complex` constructs a complex value from a floating-point real and imaginary part, while`real` and `imag`extract the real and imaginary parts of a complex value.\n\ncomplex(realPart, imaginaryPart floatT) complexT\nreal(complexT) floatT\nimag(complexT) floatT\n\nThe type of the arguments and return value correspond. For `complex`, the two arguments must be of the same[floating-point type](https://go.dev/ref/spec#Numeric%5Ftypes) and the return type is the[complex type](https://go.dev/ref/spec#Numeric%5Ftypes)with the corresponding floating-point constituents:`complex64` for `float32` arguments, and`complex128` for `float64` arguments. If one of the arguments evaluates to an untyped constant, it is first implicitly[converted](https://go.dev/ref/spec#Conversions) to the type of the other argument. If both arguments evaluate to untyped constants, they must be non-complex numbers or their imaginary parts must be zero, and the return value of the function is an untyped complex constant.\n\nFor `real` and `imag`, the argument must be of complex type, and the return type is the corresponding floating-point type: `float32` for a `complex64` argument, and`float64` for a `complex128` argument. If the argument evaluates to an untyped constant, it must be a number, and the return value of the function is an untyped floating-point constant.\n\nThe `real` and `imag` functions together form the inverse of`complex`, so for a value `z` of a complex type `Z`,`z == Z(complex(real(z), imag(z)))`.\n\nIf the operands of these functions are all constants, the return value is a constant.\n\nvar a = complex(2, -2)             // complex128\nconst b = complex(1.0, -1.4)       // untyped complex constant 1 - 1.4i\nx := float32(math.Cos(math.Pi/2))  // float32\nvar c64 = complex(5, -x)           // complex64\nvar s int = complex(1, 0)          // untyped complex constant 1 + 0i can be converted to int\n_ = complex(1, 2<<s)               // illegal: 2 assumes floating-point type, cannot shift\nvar rl = real(c64)                 // float32\nvar im = imag(a)                   // float64\nconst c = imag(b)                  // untyped constant -1.4\n_ = imag(3 << s)                   // illegal: 3 assumes complex type, cannot shift\n\nArguments of type parameter type are not permitted.\n\n### Handling panics\n\n Two built-in functions, `panic` and `recover`, assist in reporting and handling [run-time panics](https://go.dev/ref/spec#Run%5Ftime%5Fpanics)and program-defined error conditions.\n\nfunc panic(interface{})\nfunc recover() interface{}\n\nWhile executing a function `F`, an explicit call to `panic` or a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics)terminates the execution of `F`. Any functions [deferred](https://go.dev/ref/spec#Defer%5Fstatements) by `F`are then executed as usual. Next, any deferred functions run by `F`'s caller are run, and so on up to any deferred by the top-level function in the executing goroutine. At that point, the program is terminated and the error condition is reported, including the value of the argument to `panic`. This termination sequence is called _panicking_.\n\npanic(42)\npanic(\"unreachable\")\npanic(Error(\"cannot parse\"))\n\nThe `recover` function allows a program to manage behavior of a panicking goroutine. Suppose a function `G` defers a function `D` that calls`recover` and a panic occurs in a function on the same goroutine in which `G`is executing. When the running of deferred functions reaches `D`, the return value of `D`'s call to `recover` will be the value passed to the call of `panic`. If `D` returns normally, without starting a new`panic`, the panicking sequence stops. In that case, the state of functions called between `G` and the call to `panic`is discarded, and normal execution resumes. Any functions deferred by `G` before `D` are then run and `G`'s execution terminates by returning to its caller.\n\nThe return value of `recover` is `nil` if any of the following conditions holds:\n\n* `panic`'s argument was `nil`;\n* the goroutine is not panicking;\n* `recover` was not called directly by a deferred function.\n\nThe `protect` function in the example below invokes the function argument `g` and protects callers from run-time panics raised by `g`.\n\nfunc protect(g func()) {\n\tdefer func() {\n\t\tlog.Println(\"done\")  // Println executes normally even if there is a panic\n\t\tif x := recover(); x != nil {\n\t\t\tlog.Printf(\"run time panic: %v\", x)\n\t\t}\n\t}()\n\tlog.Println(\"start\")\n\tg()\n}\n\n### Bootstrapping\n\nCurrent implementations provide several built-in functions useful during bootstrapping. These functions are documented for completeness but are not guaranteed to stay in the language. They do not return a result.\n\nFunction   Behavior\n\nprint      prints all arguments; formatting of arguments is implementation-specific\nprintln    like print but prints spaces between arguments and a newline at the end\n\nImplementation restriction: `print` and `println` need not accept arbitrary argument types, but printing of boolean, numeric, and string[types](https://go.dev/ref/spec#Types) must be supported."
}