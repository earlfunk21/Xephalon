{"lang":"Go","title":"Declarations and scope","category":"","fullPath":"/Declarations_and_scope","markdown":"## Declarations and scope\n\nA _declaration_ binds a non-[blank](https://go.dev/ref/spec#Blank%5Fidentifier) identifier to a[constant](https://go.dev/ref/spec#Constant%5Fdeclarations),[type](https://go.dev/ref/spec#Type%5Fdeclarations),[type parameter](https://go.dev/ref/spec#Type%5Fparameter%5Fdeclarations),[variable](https://go.dev/ref/spec#Variable%5Fdeclarations),[function](https://go.dev/ref/spec#Function%5Fdeclarations),[label](https://go.dev/ref/spec#Labeled%5Fstatements), or[package](https://go.dev/ref/spec#Import%5Fdeclarations). Every identifier in a program must be declared. No identifier may be declared twice in the same block, and no identifier may be declared in both the file and package block.\n\nThe [blank identifier](https://go.dev/ref/spec#Blank%5Fidentifier) may be used like any other identifier in a declaration, but it does not introduce a binding and thus is not declared. In the package block, the identifier `init` may only be used for[init function](https://go.dev/ref/spec#Package%5Finitialization) declarations, and like the blank identifier it does not introduce a new binding.\n\nDeclaration   = [ConstDecl](https://go.dev/ref/spec#ConstDecl) | [TypeDecl](https://go.dev/ref/spec#TypeDecl) | [VarDecl](https://go.dev/ref/spec#VarDecl) .\nTopLevelDecl  = [Declaration](https://go.dev/ref/spec#Declaration) | [FunctionDecl](https://go.dev/ref/spec#FunctionDecl) | [MethodDecl](https://go.dev/ref/spec#MethodDecl) .\n\nThe _scope_ of a declared identifier is the extent of source text in which the identifier denotes the specified constant, type, variable, function, label, or package.\n\nGo is lexically scoped using [blocks](https://go.dev/ref/spec#Blocks):\n\n1. The scope of a [predeclared identifier](https://go.dev/ref/spec#Predeclared%5Fidentifiers) is the universe block.\n2. The scope of an identifier denoting a constant, type, variable, or function (but not method) declared at top level (outside any function) is the package block.\n3. The scope of the package name of an imported package is the file block of the file containing the import declaration.\n4. The scope of an identifier denoting a method receiver, function parameter, or result variable is the function body.\n5. The scope of an identifier denoting a type parameter of a function or declared by a method receiver begins after the name of the function and ends at the end of the function body.\n6. The scope of an identifier denoting a type parameter of a type begins after the name of the type and ends at the end of the TypeSpec.\n7. The scope of a constant or variable identifier declared inside a function begins at the end of the ConstSpec or VarSpec (ShortVarDecl for short variable declarations) and ends at the end of the innermost containing block.\n8. The scope of a type identifier declared inside a function begins at the identifier in the TypeSpec and ends at the end of the innermost containing block.\n\nAn identifier declared in a block may be redeclared in an inner block. While the identifier of the inner declaration is in scope, it denotes the entity declared by the inner declaration.\n\nThe [package clause](https://go.dev/ref/spec#Package%5Fclause) is not a declaration; the package name does not appear in any scope. Its purpose is to identify the files belonging to the same [package](https://go.dev/ref/spec#Packages) and to specify the default package name for import declarations.\n\n### Label scopes\n\nLabels are declared by [labeled statements](https://go.dev/ref/spec#Labeled%5Fstatements) and are used in the [\"break\"](https://go.dev/ref/spec#Break%5Fstatements),[\"continue\"](https://go.dev/ref/spec#Continue%5Fstatements), and[\"goto\"](https://go.dev/ref/spec#Goto%5Fstatements) statements. It is illegal to define a label that is never used. In contrast to other identifiers, labels are not block scoped and do not conflict with identifiers that are not labels. The scope of a label is the body of the function in which it is declared and excludes the body of any nested function.\n\n### Blank identifier\n\nThe _blank identifier_ is represented by the underscore character `_`. It serves as an anonymous placeholder instead of a regular (non-blank) identifier and has special meaning in [declarations](https://go.dev/ref/spec#Declarations%5Fand%5Fscope), as an [operand](https://go.dev/ref/spec#Operands), and in [assignment statements](https://go.dev/ref/spec#Assignment%5Fstatements).\n\n### Predeclared identifiers\n\nThe following identifiers are implicitly declared in the[universe block](https://go.dev/ref/spec#Blocks):\n\nTypes:\n\tany bool byte comparable\n\tcomplex64 complex128 error float32 float64\n\tint int8 int16 int32 int64 rune string\n\tuint uint8 uint16 uint32 uint64 uintptr\n\nConstants:\n\ttrue false iota\n\nZero value:\n\tnil\n\nFunctions:\n\tappend cap close complex copy delete imag len\n\tmake new panic print println real recover\n\n### Exported identifiers\n\nAn identifier may be _exported_ to permit access to it from another package. An identifier is exported if both:\n\n1. the first character of the identifier's name is a Unicode uppercase letter (Unicode character category Lu); and\n2. the identifier is declared in the [package block](https://go.dev/ref/spec#Blocks) or it is a [field name](https://go.dev/ref/spec#Struct%5Ftypes) or[method name](https://go.dev/ref/spec#MethodName).\n\nAll other identifiers are not exported.\n\n### Uniqueness of identifiers\n\nGiven a set of identifiers, an identifier is called _unique_ if it is_different_ from every other in the set. Two identifiers are different if they are spelled differently, or if they appear in different [packages](https://go.dev/ref/spec#Packages) and are not[exported](https://go.dev/ref/spec#Exported%5Fidentifiers). Otherwise, they are the same.\n\n### Constant declarations\n\nA constant declaration binds a list of identifiers (the names of the constants) to the values of a list of [constant expressions](https://go.dev/ref/spec#Constant%5Fexpressions). The number of identifiers must be equal to the number of expressions, and the _n_th identifier on the left is bound to the value of the _n_th expression on the right.\n\nConstDecl      = \"const\" ( [ConstSpec](https://go.dev/ref/spec#ConstSpec) | \"(\" { [ConstSpec](https://go.dev/ref/spec#ConstSpec) \";\" } \")\" ) .\nConstSpec      = [IdentifierList](https://go.dev/ref/spec#IdentifierList) [ [ [Type](https://go.dev/ref/spec#Type) ] \"=\" [ExpressionList](https://go.dev/ref/spec#ExpressionList) ] .\n\nIdentifierList = [identifier](https://go.dev/ref/spec#identifier) { \",\" [identifier](https://go.dev/ref/spec#identifier) } .\nExpressionList = [Expression](https://go.dev/ref/spec#Expression) { \",\" [Expression](https://go.dev/ref/spec#Expression) } .\n\nIf the type is present, all constants take the type specified, and the expressions must be [assignable](https://go.dev/ref/spec#Assignability) to that type, which must not be a type parameter. If the type is omitted, the constants take the individual types of the corresponding expressions. If the expression values are untyped [constants](https://go.dev/ref/spec#Constants), the declared constants remain untyped and the constant identifiers denote the constant values. For instance, if the expression is a floating-point literal, the constant identifier denotes a floating-point constant, even if the literal's fractional part is zero.\n\nconst Pi float64 = 3.14159265358979323846\nconst zero = 0.0         // untyped floating-point constant\nconst (\n\tsize int64 = 1024\n\teof        = -1  // untyped integer constant\n)\nconst a, b, c = 3, 4, \"foo\"  // a = 3, b = 4, c = \"foo\", untyped integer and string constants\nconst u, v float32 = 0, 3    // u = 0.0, v = 3.0\n\nWithin a parenthesized `const` declaration list the expression list may be omitted from any but the first ConstSpec. Such an empty list is equivalent to the textual substitution of the first preceding non-empty expression list and its type if any. Omitting the list of expressions is therefore equivalent to repeating the previous list. The number of identifiers must be equal to the number of expressions in the previous list. Together with the [iota constant generator](https://go.dev/ref/spec#Iota)this mechanism permits light-weight declaration of sequential values:\n\nconst (\n\tSunday = iota\n\tMonday\n\tTuesday\n\tWednesday\n\tThursday\n\tFriday\n\tPartyday\n\tnumberOfDays  // this constant is not exported\n)\n\n### Iota\n\nWithin a [constant declaration](https://go.dev/ref/spec#Constant%5Fdeclarations), the predeclared identifier`iota` represents successive untyped integer [constants](https://go.dev/ref/spec#Constants). Its value is the index of the respective [ConstSpec](https://go.dev/ref/spec#ConstSpec)in that constant declaration, starting at zero. It can be used to construct a set of related constants:\n\nconst (\n\tc0 = iota  // c0 == 0\n\tc1 = iota  // c1 == 1\n\tc2 = iota  // c2 == 2\n)\n\nconst (\n\ta = 1 << iota  // a == 1  (iota == 0)\n\tb = 1 << iota  // b == 2  (iota == 1)\n\tc = 3          // c == 3  (iota == 2, unused)\n\td = 1 << iota  // d == 8  (iota == 3)\n)\n\nconst (\n\tu         = iota * 42  // u == 0     (untyped integer constant)\n\tv float64 = iota * 42  // v == 42.0  (float64 constant)\n\tw         = iota * 42  // w == 84    (untyped integer constant)\n)\n\nconst x = iota  // x == 0\nconst y = iota  // y == 0\n\nBy definition, multiple uses of `iota` in the same ConstSpec all have the same value:\n\nconst (\n\tbit0, mask0 = 1 << iota, 1<<iota - 1  // bit0 == 1, mask0 == 0  (iota == 0)\n\tbit1, mask1                           // bit1 == 2, mask1 == 1  (iota == 1)\n\t_, _                                  //                        (iota == 2, unused)\n\tbit3, mask3                           // bit3 == 8, mask3 == 7  (iota == 3)\n)\n\nThis last example exploits the [implicit repetition](https://go.dev/ref/spec#Constant%5Fdeclarations)of the last non-empty expression list.\n\n### Type declarations\n\nA type declaration binds an identifier, the _type name_, to a [type](https://go.dev/ref/spec#Types). Type declarations come in two forms: alias declarations and type definitions.\n\nTypeDecl = \"type\" ( [TypeSpec](https://go.dev/ref/spec#TypeSpec) | \"(\" { [TypeSpec](https://go.dev/ref/spec#TypeSpec) \";\" } \")\" ) .\nTypeSpec = [AliasDecl](https://go.dev/ref/spec#AliasDecl) | [TypeDef](https://go.dev/ref/spec#TypeDef) .\n\n#### Alias declarations\n\nAn alias declaration binds an identifier to the given type.\n\nAliasDecl = [identifier](https://go.dev/ref/spec#identifier) \"=\" [Type](https://go.dev/ref/spec#Type) .\n\nWithin the [scope](https://go.dev/ref/spec#Declarations%5Fand%5Fscope) of the identifier, it serves as an _alias_ for the type.\n\ntype (\n\tnodeList = []*Node  // nodeList and []*Node are identical types\n\tPolar    = polar    // Polar and polar denote identical types\n)\n\n#### Type definitions\n\nA type definition creates a new, distinct type with the same[underlying type](https://go.dev/ref/spec#Types) and operations as the given type and binds an identifier, the _type name_, to it.\n\nTypeDef = [identifier](https://go.dev/ref/spec#identifier) [ [TypeParameters](https://go.dev/ref/spec#TypeParameters) ] [Type](https://go.dev/ref/spec#Type) .\n\nThe new type is called a _defined type_. It is [different](https://go.dev/ref/spec#Type%5Fidentity) from any other type, including the type it is created from.\n\ntype (\n\tPoint struct{ x, y float64 }  // Point and struct{ x, y float64 } are different types\n\tpolar Point                   // polar and Point denote different types\n)\n\ntype TreeNode struct {\n\tleft, right *TreeNode\n\tvalue any\n}\n\ntype Block interface {\n\tBlockSize() int\n\tEncrypt(src, dst []byte)\n\tDecrypt(src, dst []byte)\n}\n\nA defined type may have [methods](https://go.dev/ref/spec#Method%5Fdeclarations) associated with it. It does not inherit any methods bound to the given type, but the [method set](https://go.dev/ref/spec#Method%5Fsets)of an interface type or of elements of a composite type remains unchanged:\n\n// A Mutex is a data type with two methods, Lock and Unlock.\ntype Mutex struct         { /* Mutex fields */ }\nfunc (m *Mutex) Lock()    { /* Lock implementation */ }\nfunc (m *Mutex) Unlock()  { /* Unlock implementation */ }\n\n// NewMutex has the same composition as Mutex but its method set is empty.\ntype NewMutex Mutex\n\n// The method set of PtrMutex's underlying type *Mutex remains unchanged,\n// but the method set of PtrMutex is empty.\ntype PtrMutex *Mutex\n\n// The method set of *PrintableMutex contains the methods\n// Lock and Unlock bound to its embedded field Mutex.\ntype PrintableMutex struct {\n\tMutex\n}\n\n// MyBlock is an interface type that has the same method set as Block.\ntype MyBlock Block\n\nType definitions may be used to define different boolean, numeric, or string types and associate methods with them:\n\ntype TimeZone int\n\nconst (\n\tEST TimeZone = -(5 + iota)\n\tCST\n\tMST\n\tPST\n)\n\nfunc (tz TimeZone) String() string {\n\treturn fmt.Sprintf(\"GMT%+dh\", tz)\n}\n\nIf the type definition specifies [type parameters](https://go.dev/ref/spec#Type%5Fparameter%5Fdeclarations), the type name denotes a _generic type_. Generic types must be [instantiated](https://go.dev/ref/spec#Instantiations) when they are used.\n\ntype List[T any] struct {\n\tnext  *List[T]\n\tvalue T\n}\n\nIn a type definition the given type cannot be a type parameter.\n\ntype T[P any] P    // illegal: P is a type parameter\n\nfunc f[T any]() {\n\ttype L T   // illegal: T is a type parameter declared by the enclosing function\n}\n\nA generic type may also have [methods](https://go.dev/ref/spec#Method%5Fdeclarations) associated with it. In this case, the method receivers must declare the same number of type parameters as present in the generic type definition.\n\n// The method Len returns the number of elements in the linked list l.\nfunc (l *List[T]) Len() int  { … }\n\n### Type parameter declarations\n\nA type parameter list declares the _type parameters_ of a generic function or type declaration. The type parameter list looks like an ordinary [function parameter list](https://go.dev/ref/spec#Function%5Ftypes)except that the type parameter names must all be present and the list is enclosed in square brackets rather than parentheses.\n\nTypeParameters  = \"[\" [TypeParamList](https://go.dev/ref/spec#TypeParamList) [ \",\" ] \"]\" .\nTypeParamList   = [TypeParamDecl](https://go.dev/ref/spec#TypeParamDecl) { \",\" [TypeParamDecl](https://go.dev/ref/spec#TypeParamDecl) } .\nTypeParamDecl   = [IdentifierList](https://go.dev/ref/spec#IdentifierList) [TypeConstraint](https://go.dev/ref/spec#TypeConstraint) .\n\nAll non-blank names in the list must be unique. Each name declares a type parameter, which is a new and different [named type](https://go.dev/ref/spec#Types)that acts as a place holder for an (as of yet) unknown type in the declaration. The type parameter is replaced with a _type argument_ upon[instantiation](https://go.dev/ref/spec#Instantiations) of the generic function or type.\n\n[P any]\n[S interface{ ~[]byte|string }]\n[S ~[]E, E any]\n[P Constraint[int]]\n[_ any]\n\nJust as each ordinary function parameter has a parameter type, each type parameter has a corresponding (meta-)type which is called its[_type constraint_](https://go.dev/ref/spec#Type%5Fconstraints).\n\nA parsing ambiguity arises when the type parameter list for a generic type declares a single type parameter `P` with a constraint `C`such that the text `P C` forms a valid expression:\n\ntype T[P *C] …\ntype T[P (C)] …\ntype T[P *C|Q] …\n…\n\nIn these rare cases, the type parameter list is indistinguishable from an expression and the type declaration is parsed as an array type declaration. To resolve the ambiguity, embed the constraint in an[interface](https://go.dev/ref/spec#Interface%5Ftypes) or use a trailing comma:\n\ntype T[P interface{*C}] …\ntype T[P *C,] …\n\nType parameters may also be declared by the receiver specification of a [method declaration](https://go.dev/ref/spec#Method%5Fdeclarations) associated with a generic type.\n\nWithin a type parameter list of a generic type `T`, a type constraint may not (directly, or indirectly through the type parameter list of another generic type) refer to `T`.\n\ntype T1[P T1[P]] …                    // illegal: T1 refers to itself\ntype T2[P interface{ T2[int] }] …     // illegal: T2 refers to itself\ntype T3[P interface{ m(T3[int])}] …   // illegal: T3 refers to itself\ntype T4[P T5[P]] …                    // illegal: T4 refers to T5 and\ntype T5[P T4[P]] …                    //          T5 refers to T4\n\ntype T6[P int] struct{ f *T6[P] }     // ok: reference to T6 is not in type parameter list\n\n#### Type constraints\n\nA _type constraint_ is an [interface](https://go.dev/ref/spec#Interface%5Ftypes) that defines the set of permissible type arguments for the respective type parameter and controls the operations supported by values of that type parameter.\n\nTypeConstraint = [TypeElem](https://go.dev/ref/spec#TypeElem) .\n\nIf the constraint is an interface literal of the form `interface{E}` where`E` is an embedded [type element](https://go.dev/ref/spec#Interface%5Ftypes) (not a method), in a type parameter list the enclosing `interface{ … }` may be omitted for convenience:\n\n[T []P]                      // = [T interface{[]P}]\n[T ~int]                     // = [T interface{~int}]\n[T int|string]               // = [T interface{int|string}]\ntype Constraint ~int         // illegal: ~int is not in a type parameter list\n\nThe [predeclared](https://go.dev/ref/spec#Predeclared%5Fidentifiers) [interface type](https://go.dev/ref/spec#Interface%5Ftypes) `comparable`denotes the set of all non-interface types that are[strictly comparable](https://go.dev/ref/spec#Comparison%5Foperators).\n\nEven though interfaces that are not type parameters are [comparable](https://go.dev/ref/spec#Comparison%5Foperators), they are not strictly comparable and therefore they do not implement `comparable`. However, they [satisfy](https://go.dev/ref/spec#Satisfying%5Fa%5Ftype%5Fconstraint) `comparable`.\n\nint                          // implements comparable (int is strictly comparable)\n[]byte                       // does not implement comparable (slices cannot be compared)\ninterface{}                  // does not implement comparable (see above)\ninterface{ ~int | ~string }  // type parameter only: implements comparable (int, string types are stricly comparable)\ninterface{ comparable }      // type parameter only: implements comparable (comparable implements itself)\ninterface{ ~int | ~[]byte }  // type parameter only: does not implement comparable (slices are not comparable)\ninterface{ ~struct{ any } }  // type parameter only: does not implement comparable (field any is not strictly comparable)\n\nThe `comparable` interface and interfaces that (directly or indirectly) embed`comparable` may only be used as type constraints. They cannot be the types of values or variables, or components of other, non-interface types.\n\n#### Satisfying a type constraint\n\nA type argument `T` _satisfies_ a type constraint `C`if `T` is an element of the type set defined by `C`; i.e., if `T` [implements](https://go.dev/ref/spec#Implementing%5Fan%5Finterface) `C`. As an exception, a [strictly comparable](https://go.dev/ref/spec#Comparison%5Foperators)type constraint may also be satisfied by a [comparable](https://go.dev/ref/spec#Comparison%5Foperators)(not necessarily strictly comparable) type argument. More precisely:\n\nA type T _satisfies_ a constraint `C` if\n\n* `T` [implements](https://go.dev/ref/spec#Implementing%5Fan%5Finterface) `C`; or\n* `C` can be written in the form `interface{ comparable; E }`, where `E` is a [basic interface](https://go.dev/ref/spec#Basic%5Finterfaces) and`T` is [comparable](https://go.dev/ref/spec#Comparison%5Foperators) and implements `E`.\n\ntype argument      type constraint                // constraint satisfaction\n\nint                interface{ ~int }              // satisfied: int implements interface{ ~int }\nstring             comparable                     // satisfied: string implements comparable (string is stricty comparable)\n[]byte             comparable                     // not satisfied: slices are not comparable\nany                interface{ comparable; int }   // not satisfied: any does not implement interface{ int }\nany                comparable                     // satisfied: any is comparable and implements the basic interface any\nstruct{f any}      comparable                     // satisfied: struct{f any} is comparable and implements the basic interface any\nany                interface{ comparable; m() }   // not satisfied: any does not implement the basic interface interface{ m() }\ninterface{ m() }   interface{ comparable; m() }   // satisfied: interface{ m() } is comparable and implements the basic interface interface{ m() }\n\nBecause of the exception in the constraint satisfaction rule, comparing operands of type parameter type may panic at run-time (even though comparable type parameters are always strictly comparable).\n\n### Variable declarations\n\nA variable declaration creates one or more [variables](https://go.dev/ref/spec#Variables), binds corresponding identifiers to them, and gives each a type and an initial value.\n\nVarDecl     = \"var\" ( [VarSpec](https://go.dev/ref/spec#VarSpec) | \"(\" { [VarSpec](https://go.dev/ref/spec#VarSpec) \";\" } \")\" ) .\nVarSpec     = [IdentifierList](https://go.dev/ref/spec#IdentifierList) ( [Type](https://go.dev/ref/spec#Type) [ \"=\" [ExpressionList](https://go.dev/ref/spec#ExpressionList) ] | \"=\" [ExpressionList](https://go.dev/ref/spec#ExpressionList) ) .\n\nvar i int\nvar U, V, W float64\nvar k = 0\nvar x, y float32 = -1, -2\nvar (\n\ti       int\n\tu, v, s = 2.0, 3.0, \"bar\"\n)\nvar re, im = complexSqrt(-1)\nvar _, found = entries[name]  // map lookup; only interested in \"found\"\n\nIf a list of expressions is given, the variables are initialized with the expressions following the rules for [assignment statements](https://go.dev/ref/spec#Assignment%5Fstatements). Otherwise, each variable is initialized to its [zero value](https://go.dev/ref/spec#The%5Fzero%5Fvalue).\n\nIf a type is present, each variable is given that type. Otherwise, each variable is given the type of the corresponding initialization value in the assignment. If that value is an untyped constant, it is first implicitly[converted](https://go.dev/ref/spec#Conversions) to its [default type](https://go.dev/ref/spec#Constants); if it is an untyped boolean value, it is first implicitly converted to type `bool`. The predeclared value `nil` cannot be used to initialize a variable with no explicit type.\n\nvar d = math.Sin(0.5)  // d is float64\nvar i = 42             // i is int\nvar t, ok = x.(T)      // t is T, ok is bool\nvar n = nil            // illegal\n\nImplementation restriction: A compiler may make it illegal to declare a variable inside a [function body](https://go.dev/ref/spec#Function%5Fdeclarations) if the variable is never used.\n\n### Short variable declarations\n\nA _short variable declaration_ uses the syntax:\n\nShortVarDecl = [IdentifierList](https://go.dev/ref/spec#IdentifierList) \":=\" [ExpressionList](https://go.dev/ref/spec#ExpressionList) .\n\nIt is shorthand for a regular [variable declaration](https://go.dev/ref/spec#Variable%5Fdeclarations)with initializer expressions but no types:\n\n\"var\" IdentifierList \"=\" ExpressionList .\n\ni, j := 0, 10\nf := func() int { return 7 }\nch := make(chan int)\nr, w, _ := os.Pipe()  // os.Pipe() returns a connected pair of Files and an error, if any\n_, y, _ := coord(p)   // coord() returns three values; only interested in y coordinate\n\nUnlike regular variable declarations, a short variable declaration may _redeclare_variables provided they were originally declared earlier in the same block (or the parameter lists if the block is the function body) with the same type, and at least one of the non-[blank](https://go.dev/ref/spec#Blank%5Fidentifier) variables is new. As a consequence, redeclaration can only appear in a multi-variable short declaration. Redeclaration does not introduce a new variable; it just assigns a new value to the original. The non-blank variable names on the left side of `:=`must be [unique](https://go.dev/ref/spec#Uniqueness%5Fof%5Fidentifiers).\n\nfield1, offset := nextField(str, 0)\nfield2, offset := nextField(str, offset)  // redeclares offset\nx, y, x := 1, 2, 3                        // illegal: x repeated on left side of :=\n\nShort variable declarations may appear only inside functions. In some contexts such as the initializers for[\"if\"](https://go.dev/ref/spec#If%5Fstatements),[\"for\"](https://go.dev/ref/spec#For%5Fstatements), or[\"switch\"](https://go.dev/ref/spec#Switch%5Fstatements) statements, they can be used to declare local temporary variables.\n\n### Function declarations\n\nA function declaration binds an identifier, the _function name_, to a function.\n\nFunctionDecl = \"func\" [FunctionName](https://go.dev/ref/spec#FunctionName) [ [TypeParameters](https://go.dev/ref/spec#TypeParameters) ] [Signature](https://go.dev/ref/spec#Signature) [ [FunctionBody](https://go.dev/ref/spec#FunctionBody) ] .\nFunctionName = [identifier](https://go.dev/ref/spec#identifier) .\nFunctionBody = [Block](https://go.dev/ref/spec#Block) .\n\nIf the function's [signature](https://go.dev/ref/spec#Function%5Ftypes) declares result parameters, the function body's statement list must end in a [terminating statement](https://go.dev/ref/spec#Terminating%5Fstatements).\n\nfunc IndexRune(s string, r rune) int {\n\tfor i, c := range s {\n\t\tif c == r {\n\t\t\treturn i\n\t\t}\n\t}\n\t// invalid: missing return statement\n}\n\nIf the function declaration specifies [type parameters](https://go.dev/ref/spec#Type%5Fparameter%5Fdeclarations), the function name denotes a _generic function_. A generic function must be [instantiated](https://go.dev/ref/spec#Instantiations) before it can be called or used as a value.\n\nfunc min[T ~int|~float64](x, y T) T {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}\n\nA function declaration without type parameters may omit the body. Such a declaration provides the signature for a function implemented outside Go, such as an assembly routine.\n\nfunc flushICache(begin, end uintptr)  // implemented externally\n\n### Method declarations\n\nA method is a [function](https://go.dev/ref/spec#Function%5Fdeclarations) with a _receiver_. A method declaration binds an identifier, the _method name_, to a method, and associates the method with the receiver's _base type_.\n\nMethodDecl = \"func\" [Receiver](https://go.dev/ref/spec#Receiver) [MethodName](https://go.dev/ref/spec#MethodName) [Signature](https://go.dev/ref/spec#Signature) [ [FunctionBody](https://go.dev/ref/spec#FunctionBody) ] .\nReceiver   = [Parameters](https://go.dev/ref/spec#Parameters) .\n\nThe receiver is specified via an extra parameter section preceding the method name. That parameter section must declare a single non-variadic parameter, the receiver. Its type must be a [defined](https://go.dev/ref/spec#Type%5Fdefinitions) type `T` or a pointer to a defined type `T`, possibly followed by a list of type parameter names `[P1, P2, …]` enclosed in square brackets.`T` is called the receiver _base type_. A receiver base type cannot be a pointer or interface type and it must be defined in the same package as the method. The method is said to be _bound_ to its receiver base type and the method name is visible only within [selectors](https://go.dev/ref/spec#Selectors) for type `T`or `*T`.\n\nA non-[blank](https://go.dev/ref/spec#Blank%5Fidentifier) receiver identifier must be[unique](https://go.dev/ref/spec#Uniqueness%5Fof%5Fidentifiers) in the method signature. If the receiver's value is not referenced inside the body of the method, its identifier may be omitted in the declaration. The same applies in general to parameters of functions and methods.\n\nFor a base type, the non-blank names of methods bound to it must be unique. If the base type is a [struct type](https://go.dev/ref/spec#Struct%5Ftypes), the non-blank method and field names must be distinct.\n\nGiven defined type `Point` the declarations\n\nfunc (p *Point) Length() float64 {\n\treturn math.Sqrt(p.x * p.x + p.y * p.y)\n}\n\nfunc (p *Point) Scale(factor float64) {\n\tp.x *= factor\n\tp.y *= factor\n}\n\nbind the methods `Length` and `Scale`, with receiver type `*Point`, to the base type `Point`.\n\nIf the receiver base type is a [generic type](https://go.dev/ref/spec#Type%5Fdeclarations), the receiver specification must declare corresponding type parameters for the method to use. This makes the receiver type parameters available to the method. Syntactically, this type parameter declaration looks like an[instantiation](https://go.dev/ref/spec#Instantiations) of the receiver base type: the type arguments must be identifiers denoting the type parameters being declared, one for each type parameter of the receiver base type. The type parameter names do not need to match their corresponding parameter names in the receiver base type definition, and all non-blank parameter names must be unique in the receiver parameter section and the method signature. The receiver type parameter constraints are implied by the receiver base type definition: corresponding type parameters have corresponding constraints.\n\ntype Pair[A, B any] struct {\n\ta A\n\tb B\n}\n\nfunc (p Pair[A, B]) Swap() Pair[B, A]  { … }  // receiver declares A, B\nfunc (p Pair[First, _]) First() First  { … }  // receiver declares First, corresponds to A in Pair"}