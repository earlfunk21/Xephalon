{"lang":"Go","title":"Properties of types and values","category":"","fullPath":"/Properties_of_types_and_values","markdown":"## Properties of types and values\n\n### Underlying types\n\nEach type `T` has an _underlying type_: If `T`is one of the predeclared boolean, numeric, or string types, or a type literal, the corresponding underlying type is `T` itself. Otherwise, `T`'s underlying type is the underlying type of the type to which `T` refers in its declaration. For a type parameter that is the underlying type of its[type constraint](https://go.dev/ref/spec#Type%5Fconstraints), which is always an interface.\n\ntype (\n\tA1 = string\n\tA2 = A1\n)\n\ntype (\n\tB1 string\n\tB2 B1\n\tB3 []B1\n\tB4 B3\n)\n\nfunc f[P any](x P) { â€¦ }\n\nThe underlying type of `string`, `A1`, `A2`, `B1`, and `B2` is `string`. The underlying type of `[]B1`, `B3`, and `B4` is `[]B1`. The underlying type of `P` is `interface{}`.\n\n### Core types\n\nEach non-interface type `T` has a _core type_, which is the same as the[underlying type](https://go.dev/ref/spec#Underlying%5Ftypes) of `T`.\n\nAn interface `T` has a core type if one of the following conditions is satisfied:\n\n1. There is a single type `U` which is the [underlying type](https://go.dev/ref/spec#Underlying%5Ftypes)of all types in the [type set](https://go.dev/ref/spec#Interface%5Ftypes) of `T`; or\n2. the type set of `T` contains only [channel types](https://go.dev/ref/spec#Channel%5Ftypes)with identical element type `E`, and all directional channels have the same direction.\n\nNo other interfaces have a core type.\n\nThe core type of an interface is, depending on the condition that is satisfied, either:\n\n1. the type `U`; or\n2. the type `chan E` if `T` contains only bidirectional channels, or the type `chan<- E` or `<-chan E`depending on the direction of the directional channels present.\n\nBy definition, a core type is never a [defined type](https://go.dev/ref/spec#Type%5Fdefinitions),[type parameter](https://go.dev/ref/spec#Type%5Fparameter%5Fdeclarations), or[interface type](https://go.dev/ref/spec#Interface%5Ftypes).\n\nExamples of interfaces with core types:\n\ntype Celsius float32\ntype Kelvin  float32\n\ninterface{ int }                          // int\ninterface{ Celsius|Kelvin }               // float32\ninterface{ ~chan int }                    // chan int\ninterface{ ~chan int|~chan<- int }        // chan<- int\ninterface{ ~[]*data; String() string }    // []*data\n\nExamples of interfaces without core types:\n\ninterface{}                               // no single underlying type\ninterface{ Celsius|float64 }              // no single underlying type\ninterface{ chan int | chan<- string }     // channels have different element types\ninterface{ <-chan int | chan<- int }      // directional channels have different directions\n\nSome operations ([slice expressions](https://go.dev/ref/spec#Slice%5Fexpressions),[append and copy](https://go.dev/ref/spec#Appending%5Fand%5Fcopying%5Fslices)) rely on a slightly more loose form of core types which accept byte slices and strings. Specifically, if there are exactly two types, `[]byte` and `string`, which are the underlying types of all types in the type set of interface `T`, the core type of `T` is called `bytestring`.\n\nExamples of interfaces with `bytestring` core types:\n\ninterface{ int }                          // int (same as ordinary core type)\ninterface{ []byte | string }              // bytestring\ninterface{ ~[]byte | myString }           // bytestring\n\nNote that `bytestring` is not a real type; it cannot be used to declare variables are compose other types. It exists solely to describe the behavior of some operations that read from a sequence of bytes, which may be a byte slice or a string.\n\n### Type identity\n\nTwo types are either _identical_ or _different_.\n\nA [named type](https://go.dev/ref/spec#Types) is always different from any other type. Otherwise, two types are identical if their [underlying](https://go.dev/ref/spec#Types) type literals are structurally equivalent; that is, they have the same literal structure and corresponding components have identical types. In detail:\n\n* Two array types are identical if they have identical element types and the same array length.\n* Two slice types are identical if they have identical element types.\n* Two struct types are identical if they have the same sequence of fields, and if corresponding fields have the same names, and identical types, and identical tags.[Non-exported](https://go.dev/ref/spec#Exported%5Fidentifiers) field names from different packages are always different.\n* Two pointer types are identical if they have identical base types.\n* Two function types are identical if they have the same number of parameters and result values, corresponding parameter and result types are identical, and either both functions are variadic or neither is. Parameter and result names are not required to match.\n* Two interface types are identical if they define the same type set.\n* Two map types are identical if they have identical key and element types.\n* Two channel types are identical if they have identical element types and the same direction.\n* Two [instantiated](https://go.dev/ref/spec#Instantiations) types are identical if their defined types and all type arguments are identical.\n\nGiven the declarations\n\ntype (\n\tA0 = []string\n\tA1 = A0\n\tA2 = struct{ a, b int }\n\tA3 = int\n\tA4 = func(A3, float64) *A0\n\tA5 = func(x int, _ float64) *[]string\n\n\tB0 A0\n\tB1 []string\n\tB2 struct{ a, b int }\n\tB3 struct{ a, c int }\n\tB4 func(int, float64) *B0\n\tB5 func(x int, y float64) *A1\n\n\tC0 = B0\n\tD0[P1, P2 any] struct{ x P1; y P2 }\n\tE0 = D0[int, string]\n)\n\nthese types are identical:\n\nA0, A1, and []string\nA2 and struct{ a, b int }\nA3 and int\nA4, func(int, float64) *[]string, and A5\n\nB0 and C0\nD0[int, string] and E0\n[]int and []int\nstruct{ a, b *B5 } and struct{ a, b *B5 }\nfunc(x int, y float64) *[]string, func(int, float64) (result *[]string), and A5\n\n`B0` and `B1` are different because they are new types created by distinct [type definitions](https://go.dev/ref/spec#Type%5Fdefinitions);`func(int, float64) *B0` and `func(x int, y float64) *[]string`are different because `B0` is different from `[]string`; and `P1` and `P2` are different because they are different type parameters.`D0[int, string]` and `struct{ x int; y string }` are different because the former is an [instantiated](https://go.dev/ref/spec#Instantiations)defined type while the latter is a type literal (but they are still [assignable](https://go.dev/ref/spec#Assignability)).\n\n### Assignability\n\nA value `x` of type `V` is _assignable_ to a [variable](https://go.dev/ref/spec#Variables) of type `T`(\"`x` is assignable to `T`\") if one of the following conditions applies:\n\n* `V` and `T` are identical.\n* `V` and `T` have identical[underlying types](https://go.dev/ref/spec#Underlying%5Ftypes)but are not type parameters and at least one of `V`or `T` is not a [named type](https://go.dev/ref/spec#Types).\n* `V` and `T` are channel types with identical element types, `V` is a bidirectional channel, and at least one of `V` or `T` is not a [named type](https://go.dev/ref/spec#Types).\n* `T` is an interface type, but not a type parameter, and`x` [implements](https://go.dev/ref/spec#Implementing%5Fan%5Finterface) `T`.\n* `x` is the predeclared identifier `nil` and `T`is a pointer, function, slice, map, channel, or interface type, but not a type parameter.\n* `x` is an untyped [constant](https://go.dev/ref/spec#Constants) [representable](https://go.dev/ref/spec#Representability)by a value of type `T`.\n\nAdditionally, if `x`'s type `V` or `T` are type parameters, `x`is assignable to a variable of type `T` if one of the following conditions applies:\n\n* `x` is the predeclared identifier `nil`, `T` is a type parameter, and `x` is assignable to each type in`T`'s type set.\n* `V` is not a [named type](https://go.dev/ref/spec#Types), `T` is a type parameter, and `x` is assignable to each type in`T`'s type set.\n* `V` is a type parameter and `T` is not a named type, and values of each type in `V`'s type set are assignable to `T`.\n\n### Representability\n\nA [constant](https://go.dev/ref/spec#Constants) `x` is _representable_by a value of type `T`, where `T` is not a [type parameter](https://go.dev/ref/spec#Type%5Fparameter%5Fdeclarations), if one of the following conditions applies:\n\n* `x` is in the set of values [determined](https://go.dev/ref/spec#Types) by `T`.\n* `T` is a [floating-point type](https://go.dev/ref/spec#Numeric%5Ftypes) and `x` can be rounded to `T`'s precision without overflow. Rounding uses IEEE 754 round-to-even rules but with an IEEE negative zero further simplified to an unsigned zero. Note that constant values never result in an IEEE negative zero, NaN, or infinity.\n* `T` is a complex type, and `x`'s[components](https://go.dev/ref/spec#Complex%5Fnumbers) `real(x)` and `imag(x)`are representable by values of `T`'s component type (`float32` or`float64`).\n\nIf `T` is a type parameter,`x` is representable by a value of type `T` if `x` is representable by a value of each type in `T`'s type set.\n\nx                   T           x is representable by a value of T because\n\n'a'                 byte        97 is in the set of byte values\n97                  rune        rune is an alias for int32, and 97 is in the set of 32-bit integers\n\"foo\"               string      \"foo\" is in the set of string values\n1024                int16       1024 is in the set of 16-bit integers\n42.0                byte        42 is in the set of unsigned 8-bit integers\n1e10                uint64      10000000000 is in the set of unsigned 64-bit integers\n2.718281828459045   float32     2.718281828459045 rounds to 2.7182817 which is in the set of float32 values\n-1e-1000            float64     -1e-1000 rounds to IEEE -0.0 which is further simplified to 0.0\n0i                  int         0 is an integer value\n(42 + 0i)           float32     42.0 (with zero imaginary part) is in the set of float32 values\n\nx                   T           x is not representable by a value of T because\n\n0                   bool        0 is not in the set of boolean values\n'a'                 string      'a' is a rune, it is not in the set of string values\n1024                byte        1024 is not in the set of unsigned 8-bit integers\n-1                  uint16      -1 is not in the set of unsigned 16-bit integers\n1.1                 int         1.1 is not an integer value\n42i                 float32     (0 + 42i) is not in the set of float32 values\n1e1000              float64     1e1000 overflows to IEEE +Inf after rounding\n\n### Method sets\n\nThe _method set_ of a type determines the methods that can be[called](https://go.dev/ref/spec#Calls) on an [operand](https://go.dev/ref/spec#Operands) of that type. Every type has a (possibly empty) method set associated with it:\n\n* The method set of a [defined type](https://go.dev/ref/spec#Type%5Fdefinitions) `T` consists of all[methods](https://go.dev/ref/spec#Method%5Fdeclarations) declared with receiver type `T`.\n* The method set of a pointer to a defined type `T`(where `T` is neither a pointer nor an interface) is the set of all methods declared with receiver `*T` or `T`.\n* The method set of an [interface type](https://go.dev/ref/spec#Interface%5Ftypes) is the intersection of the method sets of each type in the interface's [type set](https://go.dev/ref/spec#Interface%5Ftypes)(the resulting method set is usually just the set of declared methods in the interface).\n\nFurther rules apply to structs (and pointer to structs) containing embedded fields, as described in the section on [struct types](https://go.dev/ref/spec#Struct%5Ftypes). Any other type has an empty method set.\n\nIn a method set, each method must have a[unique](https://go.dev/ref/spec#Uniqueness%5Fof%5Fidentifiers)non-[blank](https://go.dev/ref/spec#Blank%5Fidentifier) [method name](https://go.dev/ref/spec#MethodName)."}