{"lang":"Go","title":"Program initialization and execution","category":"","fullPath":"/Program_initialization_and_execution","markdown":"## Program initialization and execution\n\n### The zero value\n\nWhen storage is allocated for a [variable](https://go.dev/ref/spec#Variables), either through a declaration or a call of `new`, or when a new value is created, either through a composite literal or a call of `make`, and no explicit initialization is provided, the variable or value is given a default value. Each element of such a variable or value is set to the _zero value_ for its type: `false` for booleans,`0` for numeric types, `\"\"`for strings, and `nil` for pointers, functions, interfaces, slices, channels, and maps. This initialization is done recursively, so for instance each element of an array of structs will have its fields zeroed if no value is specified.\n\nThese two simple declarations are equivalent:\n\nvar i int\nvar i int = 0\n\nAfter\n\ntype T struct { i int; f float64; next *T }\nt := new(T)\n\nthe following holds:\n\nt.i == 0\nt.f == 0.0\nt.next == nil\n\nThe same would also be true after\n\nvar t T\n\n### Package initialization\n\nWithin a package, package-level variable initialization proceeds stepwise, with each step selecting the variable earliest in _declaration order_which has no dependencies on uninitialized variables.\n\nMore precisely, a package-level variable is considered _ready for initialization_ if it is not yet initialized and either has no [initialization expression](https://go.dev/ref/spec#Variable%5Fdeclarations) or its initialization expression has no _dependencies_ on uninitialized variables. Initialization proceeds by repeatedly initializing the next package-level variable that is earliest in declaration order and ready for initialization, until there are no variables ready for initialization.\n\nIf any variables are still uninitialized when this process ends, those variables are part of one or more initialization cycles, and the program is not valid.\n\nMultiple variables on the left-hand side of a variable declaration initialized by single (multi-valued) expression on the right-hand side are initialized together: If any of the variables on the left-hand side is initialized, all those variables are initialized in the same step.\n\nvar x = a\nvar a, b = f() // a and b are initialized together, before x is initialized\n\nFor the purpose of package initialization, [blank](https://go.dev/ref/spec#Blank%5Fidentifier)variables are treated like any other variables in declarations.\n\nThe declaration order of variables declared in multiple files is determined by the order in which the files are presented to the compiler: Variables declared in the first file are declared before any of the variables declared in the second file, and so on.\n\nDependency analysis does not rely on the actual values of the variables, only on lexical _references_ to them in the source, analyzed transitively. For instance, if a variable `x`'s initialization expression refers to a function whose body refers to variable `y` then `x` depends on `y`. Specifically:\n\n* A reference to a variable or function is an identifier denoting that variable or function.\n* A reference to a method `m` is a[method value](https://go.dev/ref/spec#Method%5Fvalues) or[method expression](https://go.dev/ref/spec#Method%5Fexpressions) of the form`t.m`, where the (static) type of `t` is not an interface type, and the method `m` is in the[method set](https://go.dev/ref/spec#Method%5Fsets) of `t`. It is immaterial whether the resulting function value`t.m` is invoked.\n* A variable, function, or method `x` depends on a variable`y` if `x`'s initialization expression or body (for functions and methods) contains a reference to `y`or to a function or method that depends on `y`.\n\nFor example, given the declarations\n\nvar (\n\ta = c + b  // == 9\n\tb = f()    // == 4\n\tc = f()    // == 5\n\td = 3      // == 5 after initialization has finished\n)\n\nfunc f() int {\n\td++\n\treturn d\n}\n\nthe initialization order is `d`, `b`, `c`, `a`. Note that the order of subexpressions in initialization expressions is irrelevant:`a = c + b` and `a = b + c` result in the same initialization order in this example.\n\nDependency analysis is performed per package; only references referring to variables, functions, and (non-interface) methods declared in the current package are considered. If other, hidden, data dependencies exists between variables, the initialization order between those variables is unspecified.\n\nFor instance, given the declarations\n\nvar x = I(T{}).ab()   // x has an undetected, hidden dependency on a and b\nvar _ = sideEffect()  // unrelated to x, a, or b\nvar a = b\nvar b = 42\n\ntype I interface      { ab() []int }\ntype T struct{}\nfunc (T) ab() []int   { return []int{a, b} }\n\nthe variable `a` will be initialized after `b` but whether `x` is initialized before `b`, between`b` and `a`, or after `a`, and thus also the moment at which `sideEffect()` is called (before or after `x` is initialized) is not specified.\n\nVariables may also be initialized using functions named `init`declared in the package block, with no arguments and no result parameters.\n\nfunc init() { … }\n\nMultiple such functions may be defined per package, even within a single source file. In the package block, the `init` identifier can be used only to declare `init` functions, yet the identifier itself is not [declared](https://go.dev/ref/spec#Declarations%5Fand%5Fscope). Thus`init` functions cannot be referred to from anywhere in a program.\n\nA package with no imports is initialized by assigning initial values to all its package-level variables followed by calling all `init`functions in the order they appear in the source, possibly in multiple files, as presented to the compiler. If a package has imports, the imported packages are initialized before initializing the package itself. If multiple packages import a package, the imported package will be initialized only once. The importing of packages, by construction, guarantees that there can be no cyclic initialization dependencies.\n\nPackage initialization—variable initialization and the invocation of`init` functions—happens in a single goroutine, sequentially, one package at a time. An `init` function may launch other goroutines, which can run concurrently with the initialization code. However, initialization always sequences the `init` functions: it will not invoke the next one until the previous one has returned.\n\nTo ensure reproducible initialization behavior, build systems are encouraged to present multiple files belonging to the same package in lexical file name order to a compiler.\n\n### Program execution\n\nA complete program is created by linking a single, unimported package called the _main package_ with all the packages it imports, transitively. The main package must have package name `main` and declare a function `main` that takes no arguments and returns no value.\n\nfunc main() { … }\n\nProgram execution begins by initializing the main package and then invoking the function `main`. When that function invocation returns, the program exits. It does not wait for other (non-`main`) goroutines to complete."}