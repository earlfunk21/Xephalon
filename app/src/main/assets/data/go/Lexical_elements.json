{"lang":"Go","title":"Lexical elements","category":"","fullPath":"/Lexical_elements","markdown":"## Lexical elements\n\n### Comments\n\nComments serve as program documentation. There are two forms:\n\n1. _Line comments_ start with the character sequence `//`and stop at the end of the line.\n2. _General comments_ start with the character sequence `/*`and stop with the first subsequent character sequence `*/`.\n\nA comment cannot start inside a [rune](https://go.dev/ref/spec#Rune%5Fliterals) or[string literal](https://go.dev/ref/spec#String%5Fliterals), or inside a comment. A general comment containing no newlines acts like a space. Any other comment acts like a newline.\n\n### Tokens\n\nTokens form the vocabulary of the Go language. There are four classes: _identifiers_, _keywords_, _operators and punctuation_, and _literals_. _White space_, formed from spaces (U+0020), horizontal tabs (U+0009), carriage returns (U+000D), and newlines (U+000A), is ignored except as it separates tokens that would otherwise combine into a single token. Also, a newline or end of file may trigger the insertion of a [semicolon](https://go.dev/ref/spec#Semicolons). While breaking the input into tokens, the next token is the longest sequence of characters that form a valid token.\n\n### Semicolons\n\nThe formal syntax uses semicolons `\";\"` as terminators in a number of productions. Go programs may omit most of these semicolons using the following two rules:\n\n1. When the input is broken into tokens, a semicolon is automatically inserted into the token stream immediately after a line's final token if that token is  \n   * an[identifier](https://go.dev/ref/spec#Identifiers)  \n   * an[integer](https://go.dev/ref/spec#Integer%5Fliterals),[floating-point](https://go.dev/ref/spec#Floating-point%5Fliterals),[imaginary](https://go.dev/ref/spec#Imaginary%5Fliterals),[rune](https://go.dev/ref/spec#Rune%5Fliterals), or[string](https://go.dev/ref/spec#String%5Fliterals) literal  \n   * one of the [keywords](https://go.dev/ref/spec#Keywords) `break`,`continue`,`fallthrough`, or`return`  \n   * one of the [operators and punctuation](https://go.dev/ref/spec#Operators%5Fand%5Fpunctuation) `++`,`--`,`)`,`]`, or`}`\n2. To allow complex statements to occupy a single line, a semicolon may be omitted before a closing `\")\"` or `\"}\"`.\n\nTo reflect idiomatic use, code examples in this document elide semicolons using these rules.\n\n### Identifiers\n\nIdentifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and digits. The first character in an identifier must be a letter.\n\nidentifier = [letter](https://go.dev/ref/spec#letter) { [letter](https://go.dev/ref/spec#letter) | [unicode_digit](https://go.dev/ref/spec#unicode%5Fdigit) } .\n\na\n_x9\nThisVariableIsExported\nαβ\n\nSome identifiers are [predeclared](https://go.dev/ref/spec#Predeclared%5Fidentifiers).\n\n### Keywords\n\nThe following keywords are reserved and may not be used as identifiers.\n\nbreak        default      func         interface    select\ncase         defer        go           map          struct\nchan         else         goto         package      switch\nconst        fallthrough  if           range        type\ncontinue     for          import       return       var\n\n### Operators and punctuation\n\nThe following character sequences represent [operators](https://go.dev/ref/spec#Operators)(including [assignment operators](https://go.dev/ref/spec#Assignment%5Fstatements)) and punctuation:\n\n+    &     +=    &=     &&    ==    !=    (    )\n-    |     -=    |=     ||    <     <=    [    ]\n*    ^     *=    ^=     <-    >     >=    {    }\n/    <<    /=    <<=    ++    =     :=    ,    ;\n%    >>    %=    >>=    --    !     ...   .    :\n     &^          &^=          ~\n\n### Integer literals\n\nAn integer literal is a sequence of digits representing an[integer constant](https://go.dev/ref/spec#Constants). An optional prefix sets a non-decimal base: `0b` or `0B`for binary, `0`, `0o`, or `0O` for octal, and `0x` or `0X` for hexadecimal. A single `0` is considered a decimal zero. In hexadecimal literals, letters `a` through `f`and `A` through `F` represent values 10 through 15.\n\nFor readability, an underscore character `_` may appear after a base prefix or between successive digits; such underscores do not change the literal's value.\n\nint_lit        = [decimal_lit](https://go.dev/ref/spec#decimal%5Flit) | [binary_lit](https://go.dev/ref/spec#binary%5Flit) | [octal_lit](https://go.dev/ref/spec#octal%5Flit) | [hex_lit](https://go.dev/ref/spec#hex%5Flit) .\ndecimal_lit    = \"0\" | ( \"1\" … \"9\" ) [ [ \"_\" ] [decimal_digits](https://go.dev/ref/spec#decimal%5Fdigits) ] .\nbinary_lit     = \"0\" ( \"b\" | \"B\" ) [ \"_\" ] [binary_digits](https://go.dev/ref/spec#binary%5Fdigits) .\noctal_lit      = \"0\" [ \"o\" | \"O\" ] [ \"_\" ] [octal_digits](https://go.dev/ref/spec#octal%5Fdigits) .\nhex_lit        = \"0\" ( \"x\" | \"X\" ) [ \"_\" ] [hex_digits](https://go.dev/ref/spec#hex%5Fdigits) .\n\ndecimal_digits = [decimal_digit](https://go.dev/ref/spec#decimal%5Fdigit) { [ \"_\" ] [decimal_digit](https://go.dev/ref/spec#decimal%5Fdigit) } .\nbinary_digits  = [binary_digit](https://go.dev/ref/spec#binary%5Fdigit) { [ \"_\" ] [binary_digit](https://go.dev/ref/spec#binary%5Fdigit) } .\noctal_digits   = [octal_digit](https://go.dev/ref/spec#octal%5Fdigit) { [ \"_\" ] [octal_digit](https://go.dev/ref/spec#octal%5Fdigit) } .\nhex_digits     = [hex_digit](https://go.dev/ref/spec#hex%5Fdigit) { [ \"_\" ] [hex_digit](https://go.dev/ref/spec#hex%5Fdigit) } .\n\n42\n4_2\n0600\n0_600\n0o600\n0O600       // second character is capital letter 'O'\n0xBadFace\n0xBad_Face\n0x_67_7a_2f_cc_40_c6\n170141183460469231731687303715884105727\n170_141183_460469_231731_687303_715884_105727\n\n_42         // an identifier, not an integer literal\n42_         // invalid: _ must separate successive digits\n4__2        // invalid: only one _ at a time\n0_xBadFace  // invalid: _ must separate successive digits\n\n### Floating-point literals\n\nA floating-point literal is a decimal or hexadecimal representation of a[floating-point constant](https://go.dev/ref/spec#Constants).\n\nA decimal floating-point literal consists of an integer part (decimal digits), a decimal point, a fractional part (decimal digits), and an exponent part (`e` or `E` followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; one of the decimal point or the exponent part may be elided. An exponent value exp scales the mantissa (integer and fractional part) by 10exp.\n\nA hexadecimal floating-point literal consists of a `0x` or `0X`prefix, an integer part (hexadecimal digits), a radix point, a fractional part (hexadecimal digits), and an exponent part (`p` or `P` followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; the radix point may be elided as well, but the exponent part is required. (This syntax matches the one given in IEEE 754-2008 §5.12.3.) An exponent value exp scales the mantissa (integer and fractional part) by 2exp.\n\nFor readability, an underscore character `_` may appear after a base prefix or between successive digits; such underscores do not change the literal value.\n\nfloat_lit         = [decimal_float_lit](https://go.dev/ref/spec#decimal%5Ffloat%5Flit) | [hex_float_lit](https://go.dev/ref/spec#hex%5Ffloat%5Flit) .\n\ndecimal_float_lit = [decimal_digits](https://go.dev/ref/spec#decimal%5Fdigits) \".\" [ [decimal_digits](https://go.dev/ref/spec#decimal%5Fdigits) ] [ [decimal_exponent](https://go.dev/ref/spec#decimal%5Fexponent) ] |\n                    [decimal_digits](https://go.dev/ref/spec#decimal%5Fdigits) [decimal_exponent](https://go.dev/ref/spec#decimal%5Fexponent) |\n                    \".\" [decimal_digits](https://go.dev/ref/spec#decimal%5Fdigits) [ [decimal_exponent](https://go.dev/ref/spec#decimal%5Fexponent) ] .\ndecimal_exponent  = ( \"e\" | \"E\" ) [ \"+\" | \"-\" ] [decimal_digits](https://go.dev/ref/spec#decimal%5Fdigits) .\n\nhex_float_lit     = \"0\" ( \"x\" | \"X\" ) [hex_mantissa](https://go.dev/ref/spec#hex%5Fmantissa) [hex_exponent](https://go.dev/ref/spec#hex%5Fexponent) .\nhex_mantissa      = [ \"_\" ] [hex_digits](https://go.dev/ref/spec#hex%5Fdigits) \".\" [ [hex_digits](https://go.dev/ref/spec#hex%5Fdigits) ] |\n                    [ \"_\" ] [hex_digits](https://go.dev/ref/spec#hex%5Fdigits) |\n                    \".\" [hex_digits](https://go.dev/ref/spec#hex%5Fdigits) .\nhex_exponent      = ( \"p\" | \"P\" ) [ \"+\" | \"-\" ] [decimal_digits](https://go.dev/ref/spec#decimal%5Fdigits) .\n\n0.\n72.40\n072.40       // == 72.40\n2.71828\n1.e+0\n6.67428e-11\n1E6\n.25\n.12345E+5\n1_5.         // == 15.0\n0.15e+0_2    // == 15.0\n\n0x1p-2       // == 0.25\n0x2.p10      // == 2048.0\n0x1.Fp+0     // == 1.9375\n0X.8p-0      // == 0.5\n0X_1FFFP-16  // == 0.1249847412109375\n0x15e-2      // == 0x15e - 2 (integer subtraction)\n\n0x.p1        // invalid: mantissa has no digits\n1p-2         // invalid: p exponent requires hexadecimal mantissa\n0x1.5e-2     // invalid: hexadecimal mantissa requires p exponent\n1_.5         // invalid: _ must separate successive digits\n1._5         // invalid: _ must separate successive digits\n1.5_e1       // invalid: _ must separate successive digits\n1.5e_1       // invalid: _ must separate successive digits\n1.5e1_       // invalid: _ must separate successive digits\n\n### Imaginary literals\n\nAn imaginary literal represents the imaginary part of a[complex constant](https://go.dev/ref/spec#Constants). It consists of an [integer](https://go.dev/ref/spec#Integer%5Fliterals) or[floating-point](https://go.dev/ref/spec#Floating-point%5Fliterals) literal followed by the lowercase letter `i`. The value of an imaginary literal is the value of the respective integer or floating-point literal multiplied by the imaginary unit _i_.\n\nimaginary_lit = ([decimal_digits](https://go.dev/ref/spec#decimal%5Fdigits) | [int_lit](https://go.dev/ref/spec#int%5Flit) | [float_lit](https://go.dev/ref/spec#float%5Flit)) \"i\" .\n\nFor backward compatibility, an imaginary literal's integer part consisting entirely of decimal digits (and possibly underscores) is considered a decimal integer, even if it starts with a leading `0`.\n\n0i\n0123i         // == 123i for backward-compatibility\n0o123i        // == 0o123 * 1i == 83i\n0xabci        // == 0xabc * 1i == 2748i\n0.i\n2.71828i\n1.e+0i\n6.67428e-11i\n1E6i\n.25i\n.12345E+5i\n0x1p-2i       // == 0x1p-2 * 1i == 0.25i\n\n### Rune literals\n\nA rune literal represents a [rune constant](https://go.dev/ref/spec#Constants), an integer value identifying a Unicode code point. A rune literal is expressed as one or more characters enclosed in single quotes, as in `'x'` or `'\\n'`. Within the quotes, any character may appear except newline and unescaped single quote. A single quoted character represents the Unicode value of the character itself, while multi-character sequences beginning with a backslash encode values in various formats.\n\nThe simplest form represents the single character within the quotes; since Go source text is Unicode characters encoded in UTF-8, multiple UTF-8-encoded bytes may represent a single integer value. For instance, the literal `'a'` holds a single byte representing a literal `a`, Unicode U+0061, value `0x61`, while`'ä'` holds two bytes (`0xc3` `0xa4`) representing a literal `a`\\-dieresis, U+00E4, value `0xe4`.\n\nSeveral backslash escapes allow arbitrary values to be encoded as ASCII text. There are four ways to represent the integer value as a numeric constant: `\\x` followed by exactly two hexadecimal digits; `\\u` followed by exactly four hexadecimal digits;`\\U` followed by exactly eight hexadecimal digits, and a plain backslash `\\` followed by exactly three octal digits. In each case the value of the literal is the value represented by the digits in the corresponding base.\n\nAlthough these representations all result in an integer, they have different valid ranges. Octal escapes must represent a value between 0 and 255 inclusive. Hexadecimal escapes satisfy this condition by construction. The escapes `\\u` and `\\U`represent Unicode code points so within them some values are illegal, in particular those above `0x10FFFF` and surrogate halves.\n\nAfter a backslash, certain single-character escapes represent special values:\n\n\\a   U+0007 alert or bell\n\\b   U+0008 backspace\n\\f   U+000C form feed\n\\n   U+000A line feed or newline\n\\r   U+000D carriage return\n\\t   U+0009 horizontal tab\n\\v   U+000B vertical tab\n\\\\   U+005C backslash\n\\'   U+0027 single quote  (valid escape only within rune literals)\n\\\"   U+0022 double quote  (valid escape only within string literals)\n\nAn unrecognized character following a backslash in a rune literal is illegal.\n\nrune_lit         = \"'\" ( [unicode_value](https://go.dev/ref/spec#unicode%5Fvalue) | [byte_value](https://go.dev/ref/spec#byte%5Fvalue) ) \"'\" .\nunicode_value    = [unicode_char](https://go.dev/ref/spec#unicode%5Fchar) | [little_u_value](https://go.dev/ref/spec#little%5Fu%5Fvalue) | [big_u_value](https://go.dev/ref/spec#big%5Fu%5Fvalue) | [escaped_char](https://go.dev/ref/spec#escaped%5Fchar) .\nbyte_value       = [octal_byte_value](https://go.dev/ref/spec#octal%5Fbyte%5Fvalue) | [hex_byte_value](https://go.dev/ref/spec#hex%5Fbyte%5Fvalue) .\noctal_byte_value = `\\` [octal_digit](https://go.dev/ref/spec#octal%5Fdigit) [octal_digit](https://go.dev/ref/spec#octal%5Fdigit) [octal_digit](https://go.dev/ref/spec#octal%5Fdigit) .\nhex_byte_value   = `\\` \"x\" [hex_digit](https://go.dev/ref/spec#hex%5Fdigit) [hex_digit](https://go.dev/ref/spec#hex%5Fdigit) .\nlittle_u_value   = `\\` \"u\" [hex_digit](https://go.dev/ref/spec#hex%5Fdigit) [hex_digit](https://go.dev/ref/spec#hex%5Fdigit) [hex_digit](https://go.dev/ref/spec#hex%5Fdigit) [hex_digit](https://go.dev/ref/spec#hex%5Fdigit) .\nbig_u_value      = `\\` \"U\" [hex_digit](https://go.dev/ref/spec#hex%5Fdigit) [hex_digit](https://go.dev/ref/spec#hex%5Fdigit) [hex_digit](https://go.dev/ref/spec#hex%5Fdigit) [hex_digit](https://go.dev/ref/spec#hex%5Fdigit)\n                           [hex_digit](https://go.dev/ref/spec#hex%5Fdigit) [hex_digit](https://go.dev/ref/spec#hex%5Fdigit) [hex_digit](https://go.dev/ref/spec#hex%5Fdigit) [hex_digit](https://go.dev/ref/spec#hex%5Fdigit) .\nescaped_char     = `\\` ( \"a\" | \"b\" | \"f\" | \"n\" | \"r\" | \"t\" | \"v\" | `\\` | \"'\" | `\"` ) .\n\n'a'\n'ä'\n'本'\n'\\t'\n'\\000'\n'\\007'\n'\\377'\n'\\x07'\n'\\xff'\n'\\u12e4'\n'\\U00101234'\n'\\''         // rune literal containing single quote character\n'aa'         // illegal: too many characters\n'\\k'         // illegal: k is not recognized after a backslash\n'\\xa'        // illegal: too few hexadecimal digits\n'\\0'         // illegal: too few octal digits\n'\\400'       // illegal: octal value over 255\n'\\uDFFF'     // illegal: surrogate half\n'\\U00110000' // illegal: invalid Unicode code point\n\n### String literals\n\nA string literal represents a [string constant](https://go.dev/ref/spec#Constants)obtained from concatenating a sequence of characters. There are two forms: raw string literals and interpreted string literals.\n\nRaw string literals are character sequences between back quotes, as in`` `foo` ``. Within the quotes, any character may appear except back quote. The value of a raw string literal is the string composed of the uninterpreted (implicitly UTF-8-encoded) characters between the quotes; in particular, backslashes have no special meaning and the string may contain newlines. Carriage return characters ('\\\\r') inside raw string literals are discarded from the raw string value.\n\nInterpreted string literals are character sequences between double quotes, as in `\"bar\"`. Within the quotes, any character may appear except newline and unescaped double quote. The text between the quotes forms the value of the literal, with backslash escapes interpreted as they are in [rune literals](https://go.dev/ref/spec#Rune%5Fliterals) (except that `\\'` is illegal and`\\\"` is legal), with the same restrictions. The three-digit octal (`\\`_nnn_) and two-digit hexadecimal (`\\x`_nn_) escapes represent individual_bytes_ of the resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of individual _characters_. Thus inside a string literal `\\377` and `\\xFF` represent a single byte of value `0xFF`\\=255, while `ÿ`,`\\u00FF`, `\\U000000FF` and `\\xc3\\xbf` represent the two bytes `0xc3` `0xbf` of the UTF-8 encoding of character U+00FF.\n\nstring_lit             = [raw_string_lit](https://go.dev/ref/spec#raw%5Fstring%5Flit) | [interpreted_string_lit](https://go.dev/ref/spec#interpreted%5Fstring%5Flit) .\nraw_string_lit         = \"`\" { [unicode_char](https://go.dev/ref/spec#unicode%5Fchar) | [newline](https://go.dev/ref/spec#newline) } \"`\" .\ninterpreted_string_lit = `\"` { [unicode_value](https://go.dev/ref/spec#unicode%5Fvalue) | [byte_value](https://go.dev/ref/spec#byte%5Fvalue) } `\"` .\n\n`abc`                // same as \"abc\"\n`\\n\n\\n`                  // same as \"\\\\n\\n\\\\n\"\n\"\\n\"\n\"\\\"\"                 // same as `\"`\n\"Hello, world!\\n\"\n\"日本語\"\n\"\\u65e5本\\U00008a9e\"\n\"\\xff\\u00FF\"\n\"\\uD800\"             // illegal: surrogate half\n\"\\U00110000\"         // illegal: invalid Unicode code point\n\nThese examples all represent the same string:\n\n\"日本語\"                                 // UTF-8 input text\n`日本語`                                 // UTF-8 input text as a raw literal\n\"\\u65e5\\u672c\\u8a9e\"                    // the explicit Unicode code points\n\"\\U000065e5\\U0000672c\\U00008a9e\"        // the explicit Unicode code points\n\"\\xe6\\x97\\xa5\\xe6\\x9c\\xac\\xe8\\xaa\\x9e\"  // the explicit UTF-8 bytes\n\nIf the source code represents a character as two code points, such as a combining form involving an accent and a letter, the result will be an error if placed in a rune literal (it is not a single code point), and will appear as two code points if placed in a string literal."}