{"lang":"Go","title":"Expressions","category":"","fullPath":"/Expressions","markdown":"## Expressions\n\nAn expression specifies the computation of a value by applying operators and functions to operands.\n\n### Operands\n\nOperands denote the elementary values in an expression. An operand may be a literal, a (possibly [qualified](https://go.dev/ref/spec#Qualified%5Fidentifiers)) non-[blank](https://go.dev/ref/spec#Blank%5Fidentifier) identifier denoting a[constant](https://go.dev/ref/spec#Constant%5Fdeclarations),[variable](https://go.dev/ref/spec#Variable%5Fdeclarations), or[function](https://go.dev/ref/spec#Function%5Fdeclarations), or a parenthesized expression.\n\nOperand     = [Literal](https://go.dev/ref/spec#Literal) | [OperandName](https://go.dev/ref/spec#OperandName) [ [TypeArgs](https://go.dev/ref/spec#TypeArgs) ] | \"(\" [Expression](https://go.dev/ref/spec#Expression) \")\" .\nLiteral     = [BasicLit](https://go.dev/ref/spec#BasicLit) | [CompositeLit](https://go.dev/ref/spec#CompositeLit) | [FunctionLit](https://go.dev/ref/spec#FunctionLit) .\nBasicLit    = [int_lit](https://go.dev/ref/spec#int%5Flit) | [float_lit](https://go.dev/ref/spec#float%5Flit) | [imaginary_lit](https://go.dev/ref/spec#imaginary%5Flit) | [rune_lit](https://go.dev/ref/spec#rune%5Flit) | [string_lit](https://go.dev/ref/spec#string%5Flit) .\nOperandName = [identifier](https://go.dev/ref/spec#identifier) | [QualifiedIdent](https://go.dev/ref/spec#QualifiedIdent) .\n\nAn operand name denoting a [generic function](https://go.dev/ref/spec#Function%5Fdeclarations)may be followed by a list of [type arguments](https://go.dev/ref/spec#Instantiations); the resulting operand is an [instantiated](https://go.dev/ref/spec#Instantiations) function.\n\nThe [blank identifier](https://go.dev/ref/spec#Blank%5Fidentifier) may appear as an operand only on the left-hand side of an [assignment statement](https://go.dev/ref/spec#Assignment%5Fstatements).\n\nImplementation restriction: A compiler need not report an error if an operand's type is a [type parameter](https://go.dev/ref/spec#Type%5Fparameter%5Fdeclarations) with an empty[type set](https://go.dev/ref/spec#Interface%5Ftypes). Functions with such type parameters cannot be [instantiated](https://go.dev/ref/spec#Instantiations); any attempt will lead to an error at the instantiation site.\n\n### Qualified identifiers\n\nA _qualified identifier_ is an identifier qualified with a package name prefix. Both the package name and the identifier must not be[blank](https://go.dev/ref/spec#Blank%5Fidentifier).\n\nQualifiedIdent = [PackageName](https://go.dev/ref/spec#PackageName) \".\" [identifier](https://go.dev/ref/spec#identifier) .\n\nA qualified identifier accesses an identifier in a different package, which must be [imported](https://go.dev/ref/spec#Import%5Fdeclarations). The identifier must be [exported](https://go.dev/ref/spec#Exported%5Fidentifiers) and declared in the [package block](https://go.dev/ref/spec#Blocks) of that package.\n\nmath.Sin // denotes the Sin function in package math\n\n### Composite literals\n\nComposite literals construct new composite values each time they are evaluated. They consist of the type of the literal followed by a brace-bound list of elements. Each element may optionally be preceded by a corresponding key.\n\nCompositeLit  = [LiteralType](https://go.dev/ref/spec#LiteralType) [LiteralValue](https://go.dev/ref/spec#LiteralValue) .\nLiteralType   = [StructType](https://go.dev/ref/spec#StructType) | [ArrayType](https://go.dev/ref/spec#ArrayType) | \"[\" \"...\" \"]\" [ElementType](https://go.dev/ref/spec#ElementType) |\n                [SliceType](https://go.dev/ref/spec#SliceType) | [MapType](https://go.dev/ref/spec#MapType) | [TypeName](https://go.dev/ref/spec#TypeName) [ [TypeArgs](https://go.dev/ref/spec#TypeArgs) ] .\nLiteralValue  = \"{\" [ [ElementList](https://go.dev/ref/spec#ElementList) [ \",\" ] ] \"}\" .\nElementList   = [KeyedElement](https://go.dev/ref/spec#KeyedElement) { \",\" [KeyedElement](https://go.dev/ref/spec#KeyedElement) } .\nKeyedElement  = [ [Key](https://go.dev/ref/spec#Key) \":\" ] [Element](https://go.dev/ref/spec#Element) .\nKey           = [FieldName](https://go.dev/ref/spec#FieldName) | [Expression](https://go.dev/ref/spec#Expression) | [LiteralValue](https://go.dev/ref/spec#LiteralValue) .\nFieldName     = [identifier](https://go.dev/ref/spec#identifier) .\nElement       = [Expression](https://go.dev/ref/spec#Expression) | [LiteralValue](https://go.dev/ref/spec#LiteralValue) .\n\nThe LiteralType's [core type](https://go.dev/ref/spec#Core%5Ftypes) `T`must be a struct, array, slice, or map type (the syntax enforces this constraint except when the type is given as a TypeName). The types of the elements and keys must be [assignable](https://go.dev/ref/spec#Assignability)to the respective field, element, and key types of type `T`; there is no additional conversion. The key is interpreted as a field name for struct literals, an index for array and slice literals, and a key for map literals. For map literals, all elements must have a key. It is an error to specify multiple elements with the same field name or constant key value. For non-constant map keys, see the section on[evaluation order](https://go.dev/ref/spec#Order%5Fof%5Fevaluation).\n\nFor struct literals the following rules apply:\n\n* A key must be a field name declared in the struct type.\n* An element list that does not contain any keys must list an element for each struct field in the order in which the fields are declared.\n* If any element has a key, every element must have a key.\n* An element list that contains keys does not need to have an element for each struct field. Omitted fields get the zero value for that field.\n* A literal may omit the element list; such a literal evaluates to the zero value for its type.\n* It is an error to specify an element for a non-exported field of a struct belonging to a different package.\n\nGiven the declarations\n\ntype Point3D struct { x, y, z float64 }\ntype Line struct { p, q Point3D }\n\none may write\n\norigin := Point3D{}                            // zero value for Point3D\nline := Line{origin, Point3D{y: -4, z: 12.3}}  // zero value for line.q.x\n\nFor array and slice literals the following rules apply:\n\n* Each element has an associated integer index marking its position in the array.\n* An element with a key uses the key as its index. The key must be a non-negative constant[representable](https://go.dev/ref/spec#Representability) by a value of type `int`; and if it is typed it must be of [integer type](https://go.dev/ref/spec#Numeric%5Ftypes).\n* An element without a key uses the previous element's index plus one. If the first element has no key, its index is zero.\n\n[Taking the address](https://go.dev/ref/spec#Address%5Foperators) of a composite literal generates a pointer to a unique [variable](https://go.dev/ref/spec#Variables) initialized with the literal's value.\n\nvar pointer *Point3D = &Point3D{y: 1000}\n\nNote that the [zero value](https://go.dev/ref/spec#The%5Fzero%5Fvalue) for a slice or map type is not the same as an initialized but empty value of the same type. Consequently, taking the address of an empty slice or map composite literal does not have the same effect as allocating a new slice or map value with[new](https://go.dev/ref/spec#Allocation).\n\np1 := &[]int{}    // p1 points to an initialized, empty slice with value []int{} and length 0\np2 := new([]int)  // p2 points to an uninitialized slice with value nil and length 0\n\nThe length of an array literal is the length specified in the literal type. If fewer elements than the length are provided in the literal, the missing elements are set to the zero value for the array element type. It is an error to provide elements with index values outside the index range of the array. The notation `...` specifies an array length equal to the maximum element index plus one.\n\nbuffer := [10]string{}             // len(buffer) == 10\nintSet := [6]int{1, 2, 3, 5}       // len(intSet) == 6\ndays := [...]string{\"Sat\", \"Sun\"}  // len(days) == 2\n\nA slice literal describes the entire underlying array literal. Thus the length and capacity of a slice literal are the maximum element index plus one. A slice literal has the form\n\n[]T{x1, x2, … xn}\n\nand is shorthand for a slice operation applied to an array:\n\ntmp := [n]T{x1, x2, … xn}\ntmp[0 : n]\n\nWithin a composite literal of array, slice, or map type `T`, elements or map keys that are themselves composite literals may elide the respective literal type if it is identical to the element or key type of `T`. Similarly, elements or keys that are addresses of composite literals may elide the `&T` when the element or key type is `*T`.\n\n[...]Point{{1.5, -3.5}, {0, 0}}     // same as [...]Point{Point{1.5, -3.5}, Point{0, 0}}\n[][]int{{1, 2, 3}, {4, 5}}          // same as [][]int{[]int{1, 2, 3}, []int{4, 5}}\n[][]Point{{{0, 1}, {1, 2}}}         // same as [][]Point{[]Point{Point{0, 1}, Point{1, 2}}}\nmap[string]Point{\"orig\": {0, 0}}    // same as map[string]Point{\"orig\": Point{0, 0}}\nmap[Point]string{{0, 0}: \"orig\"}    // same as map[Point]string{Point{0, 0}: \"orig\"}\n\ntype PPoint *Point\n[2]*Point{{1.5, -3.5}, {}}          // same as [2]*Point{&Point{1.5, -3.5}, &Point{}}\n[2]PPoint{{1.5, -3.5}, {}}          // same as [2]PPoint{PPoint(&Point{1.5, -3.5}), PPoint(&Point{})}\n\nA parsing ambiguity arises when a composite literal using the TypeName form of the LiteralType appears as an operand between the[keyword](https://go.dev/ref/spec#Keywords) and the opening brace of the block of an \"if\", \"for\", or \"switch\" statement, and the composite literal is not enclosed in parentheses, square brackets, or curly braces. In this rare case, the opening brace of the literal is erroneously parsed as the one introducing the block of statements. To resolve the ambiguity, the composite literal must appear within parentheses.\n\nif x == (T{a,b,c}[i]) { … }\nif (x == T{a,b,c}[i]) { … }\n\nExamples of valid array, slice, and map literals:\n\n// list of prime numbers\nprimes := []int{2, 3, 5, 7, 9, 2147483647}\n\n// vowels[ch] is true if ch is a vowel\nvowels := [128]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'y': true}\n\n// the array [10]float32{-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1}\nfilter := [10]float32{-1, 4: -0.1, -0.1, 9: -1}\n\n// frequencies in Hz for equal-tempered scale (A4 = 440Hz)\nnoteFrequency := map[string]float32{\n\t\"C0\": 16.35, \"D0\": 18.35, \"E0\": 20.60, \"F0\": 21.83,\n\t\"G0\": 24.50, \"A0\": 27.50, \"B0\": 30.87,\n}\n\n### Function literals\n\nA function literal represents an anonymous [function](https://go.dev/ref/spec#Function%5Fdeclarations). Function literals cannot declare type parameters.\n\nFunctionLit = \"func\" [Signature](https://go.dev/ref/spec#Signature) [FunctionBody](https://go.dev/ref/spec#FunctionBody) .\n\nfunc(a, b int, z float64) bool { return a*b < int(z) }\n\nA function literal can be assigned to a variable or invoked directly.\n\nf := func(x, y int) int { return x + y }\nfunc(ch chan int) { ch <- ACK }(replyChan)\n\nFunction literals are _closures_: they may refer to variables defined in a surrounding function. Those variables are then shared between the surrounding function and the function literal, and they survive as long as they are accessible.\n\n### Primary expressions\n\nPrimary expressions are the operands for unary and binary expressions.\n\nPrimaryExpr =\n\t[Operand](https://go.dev/ref/spec#Operand) |\n\t[Conversion](https://go.dev/ref/spec#Conversion) |\n\t[MethodExpr](https://go.dev/ref/spec#MethodExpr) |\n\t[PrimaryExpr](https://go.dev/ref/spec#PrimaryExpr) [Selector](https://go.dev/ref/spec#Selector) |\n\t[PrimaryExpr](https://go.dev/ref/spec#PrimaryExpr) [Index](https://go.dev/ref/spec#Index) |\n\t[PrimaryExpr](https://go.dev/ref/spec#PrimaryExpr) [Slice](https://go.dev/ref/spec#Slice) |\n\t[PrimaryExpr](https://go.dev/ref/spec#PrimaryExpr) [TypeAssertion](https://go.dev/ref/spec#TypeAssertion) |\n\t[PrimaryExpr](https://go.dev/ref/spec#PrimaryExpr) [Arguments](https://go.dev/ref/spec#Arguments) .\n\nSelector       = \".\" [identifier](https://go.dev/ref/spec#identifier) .\nIndex          = \"[\" [Expression](https://go.dev/ref/spec#Expression) [ \",\" ] \"]\" .\nSlice          = \"[\" [ [Expression](https://go.dev/ref/spec#Expression) ] \":\" [ [Expression](https://go.dev/ref/spec#Expression) ] \"]\" |\n                 \"[\" [ [Expression](https://go.dev/ref/spec#Expression) ] \":\" [Expression](https://go.dev/ref/spec#Expression) \":\" [Expression](https://go.dev/ref/spec#Expression) \"]\" .\nTypeAssertion  = \".\" \"(\" [Type](https://go.dev/ref/spec#Type) \")\" .\nArguments      = \"(\" [ ( [ExpressionList](https://go.dev/ref/spec#ExpressionList) | [Type](https://go.dev/ref/spec#Type) [ \",\" [ExpressionList](https://go.dev/ref/spec#ExpressionList) ] ) [ \"...\" ] [ \",\" ] ] \")\" .\n\nx\n2\n(s + \".txt\")\nf(3.1415, true)\nPoint{1, 2}\nm[\"foo\"]\ns[i : j + 1]\nobj.color\nf.p[i].x()\n\n### Selectors\n\nFor a [primary expression](https://go.dev/ref/spec#Primary%5Fexpressions) `x`that is not a [package name](https://go.dev/ref/spec#Package%5Fclause), the_selector expression_ \n\nx.f\n\ndenotes the field or method `f` of the value `x`(or sometimes `*x`; see below). The identifier `f` is called the (field or method) _selector_; it must not be the [blank identifier](https://go.dev/ref/spec#Blank%5Fidentifier). The type of the selector expression is the type of `f`. If `x` is a package name, see the section on[qualified identifiers](https://go.dev/ref/spec#Qualified%5Fidentifiers).\n\nA selector `f` may denote a field or method `f` of a type `T`, or it may refer to a field or method `f` of a nested[embedded field](https://go.dev/ref/spec#Struct%5Ftypes) of `T`. The number of embedded fields traversed to reach `f` is called its _depth_ in `T`. The depth of a field or method `f`declared in `T` is zero. The depth of a field or method `f` declared in an embedded field `A` in `T` is the depth of `f` in `A` plus one.\n\nThe following rules apply to selectors:\n\n1. For a value `x` of type `T` or `*T`where `T` is not a pointer or interface type,`x.f` denotes the field or method at the shallowest depth in `T` where there is such an `f`. If there is not exactly [one f](https://go.dev/ref/spec#Uniqueness%5Fof%5Fidentifiers)with shallowest depth, the selector expression is illegal.\n2. For a value `x` of type `I` where `I`is an interface type, `x.f` denotes the actual method with name`f` of the dynamic value of `x`. If there is no method with name `f` in the[method set](https://go.dev/ref/spec#Method%5Fsets) of `I`, the selector expression is illegal.\n3. As an exception, if the type of `x` is a [defined](https://go.dev/ref/spec#Type%5Fdefinitions)pointer type and `(*x).f` is a valid selector expression denoting a field (but not a method), `x.f` is shorthand for `(*x).f`.\n4. In all other cases, `x.f` is illegal.\n5. If `x` is of pointer type and has the value`nil` and `x.f` denotes a struct field, assigning to or evaluating `x.f`causes a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics).\n6. If `x` is of interface type and has the value`nil`, [calling](https://go.dev/ref/spec#Calls) or[evaluating](https://go.dev/ref/spec#Method%5Fvalues) the method `x.f`causes a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics).\n\nFor example, given the declarations:\n\ntype T0 struct {\n\tx int\n}\n\nfunc (*T0) M0()\n\ntype T1 struct {\n\ty int\n}\n\nfunc (T1) M1()\n\ntype T2 struct {\n\tz int\n\tT1\n\t*T0\n}\n\nfunc (*T2) M2()\n\ntype Q *T2\n\nvar t T2     // with t.T0 != nil\nvar p *T2    // with p != nil and (*p).T0 != nil\nvar q Q = p\n\none may write:\n\nt.z          // t.z\nt.y          // t.T1.y\nt.x          // (*t.T0).x\n\np.z          // (*p).z\np.y          // (*p).T1.y\np.x          // (*(*p).T0).x\n\nq.x          // (*(*q).T0).x        (*q).x is a valid field selector\n\np.M0()       // ((*p).T0).M0()      M0 expects *T0 receiver\np.M1()       // ((*p).T1).M1()      M1 expects T1 receiver\np.M2()       // p.M2()              M2 expects *T2 receiver\nt.M2()       // (&t).M2()           M2 expects *T2 receiver, see section on Calls\n\nbut the following is invalid:\n\nq.M0()       // (*q).M0 is valid but not a field selector\n\n### Method expressions\n\nIf `M` is in the [method set](https://go.dev/ref/spec#Method%5Fsets) of type `T`,`T.M` is a function that is callable as a regular function with the same arguments as `M` prefixed by an additional argument that is the receiver of the method.\n\nMethodExpr    = [ReceiverType](https://go.dev/ref/spec#ReceiverType) \".\" [MethodName](https://go.dev/ref/spec#MethodName) .\nReceiverType  = [Type](https://go.dev/ref/spec#Type) .\n\nConsider a struct type `T` with two methods,`Mv`, whose receiver is of type `T`, and`Mp`, whose receiver is of type `*T`.\n\ntype T struct {\n\ta int\n}\nfunc (tv  T) Mv(a int) int         { return 0 }  // value receiver\nfunc (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver\n\nvar t T\n\nThe expression\n\nT.Mv\n\nyields a function equivalent to `Mv` but with an explicit receiver as its first argument; it has signature\n\nfunc(tv T, a int) int\n\nThat function may be called normally with an explicit receiver, so these five invocations are equivalent:\n\nt.Mv(7)\nT.Mv(t, 7)\n(T).Mv(t, 7)\nf1 := T.Mv; f1(t, 7)\nf2 := (T).Mv; f2(t, 7)\n\nSimilarly, the expression\n\n(*T).Mp\n\nyields a function value representing `Mp` with signature\n\nfunc(tp *T, f float32) float32\n\nFor a method with a value receiver, one can derive a function with an explicit pointer receiver, so\n\n(*T).Mv\n\nyields a function value representing `Mv` with signature\n\nfunc(tv *T, a int) int\n\nSuch a function indirects through the receiver to create a value to pass as the receiver to the underlying method; the method does not overwrite the value whose address is passed in the function call.\n\nThe final case, a value-receiver function for a pointer-receiver method, is illegal because pointer-receiver methods are not in the method set of the value type.\n\nFunction values derived from methods are called with function call syntax; the receiver is provided as the first argument to the call. That is, given `f := T.Mv`, `f` is invoked as `f(t, 7)` not `t.f(7)`. To construct a function that binds the receiver, use a[function literal](https://go.dev/ref/spec#Function%5Fliterals) or[method value](https://go.dev/ref/spec#Method%5Fvalues).\n\nIt is legal to derive a function value from a method of an interface type. The resulting function takes an explicit receiver of that interface type.\n\n### Method values\n\nIf the expression `x` has static type `T` and`M` is in the [method set](https://go.dev/ref/spec#Method%5Fsets) of type `T`,`x.M` is called a _method value_. The method value `x.M` is a function value that is callable with the same arguments as a method call of `x.M`. The expression `x` is evaluated and saved during the evaluation of the method value; the saved copy is then used as the receiver in any calls, which may be executed later.\n\ntype S struct { *T }\ntype T int\nfunc (t T) M() { print(t) }\n\nt := new(T)\ns := S{T: t}\nf := t.M                    // receiver *t is evaluated and stored in f\ng := s.M                    // receiver *(s.T) is evaluated and stored in g\n*t = 42                     // does not affect stored receivers in f and g\n\nThe type `T` may be an interface or non-interface type.\n\nAs in the discussion of [method expressions](https://go.dev/ref/spec#Method%5Fexpressions) above, consider a struct type `T` with two methods,`Mv`, whose receiver is of type `T`, and`Mp`, whose receiver is of type `*T`.\n\ntype T struct {\n\ta int\n}\nfunc (tv  T) Mv(a int) int         { return 0 }  // value receiver\nfunc (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver\n\nvar t T\nvar pt *T\nfunc makeT() T\n\nThe expression\n\nt.Mv\n\nyields a function value of type\n\nfunc(int) int\n\nThese two invocations are equivalent:\n\nt.Mv(7)\nf := t.Mv; f(7)\n\nSimilarly, the expression\n\npt.Mp\n\nyields a function value of type\n\nfunc(float32) float32\n\nAs with [selectors](https://go.dev/ref/spec#Selectors), a reference to a non-interface method with a value receiver using a pointer will automatically dereference that pointer: `pt.Mv` is equivalent to `(*pt).Mv`.\n\nAs with [method calls](https://go.dev/ref/spec#Calls), a reference to a non-interface method with a pointer receiver using an addressable value will automatically take the address of that value: `t.Mp` is equivalent to `(&t).Mp`.\n\nf := t.Mv; f(7)   // like t.Mv(7)\nf := pt.Mp; f(7)  // like pt.Mp(7)\nf := pt.Mv; f(7)  // like (*pt).Mv(7)\nf := t.Mp; f(7)   // like (&t).Mp(7)\nf := makeT().Mp   // invalid: result of makeT() is not addressable\n\nAlthough the examples above use non-interface types, it is also legal to create a method value from a value of interface type.\n\nvar i interface { M(int) } = myVal\nf := i.M; f(7)  // like i.M(7)\n\n### Index expressions\n\nA primary expression of the form\n\na[x]\n\ndenotes the element of the array, pointer to array, slice, string or map `a` indexed by `x`. The value `x` is called the _index_ or _map key_, respectively. The following rules apply:\n\nIf `a` is neither a map nor a type parameter:\n\n* the index `x` must be an untyped constant or its[core type](https://go.dev/ref/spec#Core%5Ftypes) must be an [integer](https://go.dev/ref/spec#Numeric%5Ftypes)\n* a constant index must be non-negative and[representable](https://go.dev/ref/spec#Representability) by a value of type `int`\n* a constant index that is untyped is given type `int`\n* the index `x` is _in range_ if `0 <= x < len(a)`, otherwise it is _out of range_\n\nFor `a` of [array type](https://go.dev/ref/spec#Array%5Ftypes) `A`:\n\n* a [constant](https://go.dev/ref/spec#Constants) index must be in range\n* if `x` is out of range at run time, a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics) occurs\n* `a[x]` is the array element at index `x` and the type of`a[x]` is the element type of `A`\n\nFor `a` of [pointer](https://go.dev/ref/spec#Pointer%5Ftypes) to array type:\n\n* `a[x]` is shorthand for `(*a)[x]`\n\nFor `a` of [slice type](https://go.dev/ref/spec#Slice%5Ftypes) `S`:\n\n* if `x` is out of range at run time, a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics) occurs\n* `a[x]` is the slice element at index `x` and the type of`a[x]` is the element type of `S`\n\nFor `a` of [string type](https://go.dev/ref/spec#String%5Ftypes):\n\n* a [constant](https://go.dev/ref/spec#Constants) index must be in range if the string `a` is also constant\n* if `x` is out of range at run time, a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics) occurs\n* `a[x]` is the non-constant byte value at index `x` and the type of`a[x]` is `byte`\n* `a[x]` may not be assigned to\n\nFor `a` of [map type](https://go.dev/ref/spec#Map%5Ftypes) `M`:\n\n* `x`'s type must be[assignable](https://go.dev/ref/spec#Assignability) to the key type of `M`\n* if the map contains an entry with key `x`,`a[x]` is the map element with key `x` and the type of `a[x]` is the element type of `M`\n* if the map is `nil` or does not contain such an entry,`a[x]` is the [zero value](https://go.dev/ref/spec#The%5Fzero%5Fvalue) for the element type of `M`\n\nFor `a` of [type parameter type](https://go.dev/ref/spec#Type%5Fparameter%5Fdeclarations) `P`:\n\n* The index expression `a[x]` must be valid for values of all types in `P`'s type set.\n* The element types of all types in `P`'s type set must be identical. In this context, the element type of a string type is `byte`.\n* If there is a map type in the type set of `P`, all types in that type set must be map types, and the respective key types must be all identical.\n* `a[x]` is the array, slice, or string element at index `x`, or the map element with key `x` of the type argument that `P` is instantiated with, and the type of `a[x]` is the type of the (identical) element types.\n* `a[x]` may not be assigned to if `P`'s type set includes string types.\n\nOtherwise `a[x]` is illegal.\n\nAn index expression on a map `a` of type `map[K]V`used in an [assignment statement](https://go.dev/ref/spec#Assignment%5Fstatements) or initialization of the special form\n\nv, ok = a[x]\nv, ok := a[x]\nvar v, ok = a[x]\n\nyields an additional untyped boolean value. The value of `ok` is`true` if the key `x` is present in the map, and`false` otherwise.\n\nAssigning to an element of a `nil` map causes a[run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics).\n\n### Slice expressions\n\nSlice expressions construct a substring or slice from a string, array, pointer to array, or slice. There are two variants: a simple form that specifies a low and high bound, and a full form that also specifies a bound on the capacity.\n\n#### Simple slice expressions\n\nThe primary expression\n\na[low : high]\n\nconstructs a substring or slice. The [core type](https://go.dev/ref/spec#Core%5Ftypes) of`a` must be a string, array, pointer to array, slice, or a[bytestring](https://go.dev/ref/spec#Core%5Ftypes). The _indices_ `low` and`high` select which elements of operand `a` appear in the result. The result has indices starting at 0 and length equal to`high` \\- `low`. After slicing the array `a` \n\na := [5]int{1, 2, 3, 4, 5}\ns := a[1:4]\n\nthe slice `s` has type `[]int`, length 3, capacity 4, and elements\n\ns[0] == 2\ns[1] == 3\ns[2] == 4\n\nFor convenience, any of the indices may be omitted. A missing `low`index defaults to zero; a missing `high` index defaults to the length of the sliced operand:\n\na[2:]  // same as a[2 : len(a)]\na[:3]  // same as a[0 : 3]\na[:]   // same as a[0 : len(a)]\n\nIf `a` is a pointer to an array, `a[low : high]` is shorthand for`(*a)[low : high]`.\n\nFor arrays or strings, the indices are _in range_ if`0` <= `low` <= `high` <= `len(a)`, otherwise they are _out of range_. For slices, the upper index bound is the slice capacity `cap(a)` rather than the length. A [constant](https://go.dev/ref/spec#Constants) index must be non-negative and[representable](https://go.dev/ref/spec#Representability) by a value of type`int`; for arrays or constant strings, constant indices must also be in range. If both indices are constant, they must satisfy `low <= high`. If the indices are out of range at run time, a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics) occurs.\n\nExcept for [untyped strings](https://go.dev/ref/spec#Constants), if the sliced operand is a string or slice, the result of the slice operation is a non-constant value of the same type as the operand. For untyped string operands the result is a non-constant value of type `string`. If the sliced operand is an array, it must be [addressable](https://go.dev/ref/spec#Address%5Foperators)and the result of the slice operation is a slice with the same element type as the array.\n\nIf the sliced operand of a valid slice expression is a `nil` slice, the result is a `nil` slice. Otherwise, if the result is a slice, it shares its underlying array with the operand.\n\nvar a [10]int\ns1 := a[3:7]   // underlying array of s1 is array a; &s1[2] == &a[5]\ns2 := s1[1:4]  // underlying array of s2 is underlying array of s1 which is array a; &s2[1] == &a[5]\ns2[1] = 42     // s2[1] == s1[2] == a[5] == 42; they all refer to the same underlying array element\n\nvar s []int\ns3 := s[:0]    // s3 == nil\n\n#### Full slice expressions\n\nThe primary expression\n\na[low : high : max]\n\nconstructs a slice of the same type, and with the same length and elements as the simple slice expression `a[low : high]`. Additionally, it controls the resulting slice's capacity by setting it to `max - low`. Only the first index may be omitted; it defaults to 0\\. The [core type](https://go.dev/ref/spec#Core%5Ftypes) of `a` must be an array, pointer to array, or slice (but not a string). After slicing the array `a` \n\na := [5]int{1, 2, 3, 4, 5}\nt := a[1:3:5]\n\nthe slice `t` has type `[]int`, length 2, capacity 4, and elements\n\nt[0] == 2\nt[1] == 3\n\nAs for simple slice expressions, if `a` is a pointer to an array,`a[low : high : max]` is shorthand for `(*a)[low : high : max]`. If the sliced operand is an array, it must be [addressable](https://go.dev/ref/spec#Address%5Foperators).\n\nThe indices are _in range_ if `0 <= low <= high <= max <= cap(a)`, otherwise they are _out of range_. A [constant](https://go.dev/ref/spec#Constants) index must be non-negative and[representable](https://go.dev/ref/spec#Representability) by a value of type`int`; for arrays, constant indices must also be in range. If multiple indices are constant, the constants that are present must be in range relative to each other. If the indices are out of range at run time, a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics) occurs.\n\n### Type assertions\n\nFor an expression `x` of [interface type](https://go.dev/ref/spec#Interface%5Ftypes), but not a [type parameter](https://go.dev/ref/spec#Type%5Fparameter%5Fdeclarations), and a type `T`, the primary expression\n\nx.(T)\n\nasserts that `x` is not `nil`and that the value stored in `x` is of type `T`. The notation `x.(T)` is called a _type assertion_.\n\nMore precisely, if `T` is not an interface type, `x.(T)` asserts that the dynamic type of `x` is [identical](https://go.dev/ref/spec#Type%5Fidentity)to the type `T`. In this case, `T` must [implement](https://go.dev/ref/spec#Method%5Fsets) the (interface) type of `x`; otherwise the type assertion is invalid since it is not possible for `x`to store a value of type `T`. If `T` is an interface type, `x.(T)` asserts that the dynamic type of `x` [implements](https://go.dev/ref/spec#Implementing%5Fan%5Finterface) the interface `T`.\n\nIf the type assertion holds, the value of the expression is the value stored in `x` and its type is `T`. If the type assertion is false, a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics) occurs. In other words, even though the dynamic type of `x`is known only at run time, the type of `x.(T)` is known to be `T` in a correct program.\n\nvar x interface{} = 7          // x has dynamic type int and value 7\ni := x.(int)                   // i has type int and value 7\n\ntype I interface { m() }\n\nfunc f(y I) {\n\ts := y.(string)        // illegal: string does not implement I (missing method m)\n\tr := y.(io.Reader)     // r has type io.Reader and the dynamic type of y must implement both I and io.Reader\n\t…\n}\n\nA type assertion used in an [assignment statement](https://go.dev/ref/spec#Assignment%5Fstatements) or initialization of the special form\n\nv, ok = x.(T)\nv, ok := x.(T)\nvar v, ok = x.(T)\nvar v, ok interface{} = x.(T) // dynamic types of v and ok are T and bool\n\nyields an additional untyped boolean value. The value of `ok` is `true`if the assertion holds. Otherwise it is `false` and the value of `v` is the [zero value](https://go.dev/ref/spec#The%5Fzero%5Fvalue) for type `T`. No [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics) occurs in this case.\n\n### Calls\n\nGiven an expression `f` with a [core type](https://go.dev/ref/spec#Core%5Ftypes) `F` of [function type](https://go.dev/ref/spec#Function%5Ftypes),\n\nf(a1, a2, … an)\n\ncalls `f` with arguments `a1, a2, … an`. Except for one special case, arguments must be single-valued expressions[assignable](https://go.dev/ref/spec#Assignability) to the parameter types of`F` and are evaluated before the function is called. The type of the expression is the result type of `F`. A method invocation is similar but the method itself is specified as a selector upon a value of the receiver type for the method.\n\nmath.Atan2(x, y)  // function call\nvar pt *Point\npt.Scale(3.5)     // method call with receiver pt\n\nIf `f` denotes a generic function, it must be[instantiated](https://go.dev/ref/spec#Instantiations) before it can be called or used as a function value.\n\nIn a function call, the function value and arguments are evaluated in[the usual order](https://go.dev/ref/spec#Order%5Fof%5Fevaluation). After they are evaluated, the parameters of the call are passed by value to the function and the called function begins execution. The return parameters of the function are passed by value back to the caller when the function returns.\n\nCalling a `nil` function value causes a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics).\n\nAs a special case, if the return values of a function or method`g` are equal in number and individually assignable to the parameters of another function or method`f`, then the call `f(g(_parametersofg_))`will invoke `f` after binding the return values of`g` to the parameters of `f` in order. The call of `f` must contain no parameters other than the call of `g`, and `g` must have at least one return value. If `f` has a final `...` parameter, it is assigned the return values of `g` that remain after assignment of regular parameters.\n\nfunc Split(s string, pos int) (string, string) {\n\treturn s[0:pos], s[pos:]\n}\n\nfunc Join(s, t string) string {\n\treturn s + t\n}\n\nif Join(Split(value, len(value)/2)) != value {\n\tlog.Panic(\"test fails\")\n}\n\nA method call `x.m()` is valid if the [method set](https://go.dev/ref/spec#Method%5Fsets)of (the type of) `x` contains `m` and the argument list can be assigned to the parameter list of `m`. If `x` is [addressable](https://go.dev/ref/spec#Address%5Foperators) and `&x`'s method set contains `m`, `x.m()` is shorthand for `(&x).m()`:\n\nvar p Point\np.Scale(3.5)\n\nThere is no distinct method type and there are no method literals.\n\n### Passing arguments to `...` parameters\n\nIf `f` is [variadic](https://go.dev/ref/spec#Function%5Ftypes) with a final parameter `p` of type `...T`, then within `f`the type of `p` is equivalent to type `[]T`. If `f` is invoked with no actual arguments for `p`, the value passed to `p` is `nil`. Otherwise, the value passed is a new slice of type `[]T` with a new underlying array whose successive elements are the actual arguments, which all must be [assignable](https://go.dev/ref/spec#Assignability)to `T`. The length and capacity of the slice is therefore the number of arguments bound to `p` and may differ for each call site.\n\nGiven the function and calls\n\nfunc Greeting(prefix string, who ...string)\nGreeting(\"nobody\")\nGreeting(\"hello:\", \"Joe\", \"Anna\", \"Eileen\")\n\nwithin `Greeting`, `who` will have the value`nil` in the first call, and`[]string{\"Joe\", \"Anna\", \"Eileen\"}` in the second.\n\nIf the final argument is assignable to a slice type `[]T` and is followed by `...`, it is passed unchanged as the value for a `...T` parameter. In this case no new slice is created.\n\nGiven the slice `s` and call\n\ns := []string{\"James\", \"Jasmine\"}\nGreeting(\"goodbye:\", s...)\n\nwithin `Greeting`, `who` will have the same value as `s`with the same underlying array.\n\n### Instantiations\n\nA generic function or type is _instantiated_ by substituting _type arguments_for the type parameters. Instantiation proceeds in two steps:\n\n1. Each type argument is substituted for its corresponding type parameter in the generic declaration. This substitution happens across the entire function or type declaration, including the type parameter list itself and any types in that list.\n2. After substitution, each type argument must [satisfy](https://go.dev/ref/spec#Satisfying%5Fa%5Ftype%5Fconstraint)the [constraint](https://go.dev/ref/spec#Type%5Fparameter%5Fdeclarations) (instantiated, if necessary) of the corresponding type parameter. Otherwise instantiation fails.\n\nInstantiating a type results in a new non-generic [named type](https://go.dev/ref/spec#Types); instantiating a function produces a new non-generic function.\n\ntype parameter list    type arguments    after substitution\n\n[P any]                int               int satisfies any\n[S ~[]E, E any]        []int, int        []int satisfies ~[]int, int satisfies any\n[P io.Writer]          string            illegal: string doesn't satisfy io.Writer\n[P comparable]         any               any satisfies (but does not implement) comparable\n\nFor a generic function, type arguments may be provided explicitly, or they may be partially or completely [inferred](https://go.dev/ref/spec#Type%5Finference). A generic function that is _not_ [called](https://go.dev/ref/spec#Calls) requires a type argument list for instantiation; if the list is partial, all remaining type arguments must be inferrable. A generic function that is called may provide a (possibly partial) type argument list, or may omit it entirely if the omitted type arguments are inferrable from the ordinary (non-type) function arguments.\n\nfunc min[T ~int|~float64](x, y T) T { … }\n\nf := min                   // illegal: min must be instantiated with type arguments when used without being called\nminInt := min[int]         // minInt has type func(x, y int) int\na := minInt(2, 3)          // a has value 2 of type int\nb := min[float64](2.0, 3)  // b has value 2.0 of type float64\nc := min(b, -1)            // c has value -1.0 of type float64\n\nA partial type argument list cannot be empty; at least the first argument must be present. The list is a prefix of the full list of type arguments, leaving the remaining arguments to be inferred. Loosely speaking, type arguments may be omitted from \"right to left\".\n\nfunc apply[S ~[]E, E any](s S, f func(E) E) S { … }\n\nf0 := apply[]                  // illegal: type argument list cannot be empty\nf1 := apply[[]int]             // type argument for S explicitly provided, type argument for E inferred\nf2 := apply[[]string, string]  // both type arguments explicitly provided\n\nvar bytes []byte\nr := apply(bytes, func(byte) byte { … })  // both type arguments inferred from the function arguments\n\nFor a generic type, all type arguments must always be provided explicitly.\n\n### Type inference\n\nMissing function type arguments may be _inferred_ by a series of steps, described below. Each step attempts to use known information to infer additional type arguments. Type inference stops as soon as all type arguments are known. After type inference is complete, it is still necessary to substitute all type arguments for type parameters and verify that each type argument[implements](https://go.dev/ref/spec#Implementing%5Fan%5Finterface) the relevant constraint; it is possible for an inferred type argument to fail to implement a constraint, in which case instantiation fails.\n\nType inference is based on\n\n* a [type parameter list](https://go.dev/ref/spec#Type%5Fparameter%5Fdeclarations)\n* a substitution map _M_ initialized with the known type arguments, if any\n* a (possibly empty) list of ordinary function arguments (in case of a function call only)\n\nand then proceeds with the following steps:\n\n1. apply [_function argument type inference_](https://go.dev/ref/spec#Function%5Fargument%5Ftype%5Finference) to all _typed_ ordinary function arguments\n2. apply [_constraint type inference_](https://go.dev/ref/spec#Constraint%5Ftype%5Finference)\n3. apply function argument type inference to all _untyped_ ordinary function arguments using the default type for each of the untyped function arguments\n4. apply constraint type inference\n\nIf there are no ordinary or untyped function arguments, the respective steps are skipped. Constraint type inference is skipped if the previous step didn't infer any new type arguments, but it is run at least once if there are missing type arguments.\n\nThe substitution map _M_ is carried through all steps, and each step may add entries to _M_. The process stops as soon as _M_ has a type argument for each type parameter or if an inference step fails. If an inference step fails, or if _M_ is still missing type arguments after the last step, type inference fails.\n\n#### Type unification\n\nType inference is based on _type unification_. A single unification step applies to a [substitution map](https://go.dev/ref/spec#Type%5Finference) and two types, either or both of which may be or contain type parameters. The substitution map tracks the known (explicitly provided or already inferred) type arguments: the map contains an entry `P` → `A` for each type parameter `P` and corresponding known type argument `A`. During unification, known type arguments take the place of their corresponding type parameters when comparing types. Unification is the process of finding substitution map entries that make the two types equivalent.\n\nFor unification, two types that don't contain any type parameters from the current type parameter list are _equivalent_if they are identical, or if they are channel types that are identical ignoring channel direction, or if their underlying types are equivalent.\n\nUnification works by comparing the structure of pairs of types: their structure disregarding type parameters must be identical, and types other than type parameters must be equivalent. A type parameter in one type may match any complete subtype in the other type; each successful match causes an entry to be added to the substitution map. If the structure differs, or types other than type parameters are not equivalent, unification fails.\n\nFor example, if `T1` and `T2` are type parameters,`[]map[int]bool` can be unified with any of the following:\n\n[]map[int]bool   // types are identical\nT1               // adds T1 → []map[int]bool to substitution map\n[]T1             // adds T1 → map[int]bool to substitution map\n[]map[T1]T2      // adds T1 → int and T2 → bool to substitution map\n\nOn the other hand, `[]map[int]bool` cannot be unified with any of\n\nint              // int is not a slice\nstruct{}         // a struct is not a slice\n[]struct{}       // a struct is not a map\n[]map[T1]string  // map element types don't match\n\nAs an exception to this general rule, because a [defined type](https://go.dev/ref/spec#Type%5Fdefinitions) `D` and a type literal `L` are never equivalent, unification compares the underlying type of `D` with `L` instead. For example, given the defined type\n\ntype Vector []float64\n\nand the type literal `[]E`, unification compares `[]float64` with`[]E` and adds an entry `E` → `float64` to the substitution map.\n\n#### Function argument type inference\n\nFunction argument type inference infers type arguments from function arguments: if a function parameter is declared with a type `T` that uses type parameters,[unifying](https://go.dev/ref/spec#Type%5Funification) the type of the corresponding function argument with `T` may infer type arguments for the type parameters used by `T`.\n\nFor instance, given the generic function\n\nfunc scale[Number ~int64|~float64|~complex128](v []Number, s Number) []Number\n\nand the call\n\nvar vector []float64\nscaledVector := scale(vector, 42)\n\nthe type argument for `Number` can be inferred from the function argument`vector` by unifying the type of `vector` with the corresponding parameter type: `[]float64` and `[]Number`match in structure and `float64` matches with `Number`. This adds the entry `Number` → `float64` to the[substitution map](https://go.dev/ref/spec#Type%5Funification). Untyped arguments, such as the second function argument `42` here, are ignored in the first round of function argument type inference and only considered if there are unresolved type parameters left.\n\nInference happens in two separate phases; each phase operates on a specific list of (parameter, argument) pairs:\n\n1. The list _Lt_ contains all (parameter, argument) pairs where the parameter type uses type parameters and where the function argument is _typed_.\n2. The list _Lu_ contains all remaining pairs where the parameter type is a single type parameter. In this list, the respective function arguments are untyped.\n\nAny other (parameter, argument) pair is ignored.\n\nBy construction, the arguments of the pairs in _Lu_ are _untyped_ constants (or the untyped boolean result of a comparison). And because [default types](https://go.dev/ref/spec#Constants)of untyped values are always predeclared non-composite types, they can never match against a composite type, so it is sufficient to only consider parameter types that are single type parameters.\n\nEach list is processed in a separate phase:\n\n1. In the first phase, the parameter and argument types of each pair in _Lt_ are unified. If unification succeeds for a pair, it may yield new entries that are added to the substitution map _M_. If unification fails, type inference fails.\n2. The second phase considers the entries of list _Lu_. Type parameters for which the type argument has already been determined are ignored in this phase. For each remaining pair, the parameter type (which is a single type parameter) and the [default type](https://go.dev/ref/spec#Constants) of the corresponding untyped argument is unified. If unification fails, type inference fails.\n\nWhile unification is successful, processing of each list continues until all list elements are considered, even if all type arguments are inferred before the last list element has been processed.\n\nExample:\n\nfunc min[T ~int|~float64](x, y T) T\n\nvar x int\nmin(x, 2.0)    // T is int, inferred from typed argument x; 2.0 is assignable to int\nmin(1.0, 2.0)  // T is float64, inferred from default type for 1.0 and matches default type for 2.0\nmin(1.0, 2)    // illegal: default type float64 (for 1.0) doesn't match default type int (for 2)\n\nIn the example `min(1.0, 2)`, processing the function argument `1.0`yields the substitution map entry `T` → `float64`. Because processing continues until all untyped arguments are considered, an error is reported. This ensures that type inference does not depend on the order of the untyped arguments.\n\n#### Constraint type inference\n\nConstraint type inference infers type arguments by considering type constraints. If a type parameter `P` has a constraint with a[core type](https://go.dev/ref/spec#Core%5Ftypes) `C`,[unifying](https://go.dev/ref/spec#Type%5Funification) `P` with `C`may infer additional type arguments, either the type argument for `P`, or if that is already known, possibly the type arguments for type parameters used in `C`.\n\nFor instance, consider the type parameter list with type parameters `List` and`Elem`:\n\n[List ~[]Elem, Elem any]\n\nConstraint type inference can deduce the type of `Elem` from the type argument for `List` because `Elem` is a type parameter in the core type`[]Elem` of `List`. If the type argument is `Bytes`:\n\ntype Bytes []byte\n\nunifying the underlying type of `Bytes` with the core type means unifying `[]byte` with `[]Elem`. That unification succeeds and yields the [substitution map](https://go.dev/ref/spec#Type%5Funification) entry`Elem` → `byte`. Thus, in this example, constraint type inference can infer the second type argument from the first one.\n\nUsing the core type of a constraint may lose some information: In the (unlikely) case that the constraint's type set contains a single [defined type](https://go.dev/ref/spec#Type%5Fdefinitions) `N`, the corresponding core type is `N`'s underlying type rather than`N` itself. In this case, constraint type inference may succeed but instantiation will fail because the inferred type is not in the type set of the constraint. Thus, constraint type inference uses the _adjusted core type_ of a constraint: if the type set contains a single type, use that type; otherwise use the constraint's core type.\n\nGenerally, constraint type inference proceeds in two phases: Starting with a given substitution map _M_ \n\n1. For all type parameters with an adjusted core type, unify the type parameter with that type. If any unification fails, constraint type inference fails.\n2. At this point, some entries in _M_ may map type parameters to other type parameters or to types containing type parameters. For each entry`P` → `A` in _M_ where `A` is or contains type parameters `Q` for which there exist entries`Q` → `B` in _M_, substitute those`Q` with the respective `B` in `A`. Stop when no further substitution is possible.\n\nThe result of constraint type inference is the final substitution map _M_ from type parameters `P` to type arguments `A` where no type parameter `P`appears in any of the `A`.\n\nFor instance, given the type parameter list\n\n[A any, B []C, C *A]\n\nand the single provided type argument `int` for type parameter `A`, the initial substitution map _M_ contains the entry `A` → `int`.\n\nIn the first phase, the type parameters `B` and `C` are unified with the core type of their respective constraints. This adds the entries`B` → `[]C` and `C` → `*A`to _M_.\n\nAt this point there are two entries in _M_ where the right-hand side is or contains type parameters for which there exists other entries in _M_:`[]C` and `*A`. In the second phase, these type parameters are replaced with their respective types. It doesn't matter in which order this happens. Starting with the state of _M_ after the first phase:\n\n`A` → `int`,`B` → `[]C`,`C` → `*A` \n\nReplace `A` on the right-hand side of → with `int`:\n\n`A` → `int`,`B` → `[]C`,`C` → `*int` \n\nReplace `C` on the right-hand side of → with `*int`:\n\n`A` → `int`,`B` → `[]*int`,`C` → `*int` \n\nAt this point no further substitution is possible and the map is full. Therefore, `M` represents the final map of type parameters to type arguments for the given type parameter list.\n\n### Operators\n\nOperators combine operands into expressions.\n\nExpression = [UnaryExpr](https://go.dev/ref/spec#UnaryExpr) | [Expression](https://go.dev/ref/spec#Expression) [binary_op](https://go.dev/ref/spec#binary%5Fop) [Expression](https://go.dev/ref/spec#Expression) .\nUnaryExpr  = [PrimaryExpr](https://go.dev/ref/spec#PrimaryExpr) | [unary_op](https://go.dev/ref/spec#unary%5Fop) [UnaryExpr](https://go.dev/ref/spec#UnaryExpr) .\n\nbinary_op  = \"||\" | \"&&\" | [rel_op](https://go.dev/ref/spec#rel%5Fop) | [add_op](https://go.dev/ref/spec#add%5Fop) | [mul_op](https://go.dev/ref/spec#mul%5Fop) .\nrel_op     = \"==\" | \"!=\" | \"<\" | \"<=\" | \">\" | \">=\" .\nadd_op     = \"+\" | \"-\" | \"|\" | \"^\" .\nmul_op     = \"*\" | \"/\" | \"%\" | \"<<\" | \">>\" | \"&\" | \"&^\" .\n\nunary_op   = \"+\" | \"-\" | \"!\" | \"^\" | \"*\" | \"&\" | \"<-\" .\n\nComparisons are discussed [elsewhere](https://go.dev/ref/spec#Comparison%5Foperators). For other binary operators, the operand types must be [identical](https://go.dev/ref/spec#Type%5Fidentity)unless the operation involves shifts or untyped [constants](https://go.dev/ref/spec#Constants). For operations involving constants only, see the section on[constant expressions](https://go.dev/ref/spec#Constant%5Fexpressions).\n\nExcept for shift operations, if one operand is an untyped [constant](https://go.dev/ref/spec#Constants)and the other operand is not, the constant is implicitly [converted](https://go.dev/ref/spec#Conversions)to the type of the other operand.\n\nThe right operand in a shift expression must have [integer type](https://go.dev/ref/spec#Numeric%5Ftypes)or be an untyped constant [representable](https://go.dev/ref/spec#Representability) by a value of type `uint`. If the left operand of a non-constant shift expression is an untyped constant, it is first implicitly converted to the type it would assume if the shift expression were replaced by its left operand alone.\n\nvar a [1024]byte\nvar s uint = 33\n\n// The results of the following examples are given for 64-bit ints.\nvar i = 1<<s                   // 1 has type int\nvar j int32 = 1<<s             // 1 has type int32; j == 0\nvar k = uint64(1<<s)           // 1 has type uint64; k == 1<<33\nvar m int = 1.0<<s             // 1.0 has type int; m == 1<<33\nvar n = 1.0<<s == j            // 1.0 has type int32; n == true\nvar o = 1<<s == 2<<s           // 1 and 2 have type int; o == false\nvar p = 1<<s == 1<<33          // 1 has type int; p == true\nvar u = 1.0<<s                 // illegal: 1.0 has type float64, cannot shift\nvar u1 = 1.0<<s != 0           // illegal: 1.0 has type float64, cannot shift\nvar u2 = 1<<s != 1.0           // illegal: 1 has type float64, cannot shift\nvar v1 float32 = 1<<s          // illegal: 1 has type float32, cannot shift\nvar v2 = string(1<<s)          // illegal: 1 is converted to a string, cannot shift\nvar w int64 = 1.0<<33          // 1.0<<33 is a constant shift expression; w == 1<<33\nvar x = a[1.0<<s]              // panics: 1.0 has type int, but 1<<33 overflows array bounds\nvar b = make([]byte, 1.0<<s)   // 1.0 has type int; len(b) == 1<<33\n\n// The results of the following examples are given for 32-bit ints,\n// which means the shifts will overflow.\nvar mm int = 1.0<<s            // 1.0 has type int; mm == 0\nvar oo = 1<<s == 2<<s          // 1 and 2 have type int; oo == true\nvar pp = 1<<s == 1<<33         // illegal: 1 has type int, but 1<<33 overflows int\nvar xx = a[1.0<<s]             // 1.0 has type int; xx == a[0]\nvar bb = make([]byte, 1.0<<s)  // 1.0 has type int; len(bb) == 0\n\n#### Operator precedence\n\nUnary operators have the highest precedence. As the `++` and `--` operators form statements, not expressions, they fall outside the operator hierarchy. As a consequence, statement `*p++` is the same as `(*p)++`.\n\nThere are five precedence levels for binary operators. Multiplication operators bind strongest, followed by addition operators, comparison operators, `&&` (logical AND), and finally `||` (logical OR):\n\nPrecedence    Operator\n    5             *  /  %  <<  >>  &  &^\n    4             +  -  |  ^\n    3             ==  !=  <  <=  >  >=\n    2             &&\n    1             ||\n\nBinary operators of the same precedence associate from left to right. For instance, `x / y * z` is the same as `(x / y) * z`.\n\n+x\n23 + 3*x[i]\nx <= f()\n^a >> b\nf() || g()\nx == y+1 && <-chanInt > 0\n\n### Arithmetic operators\n\nArithmetic operators apply to numeric values and yield a result of the same type as the first operand. The four standard arithmetic operators (`+`,`-`, `*`, `/`) apply to[integer](https://go.dev/ref/spec#Numeric%5Ftypes), [floating-point](https://go.dev/ref/spec#Numeric%5Ftypes), and[complex](https://go.dev/ref/spec#Numeric%5Ftypes) types; `+` also applies to [strings](https://go.dev/ref/spec#String%5Ftypes). The bitwise logical and shift operators apply to integers only.\n\n+    sum                    integers, floats, complex values, strings\n-    difference             integers, floats, complex values\n*    product                integers, floats, complex values\n/    quotient               integers, floats, complex values\n%    remainder              integers\n\n&    bitwise AND            integers\n|    bitwise OR             integers\n^    bitwise XOR            integers\n&^   bit clear (AND NOT)    integers\n\n<<   left shift             integer << integer >= 0\n>>   right shift            integer >> integer >= 0\n\nIf the operand type is a [type parameter](https://go.dev/ref/spec#Type%5Fparameter%5Fdeclarations), the operator must apply to each type in that type set. The operands are represented as values of the type argument that the type parameter is [instantiated](https://go.dev/ref/spec#Instantiations) with, and the operation is computed with the precision of that type argument. For example, given the function:\n\nfunc dotProduct[F ~float32|~float64](v1, v2 []F) F {\n\tvar s F\n\tfor i, x := range v1 {\n\t\ty := v2[i]\n\t\ts += x * y\n\t}\n\treturn s\n}\n\nthe product `x * y` and the addition `s += x * y`are computed with `float32` or `float64` precision, respectively, depending on the type argument for `F`.\n\n#### Integer operators\n\nFor two integer values `x` and `y`, the integer quotient`q = x / y` and remainder `r = x % y` satisfy the following relationships:\n\nx = q*y + r  and  |r| < |y|\n\nwith `x / y` truncated towards zero ([\"truncated division\"](https://en.wikipedia.org/wiki/Modulo%5Foperation)).\n\n x     y     x / y     x % y\n 5     3       1         2\n-5     3      -1        -2\n 5    -3      -1         2\n-5    -3       1        -2\n\nThe one exception to this rule is that if the dividend `x` is the most negative value for the int type of `x`, the quotient`q = x / -1` is equal to `x` (and `r = 0`) due to two's-complement [integer overflow](https://go.dev/ref/spec#Integer%5Foverflow):\n\n                         x, q\nint8                     -128\nint16                  -32768\nint32             -2147483648\nint64    -9223372036854775808\n\nIf the divisor is a [constant](https://go.dev/ref/spec#Constants), it must not be zero. If the divisor is zero at run time, a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics) occurs. If the dividend is non-negative and the divisor is a constant power of 2, the division may be replaced by a right shift, and computing the remainder may be replaced by a bitwise AND operation:\n\n x     x / 4     x % 4     x >> 2     x & 3\n 11      2         3         2          3\n-11     -2        -3        -3          1\n\nThe shift operators shift the left operand by the shift count specified by the right operand, which must be non-negative. If the shift count is negative at run time, a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics) occurs. The shift operators implement arithmetic shifts if the left operand is a signed integer and logical shifts if it is an unsigned integer. There is no upper limit on the shift count. Shifts behave as if the left operand is shifted `n` times by 1 for a shift count of `n`. As a result, `x << 1` is the same as `x*2`and `x >> 1` is the same as`x/2` but truncated towards negative infinity.\n\nFor integer operands, the unary operators`+`, `-`, and `^` are defined as follows:\n\n+x                          is 0 + x\n-x    negation              is 0 - x\n^x    bitwise complement    is m ^ x  with m = \"all bits set to 1\" for unsigned x\n                                      and  m = -1 for signed x\n\n#### Integer overflow\n\nFor [unsigned integer](https://go.dev/ref/spec#Numeric%5Ftypes) values, the operations `+`,`-`, `*`, and `<<` are computed modulo 2_n_, where _n_ is the bit width of the unsigned integer's type. Loosely speaking, these unsigned integer operations discard high bits upon overflow, and programs may rely on \"wrap around\".\n\nFor signed integers, the operations `+`,`-`, `*`, `/`, and `<<` may legally overflow and the resulting value exists and is deterministically defined by the signed integer representation, the operation, and its operands. Overflow does not cause a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics). A compiler may not optimize code under the assumption that overflow does not occur. For instance, it may not assume that `x < x + 1` is always true.\n\n#### Floating-point operators\n\nFor floating-point and complex numbers,`+x` is the same as `x`, while `-x` is the negation of `x`. The result of a floating-point or complex division by zero is not specified beyond the IEEE-754 standard; whether a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics)occurs is implementation-specific.\n\nAn implementation may combine multiple floating-point operations into a single fused operation, possibly across statements, and produce a result that differs from the value obtained by executing and rounding the instructions individually. An explicit [floating-point type](https://go.dev/ref/spec#Numeric%5Ftypes) [conversion](https://go.dev/ref/spec#Conversions) rounds to the precision of the target type, preventing fusion that would discard that rounding.\n\nFor instance, some architectures provide a \"fused multiply and add\" (FMA) instruction that computes `x*y + z` without rounding the intermediate result `x*y`. These examples show when a Go implementation can use that instruction:\n\n// FMA allowed for computing r, because x*y is not explicitly rounded:\nr  = x*y + z\nr  = z;   r += x*y\nt  = x*y; r = t + z\n*p = x*y; r = *p + z\nr  = x*y + float64(z)\n\n// FMA disallowed for computing r, because it would omit rounding of x*y:\nr  = float64(x*y) + z\nr  = z; r += float64(x*y)\nt  = float64(x*y); r = t + z\n\n#### String concatenation\n\nStrings can be concatenated using the `+` operator or the `+=` assignment operator:\n\ns := \"hi\" + string(c)\ns += \" and good bye\"\n\nString addition creates a new string by concatenating the operands.\n\n### Comparison operators\n\nComparison operators compare two operands and yield an untyped boolean value.\n\n==    equal\n!=    not equal\n<     less\n<=    less or equal\n>     greater\n>=    greater or equal\n\nIn any comparison, the first operand must be [assignable](https://go.dev/ref/spec#Assignability)to the type of the second operand, or vice versa.\n\nThe equality operators `==` and `!=` apply to operands of _comparable_ types. The ordering operators `<`, `<=`, `>`, and `>=`apply to operands of _ordered_ types. These terms and the result of the comparisons are defined as follows:\n\n* Boolean types are comparable. Two boolean values are equal if they are either both`true` or both `false`.\n* Integer types are comparable and ordered. Two integer values are compared in the usual way.\n* Floating-point types are comparable and ordered. Two floating-point values are compared as defined by the IEEE-754 standard.\n* Complex types are comparable. Two complex values `u` and `v` are equal if both `real(u) == real(v)` and`imag(u) == imag(v)`.\n* String types are comparable and ordered. Two string values are compared lexically byte-wise.\n* Pointer types are comparable. Two pointer values are equal if they point to the same variable or if both have value `nil`. Pointers to distinct [zero-size](https://go.dev/ref/spec#Size%5Fand%5Falignment%5Fguarantees) variables may or may not be equal.\n* Channel types are comparable. Two channel values are equal if they were created by the same call to[make](https://go.dev/ref/spec#Making%5Fslices%5Fmaps%5Fand%5Fchannels) or if both have value `nil`.\n* Interface types that are not type parameters are comparable. Two interface values are equal if they have [identical](https://go.dev/ref/spec#Type%5Fidentity) dynamic types and equal dynamic values or if both have value `nil`.\n* A value `x` of non-interface type `X` and a value `t` of interface type `T` can be compared if type `X` is comparable and`X` [implements](https://go.dev/ref/spec#Implementing%5Fan%5Finterface) `T`. They are equal if `t`'s dynamic type is identical to `X` and `t`'s dynamic value is equal to `x`.\n* Struct types are comparable if all their field types are comparable. Two struct values are equal if their corresponding non-[blank](https://go.dev/ref/spec#Blank%5Fidentifier) field values are equal. The fields are compared in source order, and comparison stops as soon as two field values differ (or all fields have been compared).\n* Array types are comparable if their array element types are comparable. Two array values are equal if their corresponding element values are equal. The elements are compared in ascending index order, and comparison stops as soon as two element values differ (or all elements have been compared).\n* Type parameters are comparable if they are strictly comparable (see below).\n\nA comparison of two interface values with identical dynamic types causes a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics) if that type is not comparable. This behavior applies not only to direct interface value comparisons but also when comparing arrays of interface values or structs with interface-valued fields.\n\nSlice, map, and function types are not comparable. However, as a special case, a slice, map, or function value may be compared to the predeclared identifier `nil`. Comparison of pointer, channel, and interface values to `nil`is also allowed and follows from the general rules above.\n\nconst c = 3 < 4            // c is the untyped boolean constant true\n\ntype MyBool bool\nvar x, y int\nvar (\n\t// The result of a comparison is an untyped boolean.\n\t// The usual assignment rules apply.\n\tb3        = x == y // b3 has type bool\n\tb4 bool   = x == y // b4 has type bool\n\tb5 MyBool = x == y // b5 has type MyBool\n)\n\nA type is _strictly comparable_ if it is comparable and not an interface type nor composed of interface types. Specifically:\n\n* Boolean, numeric, string, pointer, and channel types are strictly comparable.\n* Struct types are strictly comparable if all their field types are strictly comparable.\n* Array types are strictly comparable if their array element types are strictly comparable.\n* Type parameters are strictly comparable if all types in their type set are strictly comparable.\n\n### Logical operators\n\nLogical operators apply to [boolean](https://go.dev/ref/spec#Boolean%5Ftypes) values and yield a result of the same type as the operands. The right operand is evaluated conditionally.\n\n&&    conditional AND    p && q  is  \"if p then q else false\"\n||    conditional OR     p || q  is  \"if p then true else q\"\n!     NOT                !p      is  \"not p\"\n\n### Address operators\n\nFor an operand `x` of type `T`, the address operation`&x` generates a pointer of type `*T` to `x`. The operand must be _addressable_, that is, either a variable, pointer indirection, or slice indexing operation; or a field selector of an addressable struct operand; or an array indexing operation of an addressable array. As an exception to the addressability requirement, `x` may also be a (possibly parenthesized)[composite literal](https://go.dev/ref/spec#Composite%5Fliterals). If the evaluation of `x` would cause a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics), then the evaluation of `&x` does too.\n\nFor an operand `x` of pointer type `*T`, the pointer indirection `*x` denotes the [variable](https://go.dev/ref/spec#Variables) of type `T` pointed to by `x`. If `x` is `nil`, an attempt to evaluate `*x`will cause a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics).\n\n&x\n&a[f(2)]\n&Point{2, 3}\n*p\n*pf(x)\n\nvar x *int = nil\n*x   // causes a run-time panic\n&*x  // causes a run-time panic\n\n### Receive operator\n\nFor an operand `ch` whose [core type](https://go.dev/ref/spec#Core%5Ftypes) is a[channel](https://go.dev/ref/spec#Channel%5Ftypes), the value of the receive operation `<-ch` is the value received from the channel `ch`. The channel direction must permit receive operations, and the type of the receive operation is the element type of the channel. The expression blocks until a value is available. Receiving from a `nil` channel blocks forever. A receive operation on a [closed](https://go.dev/ref/spec#Close) channel can always proceed immediately, yielding the element type's [zero value](https://go.dev/ref/spec#The%5Fzero%5Fvalue)after any previously sent values have been received.\n\nv1 := <-ch\nv2 = <-ch\nf(<-ch)\n<-strobe  // wait until clock pulse and discard received value\n\nA receive expression used in an [assignment statement](https://go.dev/ref/spec#Assignment%5Fstatements) or initialization of the special form\n\nx, ok = <-ch\nx, ok := <-ch\nvar x, ok = <-ch\nvar x, ok T = <-ch\n\nyields an additional untyped boolean result reporting whether the communication succeeded. The value of `ok` is `true`if the value received was delivered by a successful send operation to the channel, or `false` if it is a zero value generated because the channel is closed and empty.\n\n### Conversions\n\nA conversion changes the [type](https://go.dev/ref/spec#Types) of an expression to the type specified by the conversion. A conversion may appear literally in the source, or it may be _implied_by the context in which an expression appears.\n\nAn _explicit_ conversion is an expression of the form `T(x)`where `T` is a type and `x` is an expression that can be converted to type `T`.\n\nConversion = [Type](https://go.dev/ref/spec#Type) \"(\" [Expression](https://go.dev/ref/spec#Expression) [ \",\" ] \")\" .\n\nIf the type starts with the operator `*` or `<-`, or if the type starts with the keyword `func`and has no result list, it must be parenthesized when necessary to avoid ambiguity:\n\n*Point(p)        // same as *(Point(p))\n(*Point)(p)      // p is converted to *Point\n<-chan int(c)    // same as <-(chan int(c))\n(<-chan int)(c)  // c is converted to <-chan int\nfunc()(x)        // function signature func() x\n(func())(x)      // x is converted to func()\n(func() int)(x)  // x is converted to func() int\nfunc() int(x)    // x is converted to func() int (unambiguous)\n\nA [constant](https://go.dev/ref/spec#Constants) value `x` can be converted to type `T` if `x` is [representable](https://go.dev/ref/spec#Representability)by a value of `T`. As a special case, an integer constant `x` can be explicitly converted to a[string type](https://go.dev/ref/spec#String%5Ftypes) using the[same rule](https://go.dev/ref/spec#Conversions%5Fto%5Fand%5Ffrom%5Fa%5Fstring%5Ftype)as for non-constant `x`.\n\nConverting a constant to a type that is not a [type parameter](https://go.dev/ref/spec#Type%5Fparameter%5Fdeclarations)yields a typed constant.\n\nuint(iota)               // iota value of type uint\nfloat32(2.718281828)     // 2.718281828 of type float32\ncomplex128(1)            // 1.0 + 0.0i of type complex128\nfloat32(0.49999999)      // 0.5 of type float32\nfloat64(-1e-1000)        // 0.0 of type float64\nstring('x')              // \"x\" of type string\nstring(0x266c)           // \"♬\" of type string\nmyString(\"foo\" + \"bar\")  // \"foobar\" of type myString\nstring([]byte{'a'})      // not a constant: []byte{'a'} is not a constant\n(*int)(nil)              // not a constant: nil is not a constant, *int is not a boolean, numeric, or string type\nint(1.2)                 // illegal: 1.2 cannot be represented as an int\nstring(65.0)             // illegal: 65.0 is not an integer constant\n\nConverting a constant to a type parameter yields a _non-constant_ value of that type, with the value represented as a value of the type argument that the type parameter is [instantiated](https://go.dev/ref/spec#Instantiations) with. For example, given the function:\n\nfunc f[P ~float32|~float64]() {\n\t… P(1.1) …\n}\n\nthe conversion `P(1.1)` results in a non-constant value of type `P`and the value `1.1` is represented as a `float32` or a `float64`depending on the type argument for `f`. Accordingly, if `f` is instantiated with a `float32` type, the numeric value of the expression `P(1.1) + 1.2` will be computed with the same precision as the corresponding non-constant `float32`addition.\n\nA non-constant value `x` can be converted to type `T`in any of these cases:\n\n* `x` is [assignable](https://go.dev/ref/spec#Assignability) to `T`.\n* ignoring struct tags (see below),`x`'s type and `T` are not[type parameters](https://go.dev/ref/spec#Type%5Fparameter%5Fdeclarations) but have[identical](https://go.dev/ref/spec#Type%5Fidentity) [underlying types](https://go.dev/ref/spec#Types).\n* ignoring struct tags (see below),`x`'s type and `T` are pointer types that are not [named types](https://go.dev/ref/spec#Types), and their pointer base types are not type parameters but have identical underlying types.\n* `x`'s type and `T` are both integer or floating point types.\n* `x`'s type and `T` are both complex types.\n* `x` is an integer or a slice of bytes or runes and `T` is a string type.\n* `x` is a string and `T` is a slice of bytes or runes.\n* `x` is a slice, `T` is an array or a pointer to an array, and the slice and array types have [identical](https://go.dev/ref/spec#Type%5Fidentity) element types.\n\nAdditionally, if `T` or `x`'s type `V` are type parameters, `x`can also be converted to type `T` if one of the following conditions applies:\n\n* Both `V` and `T` are type parameters and a value of each type in `V`'s type set can be converted to each type in `T`'s type set.\n* Only `V` is a type parameter and a value of each type in `V`'s type set can be converted to `T`.\n* Only `T` is a type parameter and `x` can be converted to each type in `T`'s type set.\n\n[Struct tags](https://go.dev/ref/spec#Struct%5Ftypes) are ignored when comparing struct types for identity for the purpose of conversion:\n\ntype Person struct {\n\tName    string\n\tAddress *struct {\n\t\tStreet string\n\t\tCity   string\n\t}\n}\n\nvar data *struct {\n\tName    string `json:\"name\"`\n\tAddress *struct {\n\t\tStreet string `json:\"street\"`\n\t\tCity   string `json:\"city\"`\n\t} `json:\"address\"`\n}\n\nvar person = (*Person)(data)  // ignoring tags, the underlying types are identical\n\nSpecific rules apply to (non-constant) conversions between numeric types or to and from a string type. These conversions may change the representation of `x`and incur a run-time cost. All other conversions only change the type but not the representation of `x`.\n\nThere is no linguistic mechanism to convert between pointers and integers. The package [unsafe](https://go.dev/ref/spec#Package%5Funsafe)implements this functionality under restricted circumstances.\n\n#### Conversions between numeric types\n\nFor the conversion of non-constant numeric values, the following rules apply:\n\n1. When converting between [integer types](https://go.dev/ref/spec#Numeric%5Ftypes), if the value is a signed integer, it is sign extended to implicit infinite precision; otherwise it is zero extended. It is then truncated to fit in the result type's size. For example, if `v := uint16(0x10F0)`, then `uint32(int8(v)) == 0xFFFFFFF0`. The conversion always yields a valid value; there is no indication of overflow.\n2. When converting a [floating-point number](https://go.dev/ref/spec#Numeric%5Ftypes) to an integer, the fraction is discarded (truncation towards zero).\n3. When converting an integer or floating-point number to a floating-point type, or a [complex number](https://go.dev/ref/spec#Numeric%5Ftypes) to another complex type, the result value is rounded to the precision specified by the destination type. For instance, the value of a variable `x` of type `float32`may be stored using additional precision beyond that of an IEEE-754 32-bit number, but float32(x) represents the result of rounding `x`'s value to 32-bit precision. Similarly, `x + 0.1` may use more than 32 bits of precision, but `float32(x + 0.1)` does not.\n\nIn all non-constant conversions involving floating-point or complex values, if the result type cannot represent the value the conversion succeeds but the result value is implementation-dependent.\n\n#### Conversions to and from a string type\n\n1. Converting a signed or unsigned integer value to a string type yields a string containing the UTF-8 representation of the integer. Values outside the range of valid Unicode code points are converted to `\"\\uFFFD\"`.  \nstring('a')       // \"a\"  \nstring(-1)        // \"\\ufffd\" == \"\\xef\\xbf\\xbd\"  \nstring(0xf8)      // \"\\u00f8\" == \"ø\" == \"\\xc3\\xb8\"  \ntype myString string  \nmyString(0x65e5)  // \"\\u65e5\" == \"日\" == \"\\xe6\\x97\\xa5\"\n2. Converting a slice of bytes to a string type yields a string whose successive bytes are the elements of the slice.  \nstring([]byte{'h', 'e', 'l', 'l', '\\xc3', '\\xb8'})   // \"hellø\"  \nstring([]byte{})                                     // \"\"  \nstring([]byte(nil))                                  // \"\"  \ntype bytes []byte  \nstring(bytes{'h', 'e', 'l', 'l', '\\xc3', '\\xb8'})    // \"hellø\"  \ntype myByte byte  \nstring([]myByte{'w', 'o', 'r', 'l', 'd', '!'})       // \"world!\"  \nmyString([]myByte{'\\xf0', '\\x9f', '\\x8c', '\\x8d'})   // \"🌍\"\n3. Converting a slice of runes to a string type yields a string that is the concatenation of the individual rune values converted to strings.  \nstring([]rune{0x767d, 0x9d6c, 0x7fd4})   // \"\\u767d\\u9d6c\\u7fd4\" == \"白鵬翔\"  \nstring([]rune{})                         // \"\"  \nstring([]rune(nil))                      // \"\"  \ntype runes []rune  \nstring(runes{0x767d, 0x9d6c, 0x7fd4})    // \"\\u767d\\u9d6c\\u7fd4\" == \"白鵬翔\"  \ntype myRune rune  \nstring([]myRune{0x266b, 0x266c})         // \"\\u266b\\u266c\" == \"♫♬\"  \nmyString([]myRune{0x1f30e})              // \"\\U0001f30e\" == \"🌎\"\n4. Converting a value of a string type to a slice of bytes type yields a slice whose successive elements are the bytes of the string.  \n[]byte(\"hellø\")             // []byte{'h', 'e', 'l', 'l', '\\xc3', '\\xb8'}  \n[]byte(\"\")                  // []byte{}  \nbytes(\"hellø\")              // []byte{'h', 'e', 'l', 'l', '\\xc3', '\\xb8'}  \n[]myByte(\"world!\")          // []myByte{'w', 'o', 'r', 'l', 'd', '!'}  \n[]myByte(myString(\"🌏\"))    // []myByte{'\\xf0', '\\x9f', '\\x8c', '\\x8f'}\n5. Converting a value of a string type to a slice of runes type yields a slice containing the individual Unicode code points of the string.  \n[]rune(myString(\"白鵬翔\"))   // []rune{0x767d, 0x9d6c, 0x7fd4}  \n[]rune(\"\")                  // []rune{}  \nrunes(\"白鵬翔\")              // []rune{0x767d, 0x9d6c, 0x7fd4}  \n[]myRune(\"♫♬\")              // []myRune{0x266b, 0x266c}  \n[]myRune(myString(\"🌐\"))    // []myRune{0x1f310}\n\n#### Conversions from slice to array or array pointer\n\nConverting a slice to an array yields an array containing the elements of the underlying array of the slice. Similarly, converting a slice to an array pointer yields a pointer to the underlying array of the slice. In both cases, if the [length](https://go.dev/ref/spec#Length%5Fand%5Fcapacity) of the slice is less than the length of the array, a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics) occurs.\n\ns := make([]byte, 2, 4)\n\na0 := [0]byte(s)\na1 := [1]byte(s[1:])     // a1[0] == s[1]\na2 := [2]byte(s)         // a2[0] == s[0]\na4 := [4]byte(s)         // panics: len([4]byte) > len(s)\n\ns0 := (*[0]byte)(s)      // s0 != nil\ns1 := (*[1]byte)(s[1:])  // &s1[0] == &s[1]\ns2 := (*[2]byte)(s)      // &s2[0] == &s[0]\ns4 := (*[4]byte)(s)      // panics: len([4]byte) > len(s)\n\nvar t []string\nt0 := [0]string(t)       // ok for nil slice t\nt1 := (*[0]string)(t)    // t1 == nil\nt2 := (*[1]string)(t)    // panics: len([1]string) > len(t)\n\nu := make([]byte, 0)\nu0 := (*[0]byte)(u)      // u0 != nil\n\n### Constant expressions\n\nConstant expressions may contain only [constant](https://go.dev/ref/spec#Constants)operands and are evaluated at compile time.\n\nUntyped boolean, numeric, and string constants may be used as operands wherever it is legal to use an operand of boolean, numeric, or string type, respectively.\n\nA constant [comparison](https://go.dev/ref/spec#Comparison%5Foperators) always yields an untyped boolean constant. If the left operand of a constant[shift expression](https://go.dev/ref/spec#Operators) is an untyped constant, the result is an integer constant; otherwise it is a constant of the same type as the left operand, which must be of[integer type](https://go.dev/ref/spec#Numeric%5Ftypes).\n\nAny other operation on untyped constants results in an untyped constant of the same kind; that is, a boolean, integer, floating-point, complex, or string constant. If the untyped operands of a binary operation (other than a shift) are of different kinds, the result is of the operand's kind that appears later in this list: integer, rune, floating-point, complex. For example, an untyped integer constant divided by an untyped complex constant yields an untyped complex constant.\n\nconst a = 2 + 3.0          // a == 5.0   (untyped floating-point constant)\nconst b = 15 / 4           // b == 3     (untyped integer constant)\nconst c = 15 / 4.0         // c == 3.75  (untyped floating-point constant)\nconst Θ float64 = 3/2      // Θ == 1.0   (type float64, 3/2 is integer division)\nconst Π float64 = 3/2.     // Π == 1.5   (type float64, 3/2. is float division)\nconst d = 1 << 3.0         // d == 8     (untyped integer constant)\nconst e = 1.0 << 3         // e == 8     (untyped integer constant)\nconst f = int32(1) << 33   // illegal    (constant 8589934592 overflows int32)\nconst g = float64(2) >> 1  // illegal    (float64(2) is a typed floating-point constant)\nconst h = \"foo\" > \"bar\"    // h == true  (untyped boolean constant)\nconst j = true             // j == true  (untyped boolean constant)\nconst k = 'w' + 1          // k == 'x'   (untyped rune constant)\nconst l = \"hi\"             // l == \"hi\"  (untyped string constant)\nconst m = string(k)        // m == \"x\"   (type string)\nconst Σ = 1 - 0.707i       //            (untyped complex constant)\nconst Δ = Σ + 2.0e-4       //            (untyped complex constant)\nconst Φ = iota*1i - 1/1i   //            (untyped complex constant)\n\nApplying the built-in function `complex` to untyped integer, rune, or floating-point constants yields an untyped complex constant.\n\nconst ic = complex(0, c)   // ic == 3.75i  (untyped complex constant)\nconst iΘ = complex(0, Θ)   // iΘ == 1i     (type complex128)\n\nConstant expressions are always evaluated exactly; intermediate values and the constants themselves may require precision significantly larger than supported by any predeclared type in the language. The following are legal declarations:\n\nconst Huge = 1 << 100         // Huge == 1267650600228229401496703205376  (untyped integer constant)\nconst Four int8 = Huge >> 98  // Four == 4                                (type int8)\n\nThe divisor of a constant division or remainder operation must not be zero:\n\n3.14 / 0.0   // illegal: division by zero\n\nThe values of _typed_ constants must always be accurately[representable](https://go.dev/ref/spec#Representability) by values of the constant type. The following constant expressions are illegal:\n\nuint(-1)     // -1 cannot be represented as a uint\nint(3.14)    // 3.14 cannot be represented as an int\nint64(Huge)  // 1267650600228229401496703205376 cannot be represented as an int64\nFour * 300   // operand 300 cannot be represented as an int8 (type of Four)\nFour * 100   // product 400 cannot be represented as an int8 (type of Four)\n\nThe mask used by the unary bitwise complement operator `^` matches the rule for non-constants: the mask is all 1s for unsigned constants and -1 for signed and untyped constants.\n\n^1         // untyped integer constant, equal to -2\nuint8(^1)  // illegal: same as uint8(-2), -2 cannot be represented as a uint8\n^uint8(1)  // typed uint8 constant, same as 0xFF ^ uint8(1) = uint8(0xFE)\nint8(^1)   // same as int8(-2)\n^int8(1)   // same as -1 ^ int8(1) = -2\n\nImplementation restriction: A compiler may use rounding while computing untyped floating-point or complex constant expressions; see the implementation restriction in the section on [constants](https://go.dev/ref/spec#Constants). This rounding may cause a floating-point constant expression to be invalid in an integer context, even if it would be integral when calculated using infinite precision, and vice versa.\n\n### Order of evaluation\n\nAt package level, [initialization dependencies](https://go.dev/ref/spec#Package%5Finitialization)determine the evaluation order of individual initialization expressions in[variable declarations](https://go.dev/ref/spec#Variable%5Fdeclarations). Otherwise, when evaluating the [operands](https://go.dev/ref/spec#Operands) of an expression, assignment, or[return statement](https://go.dev/ref/spec#Return%5Fstatements), all function calls, method calls, and communication operations are evaluated in lexical left-to-right order.\n\nFor example, in the (function-local) assignment\n\ny[f()], ok = g(h(), i()+x[j()], <-c), k()\n\nthe function calls and communication happen in the order`f()`, `h()`, `i()`, `j()`,`<-c`, `g()`, and `k()`. However, the order of those events compared to the evaluation and indexing of `x` and the evaluation of `y` is not specified.\n\na := 1\nf := func() int { a++; return a }\nx := []int{a, f()}            // x may be [1, 2] or [2, 2]: evaluation order between a and f() is not specified\nm := map[int]int{a: 1, a: 2}  // m may be {2: 1} or {2: 2}: evaluation order between the two map assignments is not specified\nn := map[int]int{a: f()}      // n may be {2: 3} or {3: 3}: evaluation order between the key and the value is not specified\n\nAt package level, initialization dependencies override the left-to-right rule for individual initialization expressions, but not for operands within each expression:\n\nvar a, b, c = f() + v(), g(), sqr(u()) + v()\n\nfunc f() int        { return c }\nfunc g() int        { return a }\nfunc sqr(x int) int { return x*x }\n\n// functions u and v are independent of all other variables and functions\n\nThe function calls happen in the order`u()`, `sqr()`, `v()`,`f()`, `v()`, and `g()`.\n\nFloating-point operations within a single expression are evaluated according to the associativity of the operators. Explicit parentheses affect the evaluation by overriding the default associativity. In the expression `x + (y + z)` the addition `y + z`is performed before adding `x`."}