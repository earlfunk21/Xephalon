{"lang":"Go","title":"Statements","category":"","fullPath":"/Statements","markdown":"## Statements\n\nStatements control execution.\n\nStatement =\n\t[Declaration](https://go.dev/ref/spec#Declaration) | [LabeledStmt](https://go.dev/ref/spec#LabeledStmt) | [SimpleStmt](https://go.dev/ref/spec#SimpleStmt) |\n\t[GoStmt](https://go.dev/ref/spec#GoStmt) | [ReturnStmt](https://go.dev/ref/spec#ReturnStmt) | [BreakStmt](https://go.dev/ref/spec#BreakStmt) | [ContinueStmt](https://go.dev/ref/spec#ContinueStmt) | [GotoStmt](https://go.dev/ref/spec#GotoStmt) |\n\t[FallthroughStmt](https://go.dev/ref/spec#FallthroughStmt) | [Block](https://go.dev/ref/spec#Block) | [IfStmt](https://go.dev/ref/spec#IfStmt) | [SwitchStmt](https://go.dev/ref/spec#SwitchStmt) | [SelectStmt](https://go.dev/ref/spec#SelectStmt) | [ForStmt](https://go.dev/ref/spec#ForStmt) |\n\t[DeferStmt](https://go.dev/ref/spec#DeferStmt) .\n\nSimpleStmt = [EmptyStmt](https://go.dev/ref/spec#EmptyStmt) | [ExpressionStmt](https://go.dev/ref/spec#ExpressionStmt) | [SendStmt](https://go.dev/ref/spec#SendStmt) | [IncDecStmt](https://go.dev/ref/spec#IncDecStmt) | [Assignment](https://go.dev/ref/spec#Assignment) | [ShortVarDecl](https://go.dev/ref/spec#ShortVarDecl) .\n\n### Terminating statements\n\nA _terminating statement_ interrupts the regular flow of control in a [block](https://go.dev/ref/spec#Blocks). The following statements are terminating:\n\n1. A [\"return\"](https://go.dev/ref/spec#Return%5Fstatements) or[\"goto\"](https://go.dev/ref/spec#Goto%5Fstatements) statement.\n2. A call to the built-in function[panic](https://go.dev/ref/spec#Handling%5Fpanics).\n3. A [block](https://go.dev/ref/spec#Blocks) in which the statement list ends in a terminating statement.\n4. An [\"if\" statement](https://go.dev/ref/spec#If%5Fstatements) in which:  \n   * the \"else\" branch is present, and  \n   * both branches are terminating statements.\n5. A [\"for\" statement](https://go.dev/ref/spec#For%5Fstatements) in which:  \n   * there are no \"break\" statements referring to the \"for\" statement, and  \n   * the loop condition is absent, and  \n   * the \"for\" statement does not use a range clause.\n6. A [\"switch\" statement](https://go.dev/ref/spec#Switch%5Fstatements) in which:  \n   * there are no \"break\" statements referring to the \"switch\" statement,  \n   * there is a default case, and  \n   * the statement lists in each case, including the default, end in a terminating statement, or a possibly labeled [\"fallthrough\" statement](https://go.dev/ref/spec#Fallthrough%5Fstatements).\n7. A [\"select\" statement](https://go.dev/ref/spec#Select%5Fstatements) in which:  \n   * there are no \"break\" statements referring to the \"select\" statement, and  \n   * the statement lists in each case, including the default if present, end in a terminating statement.\n8. A [labeled statement](https://go.dev/ref/spec#Labeled%5Fstatements) labeling a terminating statement.\n\nAll other statements are not terminating.\n\nA [statement list](https://go.dev/ref/spec#Blocks) ends in a terminating statement if the list is not empty and its final non-empty statement is terminating.\n\n### Empty statements\n\nThe empty statement does nothing.\n\nEmptyStmt = .\n\n### Labeled statements\n\nA labeled statement may be the target of a `goto`,`break` or `continue` statement.\n\nLabeledStmt = [Label](https://go.dev/ref/spec#Label) \":\" [Statement](https://go.dev/ref/spec#Statement) .\nLabel       = [identifier](https://go.dev/ref/spec#identifier) .\n\nError: log.Panic(\"error encountered\")\n\n### Expression statements\n\nWith the exception of specific built-in functions, function and method [calls](https://go.dev/ref/spec#Calls) and[receive operations](https://go.dev/ref/spec#Receive%5Foperator)can appear in statement context. Such statements may be parenthesized.\n\nExpressionStmt = [Expression](https://go.dev/ref/spec#Expression) .\n\nThe following built-in functions are not permitted in statement context:\n\nappend cap complex imag len make new real\nunsafe.Add unsafe.Alignof unsafe.Offsetof unsafe.Sizeof unsafe.Slice\n\nh(x+y)\nf.Close()\n<-ch\n(<-ch)\nlen(\"foo\")  // illegal if len is the built-in function\n\n### Send statements\n\nA send statement sends a value on a channel. The channel expression's [core type](https://go.dev/ref/spec#Core%5Ftypes)must be a [channel](https://go.dev/ref/spec#Channel%5Ftypes), the channel direction must permit send operations, and the type of the value to be sent must be [assignable](https://go.dev/ref/spec#Assignability)to the channel's element type.\n\nSendStmt = [Channel](https://go.dev/ref/spec#Channel) \"<-\" [Expression](https://go.dev/ref/spec#Expression) .\nChannel  = [Expression](https://go.dev/ref/spec#Expression) .\n\nBoth the channel and the value expression are evaluated before communication begins. Communication blocks until the send can proceed. A send on an unbuffered channel can proceed if a receiver is ready. A send on a buffered channel can proceed if there is room in the buffer. A send on a closed channel proceeds by causing a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics). A send on a `nil` channel blocks forever.\n\nch <- 3  // send value 3 to channel ch\n\n### IncDec statements\n\nThe \"++\" and \"--\" statements increment or decrement their operands by the untyped [constant](https://go.dev/ref/spec#Constants) `1`. As with an assignment, the operand must be [addressable](https://go.dev/ref/spec#Address%5Foperators)or a map index expression.\n\nIncDecStmt = [Expression](https://go.dev/ref/spec#Expression) ( \"++\" | \"--\" ) .\n\nThe following [assignment statements](https://go.dev/ref/spec#Assignment%5Fstatements) are semantically equivalent:\n\nIncDec statement    Assignment\nx++                 x += 1\nx--                 x -= 1\n\n### Assignment statements\n\nAn _assignment_ replaces the current value stored in a [variable](https://go.dev/ref/spec#Variables)with a new value specified by an [expression](https://go.dev/ref/spec#Expressions). An assignment statement may assign a single value to a single variable, or multiple values to a matching number of variables.\n\nAssignment = [ExpressionList](https://go.dev/ref/spec#ExpressionList) [assign_op](https://go.dev/ref/spec#assign%5Fop) [ExpressionList](https://go.dev/ref/spec#ExpressionList) .\n\nassign_op = [ [add_op](https://go.dev/ref/spec#add%5Fop) | [mul_op](https://go.dev/ref/spec#mul%5Fop) ] \"=\" .\n\nEach left-hand side operand must be [addressable](https://go.dev/ref/spec#Address%5Foperators), a map index expression, or (for `=` assignments only) the[blank identifier](https://go.dev/ref/spec#Blank%5Fidentifier). Operands may be parenthesized.\n\nx = 1\n*p = f()\na[i] = 23\n(k) = <-ch  // same as: k = <-ch\n\nAn _assignment operation_ `x` _op_`=` `y` where _op_ is a binary [arithmetic operator](https://go.dev/ref/spec#Arithmetic%5Foperators)is equivalent to `x` `=` `x` _op_ `(y)` but evaluates `x`only once. The _op_`=` construct is a single token. In assignment operations, both the left- and right-hand expression lists must contain exactly one single-valued expression, and the left-hand expression must not be the blank identifier.\n\na[i] <<= 2\ni &^= 1<<n\n\nA tuple assignment assigns the individual elements of a multi-valued operation to a list of variables. There are two forms. In the first, the right hand operand is a single multi-valued expression such as a function call, a [channel](https://go.dev/ref/spec#Channel%5Ftypes) or[map](https://go.dev/ref/spec#Map%5Ftypes) operation, or a [type assertion](https://go.dev/ref/spec#Type%5Fassertions). The number of operands on the left hand side must match the number of values. For instance, if`f` is a function returning two values,\n\nx, y = f()\n\nassigns the first value to `x` and the second to `y`. In the second form, the number of operands on the left must equal the number of expressions on the right, each of which must be single-valued, and the_n_th expression on the right is assigned to the _n_th operand on the left:\n\none, two, three = '一', '二', '三'\n\nThe [blank identifier](https://go.dev/ref/spec#Blank%5Fidentifier) provides a way to ignore right-hand side values in an assignment:\n\n_ = x       // evaluate x but ignore it\nx, _ = f()  // evaluate f() but ignore second result value\n\nThe assignment proceeds in two phases. First, the operands of [index expressions](https://go.dev/ref/spec#Index%5Fexpressions)and [pointer indirections](https://go.dev/ref/spec#Address%5Foperators)(including implicit pointer indirections in [selectors](https://go.dev/ref/spec#Selectors)) on the left and the expressions on the right are all[evaluated in the usual order](https://go.dev/ref/spec#Order%5Fof%5Fevaluation). Second, the assignments are carried out in left-to-right order.\n\na, b = b, a  // exchange a and b\n\nx := []int{1, 2, 3}\ni := 0\ni, x[i] = 1, 2  // set i = 1, x[0] = 2\n\ni = 0\nx[i], i = 2, 1  // set x[0] = 2, i = 1\n\nx[0], x[0] = 1, 2  // set x[0] = 1, then x[0] = 2 (so x[0] == 2 at end)\n\nx[1], x[3] = 4, 5  // set x[1] = 4, then panic setting x[3] = 5.\n\ntype Point struct { x, y int }\nvar p *Point\nx[2], p.x = 6, 7  // set x[2] = 6, then panic setting p.x = 7\n\ni = 2\nx = []int{3, 5, 7}\nfor i, x[i] = range x {  // set i, x[2] = 0, x[0]\n\tbreak\n}\n// after this loop, i == 0 and x == []int{3, 5, 3}\n\nIn assignments, each value must be [assignable](https://go.dev/ref/spec#Assignability)to the type of the operand to which it is assigned, with the following special cases:\n\n1. Any typed value may be assigned to the blank identifier.\n2. If an untyped constant is assigned to a variable of interface type or the blank identifier, the constant is first implicitly [converted](https://go.dev/ref/spec#Conversions) to its[default type](https://go.dev/ref/spec#Constants).\n3. If an untyped boolean value is assigned to a variable of interface type or the blank identifier, it is first implicitly converted to type `bool`.\n\n### If statements\n\n\"If\" statements specify the conditional execution of two branches according to the value of a boolean expression. If the expression evaluates to true, the \"if\" branch is executed, otherwise, if present, the \"else\" branch is executed.\n\nIfStmt = \"if\" [ [SimpleStmt](https://go.dev/ref/spec#SimpleStmt) \";\" ] [Expression](https://go.dev/ref/spec#Expression) [Block](https://go.dev/ref/spec#Block) [ \"else\" ( [IfStmt](https://go.dev/ref/spec#IfStmt) | [Block](https://go.dev/ref/spec#Block) ) ] .\n\nif x > max {\n\tx = max\n}\n\nThe expression may be preceded by a simple statement, which executes before the expression is evaluated.\n\nif x := f(); x < y {\n\treturn x\n} else if x > z {\n\treturn z\n} else {\n\treturn y\n}\n\n### Switch statements\n\n\"Switch\" statements provide multi-way execution. An expression or type is compared to the \"cases\" inside the \"switch\" to determine which branch to execute.\n\nSwitchStmt = [ExprSwitchStmt](https://go.dev/ref/spec#ExprSwitchStmt) | [TypeSwitchStmt](https://go.dev/ref/spec#TypeSwitchStmt) .\n\nThere are two forms: expression switches and type switches. In an expression switch, the cases contain expressions that are compared against the value of the switch expression. In a type switch, the cases contain types that are compared against the type of a specially annotated switch expression. The switch expression is evaluated exactly once in a switch statement.\n\n#### Expression switches\n\nIn an expression switch, the switch expression is evaluated and the case expressions, which need not be constants, are evaluated left-to-right and top-to-bottom; the first one that equals the switch expression triggers execution of the statements of the associated case; the other cases are skipped. If no case matches and there is a \"default\" case, its statements are executed. There can be at most one default case and it may appear anywhere in the \"switch\" statement. A missing switch expression is equivalent to the boolean value`true`.\n\nExprSwitchStmt = \"switch\" [ [SimpleStmt](https://go.dev/ref/spec#SimpleStmt) \";\" ] [ [Expression](https://go.dev/ref/spec#Expression) ] \"{\" { [ExprCaseClause](https://go.dev/ref/spec#ExprCaseClause) } \"}\" .\nExprCaseClause = [ExprSwitchCase](https://go.dev/ref/spec#ExprSwitchCase) \":\" [StatementList](https://go.dev/ref/spec#StatementList) .\nExprSwitchCase = \"case\" [ExpressionList](https://go.dev/ref/spec#ExpressionList) | \"default\" .\n\nIf the switch expression evaluates to an untyped constant, it is first implicitly[converted](https://go.dev/ref/spec#Conversions) to its [default type](https://go.dev/ref/spec#Constants). The predeclared untyped value `nil` cannot be used as a switch expression. The switch expression type must be [comparable](https://go.dev/ref/spec#Comparison%5Foperators).\n\nIf a case expression is untyped, it is first implicitly [converted](https://go.dev/ref/spec#Conversions)to the type of the switch expression. For each (possibly converted) case expression `x` and the value `t`of the switch expression, `x == t` must be a valid [comparison](https://go.dev/ref/spec#Comparison%5Foperators).\n\nIn other words, the switch expression is treated as if it were used to declare and initialize a temporary variable `t` without explicit type; it is that value of `t` against which each case expression `x` is tested for equality.\n\nIn a case or default clause, the last non-empty statement may be a (possibly [labeled](https://go.dev/ref/spec#Labeled%5Fstatements))[\"fallthrough\" statement](https://go.dev/ref/spec#Fallthrough%5Fstatements) to indicate that control should flow from the end of this clause to the first statement of the next clause. Otherwise control flows to the end of the \"switch\" statement. A \"fallthrough\" statement may appear as the last statement of all but the last clause of an expression switch.\n\nThe switch expression may be preceded by a simple statement, which executes before the expression is evaluated.\n\nswitch tag {\ndefault: s3()\ncase 0, 1, 2, 3: s1()\ncase 4, 5, 6, 7: s2()\n}\n\nswitch x := f(); {  // missing switch expression means \"true\"\ncase x < 0: return -x\ndefault: return x\n}\n\nswitch {\ncase x < y: f1()\ncase x < z: f2()\ncase x == 4: f3()\n}\n\nImplementation restriction: A compiler may disallow multiple case expressions evaluating to the same constant. For instance, the current compilers disallow duplicate integer, floating point, or string constants in case expressions.\n\n#### Type switches\n\nA type switch compares types rather than values. It is otherwise similar to an expression switch. It is marked by a special switch expression that has the form of a [type assertion](https://go.dev/ref/spec#Type%5Fassertions)using the keyword `type` rather than an actual type:\n\nswitch x.(type) {\n// cases\n}\n\nCases then match actual types `T` against the dynamic type of the expression `x`. As with type assertions, `x` must be of[interface type](https://go.dev/ref/spec#Interface%5Ftypes), but not a[type parameter](https://go.dev/ref/spec#Type%5Fparameter%5Fdeclarations), and each non-interface type`T` listed in a case must implement the type of `x`. The types listed in the cases of a type switch must all be[different](https://go.dev/ref/spec#Type%5Fidentity).\n\nTypeSwitchStmt  = \"switch\" [ [SimpleStmt](https://go.dev/ref/spec#SimpleStmt) \";\" ] [TypeSwitchGuard](https://go.dev/ref/spec#TypeSwitchGuard) \"{\" { [TypeCaseClause](https://go.dev/ref/spec#TypeCaseClause) } \"}\" .\nTypeSwitchGuard = [ [identifier](https://go.dev/ref/spec#identifier) \":=\" ] [PrimaryExpr](https://go.dev/ref/spec#PrimaryExpr) \".\" \"(\" \"type\" \")\" .\nTypeCaseClause  = [TypeSwitchCase](https://go.dev/ref/spec#TypeSwitchCase) \":\" [StatementList](https://go.dev/ref/spec#StatementList) .\nTypeSwitchCase  = \"case\" [TypeList](https://go.dev/ref/spec#TypeList) | \"default\" .\n\nThe TypeSwitchGuard may include a[short variable declaration](https://go.dev/ref/spec#Short%5Fvariable%5Fdeclarations). When that form is used, the variable is declared at the end of the TypeSwitchCase in the [implicit block](https://go.dev/ref/spec#Blocks) of each clause. In clauses with a case listing exactly one type, the variable has that type; otherwise, the variable has the type of the expression in the TypeSwitchGuard.\n\nInstead of a type, a case may use the predeclared identifier[nil](https://go.dev/ref/spec#Predeclared%5Fidentifiers); that case is selected when the expression in the TypeSwitchGuard is a `nil` interface value. There may be at most one `nil` case.\n\nGiven an expression `x` of type `interface{}`, the following type switch:\n\nswitch i := x.(type) {\ncase nil:\n\tprintString(\"x is nil\")                // type of i is type of x (interface{})\ncase int:\n\tprintInt(i)                            // type of i is int\ncase float64:\n\tprintFloat64(i)                        // type of i is float64\ncase func(int) float64:\n\tprintFunction(i)                       // type of i is func(int) float64\ncase bool, string:\n\tprintString(\"type is bool or string\")  // type of i is type of x (interface{})\ndefault:\n\tprintString(\"don't know the type\")     // type of i is type of x (interface{})\n}\n\ncould be rewritten:\n\nv := x  // x is evaluated exactly once\nif v == nil {\n\ti := v                                 // type of i is type of x (interface{})\n\tprintString(\"x is nil\")\n} else if i, isInt := v.(int); isInt {\n\tprintInt(i)                            // type of i is int\n} else if i, isFloat64 := v.(float64); isFloat64 {\n\tprintFloat64(i)                        // type of i is float64\n} else if i, isFunc := v.(func(int) float64); isFunc {\n\tprintFunction(i)                       // type of i is func(int) float64\n} else {\n\t_, isBool := v.(bool)\n\t_, isString := v.(string)\n\tif isBool || isString {\n\t\ti := v                         // type of i is type of x (interface{})\n\t\tprintString(\"type is bool or string\")\n\t} else {\n\t\ti := v                         // type of i is type of x (interface{})\n\t\tprintString(\"don't know the type\")\n\t}\n}\n\nA [type parameter](https://go.dev/ref/spec#Type%5Fparameter%5Fdeclarations) or a [generic type](https://go.dev/ref/spec#Type%5Fdeclarations)may be used as a type in a case. If upon [instantiation](https://go.dev/ref/spec#Instantiations) that type turns out to duplicate another entry in the switch, the first matching case is chosen.\n\nfunc f[P any](x any) int {\n\tswitch x.(type) {\n\tcase P:\n\t\treturn 0\n\tcase string:\n\t\treturn 1\n\tcase []P:\n\t\treturn 2\n\tcase []byte:\n\t\treturn 3\n\tdefault:\n\t\treturn 4\n\t}\n}\n\nvar v1 = f[string](\"foo\")   // v1 == 0\nvar v2 = f[byte]([]byte{})  // v2 == 2\n\nThe type switch guard may be preceded by a simple statement, which executes before the guard is evaluated.\n\nThe \"fallthrough\" statement is not permitted in a type switch.\n\n### For statements\n\nA \"for\" statement specifies repeated execution of a block. There are three forms: The iteration may be controlled by a single condition, a \"for\" clause, or a \"range\" clause.\n\nForStmt = \"for\" [ [Condition](https://go.dev/ref/spec#Condition) | [ForClause](https://go.dev/ref/spec#ForClause) | [RangeClause](https://go.dev/ref/spec#RangeClause) ] [Block](https://go.dev/ref/spec#Block) .\nCondition = [Expression](https://go.dev/ref/spec#Expression) .\n\n#### For statements with single condition\n\nIn its simplest form, a \"for\" statement specifies the repeated execution of a block as long as a boolean condition evaluates to true. The condition is evaluated before each iteration. If the condition is absent, it is equivalent to the boolean value`true`.\n\nfor a < b {\n\ta *= 2\n}\n\n#### For statements with `for` clause\n\nA \"for\" statement with a ForClause is also controlled by its condition, but additionally it may specify an _init_and a _post_ statement, such as an assignment, an increment or decrement statement. The init statement may be a[short variable declaration](https://go.dev/ref/spec#Short%5Fvariable%5Fdeclarations), but the post statement must not. Variables declared by the init statement are re-used in each iteration.\n\nForClause = [ [InitStmt](https://go.dev/ref/spec#InitStmt) ] \";\" [ [Condition](https://go.dev/ref/spec#Condition) ] \";\" [ [PostStmt](https://go.dev/ref/spec#PostStmt) ] .\nInitStmt = [SimpleStmt](https://go.dev/ref/spec#SimpleStmt) .\nPostStmt = [SimpleStmt](https://go.dev/ref/spec#SimpleStmt) .\n\nfor i := 0; i < 10; i++ {\n\tf(i)\n}\n\nIf non-empty, the init statement is executed once before evaluating the condition for the first iteration; the post statement is executed after each execution of the block (and only if the block was executed). Any element of the ForClause may be empty but the[semicolons](https://go.dev/ref/spec#Semicolons) are required unless there is only a condition. If the condition is absent, it is equivalent to the boolean value`true`.\n\nfor cond { S() }    is the same as    for ; cond ; { S() }\nfor      { S() }    is the same as    for true     { S() }\n\n#### For statements with `range` clause\n\nA \"for\" statement with a \"range\" clause iterates through all entries of an array, slice, string or map, or values received on a channel. For each entry it assigns _iteration values_to corresponding _iteration variables_ if present and then executes the block.\n\nRangeClause = [ [ExpressionList](https://go.dev/ref/spec#ExpressionList) \"=\" | [IdentifierList](https://go.dev/ref/spec#IdentifierList) \":=\" ] \"range\" [Expression](https://go.dev/ref/spec#Expression) .\n\nThe expression on the right in the \"range\" clause is called the _range expression_, its [core type](https://go.dev/ref/spec#Core%5Ftypes) must be an array, pointer to an array, slice, string, map, or channel permitting[receive operations](https://go.dev/ref/spec#Receive%5Foperator). As with an assignment, if present the operands on the left must be[addressable](https://go.dev/ref/spec#Address%5Foperators) or map index expressions; they denote the iteration variables. If the range expression is a channel, at most one iteration variable is permitted, otherwise there may be up to two. If the last iteration variable is the [blank identifier](https://go.dev/ref/spec#Blank%5Fidentifier), the range clause is equivalent to the same clause without that identifier.\n\nThe range expression `x` is evaluated once before beginning the loop, with one exception: if at most one iteration variable is present and`len(x)` is [constant](https://go.dev/ref/spec#Length%5Fand%5Fcapacity), the range expression is not evaluated.\n\nFunction calls on the left are evaluated once per iteration. For each iteration, iteration values are produced as follows if the respective iteration variables are present:\n\nRange expression                          1st value          2nd value\n\narray or slice  a  [n]E, *[n]E, or []E    index    i  int    a[i]       E\nstring          s  string type            index    i  int    see below  rune\nmap             m  map[K]V                key      k  K      m[k]       V\nchannel         c  chan E, <-chan E       element  e  E\n\n1. For an array, pointer to array, or slice value `a`, the index iteration values are produced in increasing order, starting at element index 0\\. If at most one iteration variable is present, the range loop produces iteration values from 0 up to `len(a)-1` and does not index into the array or slice itself. For a `nil` slice, the number of iterations is 0.\n2. For a string value, the \"range\" clause iterates over the Unicode code points in the string starting at byte index 0\\. On successive iterations, the index value will be the index of the first byte of successive UTF-8-encoded code points in the string, and the second value, of type `rune`, will be the value of the corresponding code point. If the iteration encounters an invalid UTF-8 sequence, the second value will be `0xFFFD`, the Unicode replacement character, and the next iteration will advance a single byte in the string.\n3. The iteration order over maps is not specified and is not guaranteed to be the same from one iteration to the next. If a map entry that has not yet been reached is removed during iteration, the corresponding iteration value will not be produced. If a map entry is created during iteration, that entry may be produced during the iteration or may be skipped. The choice may vary for each entry created and from one iteration to the next. If the map is `nil`, the number of iterations is 0.\n4. For channels, the iteration values produced are the successive values sent on the channel until the channel is [closed](https://go.dev/ref/spec#Close). If the channel is `nil`, the range expression blocks forever.\n\nThe iteration values are assigned to the respective iteration variables as in an [assignment statement](https://go.dev/ref/spec#Assignment%5Fstatements).\n\nThe iteration variables may be declared by the \"range\" clause using a form of[short variable declaration](https://go.dev/ref/spec#Short%5Fvariable%5Fdeclarations)(`:=`). In this case their types are set to the types of the respective iteration values and their [scope](https://go.dev/ref/spec#Declarations%5Fand%5Fscope) is the block of the \"for\" statement; they are re-used in each iteration. If the iteration variables are declared outside the \"for\" statement, after execution their values will be those of the last iteration.\n\nvar testdata *struct {\n\ta *[7]int\n}\nfor i, _ := range testdata.a {\n\t// testdata.a is never evaluated; len(testdata.a) is constant\n\t// i ranges from 0 to 6\n\tf(i)\n}\n\nvar a [10]string\nfor i, s := range a {\n\t// type of i is int\n\t// type of s is string\n\t// s == a[i]\n\tg(i, s)\n}\n\nvar key string\nvar val interface{}  // element type of m is assignable to val\nm := map[string]int{\"mon\":0, \"tue\":1, \"wed\":2, \"thu\":3, \"fri\":4, \"sat\":5, \"sun\":6}\nfor key, val = range m {\n\th(key, val)\n}\n// key == last map key encountered in iteration\n// val == map[key]\n\nvar ch chan Work = producer()\nfor w := range ch {\n\tdoWork(w)\n}\n\n// empty a channel\nfor range ch {}\n\n### Go statements\n\nA \"go\" statement starts the execution of a function call as an independent concurrent thread of control, or _goroutine_, within the same address space.\n\nGoStmt = \"go\" [Expression](https://go.dev/ref/spec#Expression) .\n\nThe expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for[expression statements](https://go.dev/ref/spec#Expression%5Fstatements).\n\nThe function value and parameters are[evaluated as usual](https://go.dev/ref/spec#Calls)in the calling goroutine, but unlike with a regular call, program execution does not wait for the invoked function to complete. Instead, the function begins executing independently in a new goroutine. When the function terminates, its goroutine also terminates. If the function has any return values, they are discarded when the function completes.\n\ngo Server()\ngo func(ch chan<- bool) { for { sleep(10); ch <- true }} (c)\n\n### Select statements\n\nA \"select\" statement chooses which of a set of possible[send](https://go.dev/ref/spec#Send%5Fstatements) or[receive](https://go.dev/ref/spec#Receive%5Foperator)operations will proceed. It looks similar to a[\"switch\"](https://go.dev/ref/spec#Switch%5Fstatements) statement but with the cases all referring to communication operations.\n\nSelectStmt = \"select\" \"{\" { [CommClause](https://go.dev/ref/spec#CommClause) } \"}\" .\nCommClause = [CommCase](https://go.dev/ref/spec#CommCase) \":\" [StatementList](https://go.dev/ref/spec#StatementList) .\nCommCase   = \"case\" ( [SendStmt](https://go.dev/ref/spec#SendStmt) | [RecvStmt](https://go.dev/ref/spec#RecvStmt) ) | \"default\" .\nRecvStmt   = [ [ExpressionList](https://go.dev/ref/spec#ExpressionList) \"=\" | [IdentifierList](https://go.dev/ref/spec#IdentifierList) \":=\" ] [RecvExpr](https://go.dev/ref/spec#RecvExpr) .\nRecvExpr   = [Expression](https://go.dev/ref/spec#Expression) .\n\nA case with a RecvStmt may assign the result of a RecvExpr to one or two variables, which may be declared using a[short variable declaration](https://go.dev/ref/spec#Short%5Fvariable%5Fdeclarations). The RecvExpr must be a (possibly parenthesized) receive operation. There can be at most one default case and it may appear anywhere in the list of cases.\n\nExecution of a \"select\" statement proceeds in several steps:\n\n1. For all the cases in the statement, the channel operands of receive operations and the channel and right-hand-side expressions of send statements are evaluated exactly once, in source order, upon entering the \"select\" statement. The result is a set of channels to receive from or send to, and the corresponding values to send. Any side effects in that evaluation will occur irrespective of which (if any) communication operation is selected to proceed. Expressions on the left-hand side of a RecvStmt with a short variable declaration or assignment are not yet evaluated.\n2. If one or more of the communications can proceed, a single one that can proceed is chosen via a uniform pseudo-random selection. Otherwise, if there is a default case, that case is chosen. If there is no default case, the \"select\" statement blocks until at least one of the communications can proceed.\n3. Unless the selected case is the default case, the respective communication operation is executed.\n4. If the selected case is a RecvStmt with a short variable declaration or an assignment, the left-hand side expressions are evaluated and the received value (or values) are assigned.\n5. The statement list of the selected case is executed.\n\nSince communication on `nil` channels can never proceed, a select with only `nil` channels and no default case blocks forever.\n\nvar a []int\nvar c, c1, c2, c3, c4 chan int\nvar i1, i2 int\nselect {\ncase i1 = <-c1:\n\tprint(\"received \", i1, \" from c1\\n\")\ncase c2 <- i2:\n\tprint(\"sent \", i2, \" to c2\\n\")\ncase i3, ok := (<-c3):  // same as: i3, ok := <-c3\n\tif ok {\n\t\tprint(\"received \", i3, \" from c3\\n\")\n\t} else {\n\t\tprint(\"c3 is closed\\n\")\n\t}\ncase a[f()] = <-c4:\n\t// same as:\n\t// case t := <-c4\n\t//\ta[f()] = t\ndefault:\n\tprint(\"no communication\\n\")\n}\n\nfor {  // send random sequence of bits to c\n\tselect {\n\tcase c <- 0:  // note: no statement, no fallthrough, no folding of cases\n\tcase c <- 1:\n\t}\n}\n\nselect {}  // block forever\n\n### Return statements\n\nA \"return\" statement in a function `F` terminates the execution of `F`, and optionally provides one or more result values. Any functions [deferred](https://go.dev/ref/spec#Defer%5Fstatements) by `F`are executed before `F` returns to its caller.\n\nReturnStmt = \"return\" [ [ExpressionList](https://go.dev/ref/spec#ExpressionList) ] .\n\nIn a function without a result type, a \"return\" statement must not specify any result values.\n\nfunc noResult() {\n\treturn\n}\n\nThere are three ways to return values from a function with a result type:\n\n1. The return value or values may be explicitly listed in the \"return\" statement. Each expression must be single-valued and [assignable](https://go.dev/ref/spec#Assignability) to the corresponding element of the function's result type.  \nfunc simpleF() int {  \n\treturn 2  \n}  \nfunc complexF1() (re float64, im float64) {  \n\treturn -7.0, -4.0  \n}\n2. The expression list in the \"return\" statement may be a single call to a multi-valued function. The effect is as if each value returned from that function were assigned to a temporary variable with the type of the respective value, followed by a \"return\" statement listing these variables, at which point the rules of the previous case apply.  \nfunc complexF2() (re float64, im float64) {  \n\treturn complexF1()  \n}\n3. The expression list may be empty if the function's result type specifies names for its [result parameters](https://go.dev/ref/spec#Function%5Ftypes). The result parameters act as ordinary local variables and the function may assign values to them as necessary. The \"return\" statement returns the values of these variables.  \nfunc complexF3() (re float64, im float64) {  \n\tre = 7.0  \n\tim = 4.0  \n\treturn  \n}  \nfunc (devnull) Write(p []byte) (n int, _ error) {  \n\tn = len(p)  \n\treturn  \n}\n\nRegardless of how they are declared, all the result values are initialized to the [zero values](https://go.dev/ref/spec#The%5Fzero%5Fvalue) for their type upon entry to the function. A \"return\" statement that specifies results sets the result parameters before any deferred functions are executed.\n\nImplementation restriction: A compiler may disallow an empty expression list in a \"return\" statement if a different entity (constant, type, or variable) with the same name as a result parameter is in[scope](https://go.dev/ref/spec#Declarations%5Fand%5Fscope) at the place of the return.\n\nfunc f(n int) (res int, err error) {\n\tif _, err := f(n-1); err != nil {\n\t\treturn  // invalid return statement: err is shadowed\n\t}\n\treturn\n}\n\n### Break statements\n\nA \"break\" statement terminates execution of the innermost[\"for\"](https://go.dev/ref/spec#For%5Fstatements),[\"switch\"](https://go.dev/ref/spec#Switch%5Fstatements), or[\"select\"](https://go.dev/ref/spec#Select%5Fstatements) statement within the same function.\n\nBreakStmt = \"break\" [ [Label](https://go.dev/ref/spec#Label) ] .\n\nIf there is a label, it must be that of an enclosing \"for\", \"switch\", or \"select\" statement, and that is the one whose execution terminates.\n\nOuterLoop:\n\tfor i = 0; i < n; i++ {\n\t\tfor j = 0; j < m; j++ {\n\t\t\tswitch a[i][j] {\n\t\t\tcase nil:\n\t\t\t\tstate = Error\n\t\t\t\tbreak OuterLoop\n\t\t\tcase item:\n\t\t\t\tstate = Found\n\t\t\t\tbreak OuterLoop\n\t\t\t}\n\t\t}\n\t}\n\n### Continue statements\n\nA \"continue\" statement begins the next iteration of the innermost enclosing [\"for\" loop](https://go.dev/ref/spec#For%5Fstatements)by advancing control to the end of the loop block. The \"for\" loop must be within the same function.\n\nContinueStmt = \"continue\" [ [Label](https://go.dev/ref/spec#Label) ] .\n\nIf there is a label, it must be that of an enclosing \"for\" statement, and that is the one whose execution advances.\n\nRowLoop:\n\tfor y, row := range rows {\n\t\tfor x, data := range row {\n\t\t\tif data == endOfRow {\n\t\t\t\tcontinue RowLoop\n\t\t\t}\n\t\t\trow[x] = data + bias(x, y)\n\t\t}\n\t}\n\n### Goto statements\n\nA \"goto\" statement transfers control to the statement with the corresponding label within the same function.\n\nGotoStmt = \"goto\" [Label](https://go.dev/ref/spec#Label) .\n\ngoto Error\n\nExecuting the \"goto\" statement must not cause any variables to come into[scope](https://go.dev/ref/spec#Declarations%5Fand%5Fscope) that were not already in scope at the point of the goto. For instance, this example:\n\n\tgoto L  // BAD\n\tv := 3\nL:\n\nis erroneous because the jump to label `L` skips the creation of `v`.\n\nA \"goto\" statement outside a [block](https://go.dev/ref/spec#Blocks) cannot jump to a label inside that block. For instance, this example:\n\nif n%2 == 1 {\n\tgoto L1\n}\nfor n > 0 {\n\tf()\n\tn--\nL1:\n\tf()\n\tn--\n}\n\nis erroneous because the label `L1` is inside the \"for\" statement's block but the `goto` is not.\n\n### Fallthrough statements\n\nA \"fallthrough\" statement transfers control to the first statement of the next case clause in an [expression \"switch\" statement](https://go.dev/ref/spec#Expression%5Fswitches). It may be used only as the final non-empty statement in such a clause.\n\nFallthroughStmt = \"fallthrough\" .\n\n### Defer statements\n\nA \"defer\" statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a [return statement](https://go.dev/ref/spec#Return%5Fstatements), reached the end of its [function body](https://go.dev/ref/spec#Function%5Fdeclarations), or because the corresponding goroutine is [panicking](https://go.dev/ref/spec#Handling%5Fpanics).\n\nDeferStmt = \"defer\" [Expression](https://go.dev/ref/spec#Expression) .\n\nThe expression must be a function or method call; it cannot be parenthesized. Calls of built-in functions are restricted as for[expression statements](https://go.dev/ref/spec#Expression%5Fstatements).\n\nEach time a \"defer\" statement executes, the function value and parameters to the call are[evaluated as usual](https://go.dev/ref/spec#Calls)and saved anew but the actual function is not invoked. Instead, deferred functions are invoked immediately before the surrounding function returns, in the reverse order they were deferred. That is, if the surrounding function returns through an explicit [return statement](https://go.dev/ref/spec#Return%5Fstatements), deferred functions are executed _after_ any result parameters are set by that return statement but _before_ the function returns to its caller. If a deferred function value evaluates to `nil`, execution [panics](https://go.dev/ref/spec#Handling%5Fpanics)when the function is invoked, not when the \"defer\" statement is executed.\n\nFor instance, if the deferred function is a [function literal](https://go.dev/ref/spec#Function%5Fliterals) and the surrounding function has [named result parameters](https://go.dev/ref/spec#Function%5Ftypes) that are in scope within the literal, the deferred function may access and modify the result parameters before they are returned. If the deferred function has any return values, they are discarded when the function completes. (See also the section on [handling panics](https://go.dev/ref/spec#Handling%5Fpanics).)\n\nlock(l)\ndefer unlock(l)  // unlocking happens before surrounding function returns\n\n// prints 3 2 1 0 before surrounding function returns\nfor i := 0; i <= 3; i++ {\n\tdefer fmt.Print(i)\n}\n\n// f returns 42\nfunc f() (result int) {\n\tdefer func() {\n\t\t// result is accessed after it was set to 6 by the return statement\n\t\tresult *= 7\n\t}()\n\treturn 6\n}"}