{"lang":"Go","title":"System considerations","category":"","fullPath":"/System_considerations","markdown":"## System considerations\n\n### Package `unsafe`\n\nThe built-in package `unsafe`, known to the compiler and accessible through the [import path](https://go.dev/ref/spec#Import%5Fdeclarations) `\"unsafe\"`, provides facilities for low-level programming including operations that violate the type system. A package using `unsafe`must be vetted manually for type safety and may not be portable. The package provides the following interface:\n\npackage unsafe\n\ntype ArbitraryType int  // shorthand for an arbitrary Go type; it is not a real type\ntype Pointer *ArbitraryType\n\nfunc Alignof(variable ArbitraryType) uintptr\nfunc Offsetof(selector ArbitraryType) uintptr\nfunc Sizeof(variable ArbitraryType) uintptr\n\ntype IntegerType int  // shorthand for an integer type; it is not a real type\nfunc Add(ptr Pointer, len IntegerType) Pointer\nfunc Slice(ptr *ArbitraryType, len IntegerType) []ArbitraryType\nfunc SliceData(slice []ArbitraryType) *ArbitraryType\nfunc String(ptr *byte, len IntegerType) string\nfunc StringData(str string) *byte\n\nA `Pointer` is a [pointer type](https://go.dev/ref/spec#Pointer%5Ftypes) but a `Pointer`value may not be [dereferenced](https://go.dev/ref/spec#Address%5Foperators). Any pointer or value of [underlying type](https://go.dev/ref/spec#Types) `uintptr` can be[converted](https://go.dev/ref/spec#Conversions) to a type of underlying type `Pointer` and vice versa. The effect of converting between `Pointer` and `uintptr` is implementation-defined.\n\nvar f float64\nbits = *(*uint64)(unsafe.Pointer(&f))\n\ntype ptr unsafe.Pointer\nbits = *(*uint64)(ptr(&f))\n\nvar p ptr = nil\n\nThe functions `Alignof` and `Sizeof` take an expression `x`of any type and return the alignment or size, respectively, of a hypothetical variable `v`as if `v` was declared via `var v = x`.\n\nThe function `Offsetof` takes a (possibly parenthesized) [selector](https://go.dev/ref/spec#Selectors) `s.f`, denoting a field `f` of the struct denoted by `s`or `*s`, and returns the field offset in bytes relative to the struct's address. If `f` is an [embedded field](https://go.dev/ref/spec#Struct%5Ftypes), it must be reachable without pointer indirections through fields of the struct. For a struct `s` with field `f`:\n\nuintptr(unsafe.Pointer(&s)) + unsafe.Offsetof(s.f) == uintptr(unsafe.Pointer(&s.f))\n\nComputer architectures may require memory addresses to be _aligned_; that is, for addresses of a variable to be a multiple of a factor, the variable's type's _alignment_. The function `Alignof`takes an expression denoting a variable of any type and returns the alignment of the (type of the) variable in bytes. For a variable`x`:\n\nuintptr(unsafe.Pointer(&x)) % unsafe.Alignof(x) == 0\n\nA (variable of) type `T` has _variable size_ if `T`is a [type parameter](https://go.dev/ref/spec#Type%5Fparameter%5Fdeclarations), or if it is an array or struct type containing elements or fields of variable size. Otherwise the size is _constant_. Calls to `Alignof`, `Offsetof`, and `Sizeof`are compile-time [constant expressions](https://go.dev/ref/spec#Constant%5Fexpressions) of type `uintptr` if their arguments (or the struct `s` in the selector expression `s.f` for `Offsetof`) are types of constant size.\n\nThe function `Add` adds `len` to `ptr`and returns the updated pointer `unsafe.Pointer(uintptr(ptr) + uintptr(len))`. The `len` argument must be of [integer type](https://go.dev/ref/spec#Numeric%5Ftypes) or an untyped [constant](https://go.dev/ref/spec#Constants). A constant `len` argument must be [representable](https://go.dev/ref/spec#Representability) by a value of type `int`; if it is an untyped constant it is given type `int`. The rules for [valid uses](https://go.dev/pkg/unsafe#Pointer) of `Pointer` still apply.\n\nThe function `Slice` returns a slice whose underlying array starts at `ptr`and whose length and capacity are `len`.`Slice(ptr, len)` is equivalent to\n\n(*[len]ArbitraryType)(unsafe.Pointer(ptr))[:]\n\nexcept that, as a special case, if `ptr`is `nil` and `len` is zero,`Slice` returns `nil`.\n\nThe `len` argument must be of [integer type](https://go.dev/ref/spec#Numeric%5Ftypes) or an untyped [constant](https://go.dev/ref/spec#Constants). A constant `len` argument must be non-negative and [representable](https://go.dev/ref/spec#Representability) by a value of type `int`; if it is an untyped constant it is given type `int`. At run time, if `len` is negative, or if `ptr` is `nil` and `len` is not zero, a [run-time panic](https://go.dev/ref/spec#Run%5Ftime%5Fpanics) occurs.\n\nThe function `SliceData` returns a pointer to the underlying array of the `slice` argument. If the slice's capacity `cap(slice)` is not zero, that pointer is `&slice[:1][0]`. If `slice` is `nil`, the result is `nil`. Otherwise it is a non-`nil` pointer to an unspecified memory address.\n\nThe function `String` returns a `string` value whose underlying bytes start at`ptr` and whose length is `len`. The same requirements apply to the `ptr` and `len` argument as in the function`Slice`. If `len` is zero, the result is the empty string `\"\"`. Since Go strings are immutable, the bytes passed to `String` must not be modified afterwards.\n\nThe function `StringData` returns a pointer to the underlying bytes of the `str` argument. For an empty string the return value is unspecified, and may be `nil`. Since Go strings are immutable, the bytes returned by `StringData` must not be modified.\n\n### Size and alignment guarantees\n\nFor the [numeric types](https://go.dev/ref/spec#Numeric%5Ftypes), the following sizes are guaranteed:\n\ntype                                 size in bytes\n\nbyte, uint8, int8                     1\nuint16, int16                         2\nuint32, int32, float32                4\nuint64, int64, float64, complex64     8\ncomplex128                           16\n\nThe following minimal alignment properties are guaranteed:\n\n1. For a variable `x` of any type: `unsafe.Alignof(x)` is at least 1.\n2. For a variable `x` of struct type: `unsafe.Alignof(x)` is the largest of all the values `unsafe.Alignof(x.f)` for each field `f` of `x`, but at least 1.\n3. For a variable `x` of array type: `unsafe.Alignof(x)` is the same as the alignment of a variable of the array's element type.\n\nA struct or array type has size zero if it contains no fields (or elements, respectively) that have a size greater than zero. Two distinct zero-size variables may have the same address in memory."}