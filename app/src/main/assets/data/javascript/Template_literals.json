{"lang":"Javascript","fullPath":"/Template_literals","category":"","title":"Template_literals","url":"/en-US/docs/Web/JavaScript/Reference/Template_literals","markdown":"# Template literals (Template strings)\n\n**Template literals** are literals delimited with backtick (`` ` ``) characters, allowing for [multi-line strings](#multi-line%5Fstrings), [string interpolation](#string%5Finterpolation) with embedded expressions, and special constructs called [tagged templates](#tagged%5Ftemplates).\n\nTemplate literals are sometimes informally called _template strings_, because they are used most commonly for [string interpolation](#string%5Finterpolation) (to create strings by doing substitution of placeholders). However, a tagged template literal may not result in a string; it can be used with a custom [tag function](#tagged%5Ftemplates) to perform whatever operations you want on the different parts of the template literal.\n\n## [Syntax](#syntax)\n\n```\n`string text`\n\n`string text line 1\n string text line 2`\n\n`string text ${expression} string text`\n\ntagFunction`string text ${expression} string text`\n\n```\n\n### [Parameters](#parameters)\n\n`string text`\n\nThe string text that will become part of the template literal. Almost all characters are allowed literally, including [line breaks](/en-US/docs/Web/JavaScript/Reference/Lexical%5Fgrammar#line%5Fterminators) and other [whitespace characters](/en-US/docs/Web/JavaScript/Reference/Lexical%5Fgrammar#white%5Fspace). However, invalid escape sequences will cause a syntax error, unless a [tag function](#tagged%5Ftemplates%5Fand%5Fescape%5Fsequences) is used.\n\n`expression`\n\nAn expression to be inserted in the current position, whose value is converted to a string or passed to `tagFunction`.\n\n`tagFunction`\n\nIf specified, it will be called with the template strings array and substitution expressions, and the return value becomes the value of the template literal. See [tagged templates](#tagged%5Ftemplates).\n\n## [Description](#description)\n\nTemplate literals are enclosed by backtick (`` ` ``) characters instead of double or single quotes.\n\nAlong with having normal strings, template literals can also contain other parts called _placeholders_, which are embedded expressions delimited by a dollar sign and curly braces: `${expression}`. The strings and placeholders get passed to a function — either a default function, or a function you supply. The default function (when you don't supply your own) just performs [string interpolation](#string%5Finterpolation) to do substitution of the placeholders and then concatenate the parts into a single string.\n\nTo supply a function of your own, precede the template literal with a function name; the result is called a [**tagged template**](#tagged%5Ftemplates). In that case, the template literal is passed to your tag function, where you can then perform whatever operations you want on the different parts of the template literal.\n\nTo escape a backtick in a template literal, put a backslash (`\\`) before the backtick.\n\n```\n`\\`` === \"`\"; // true\n\n```\n\nDollar signs can be escaped as well to prevent interpolation.\n\n```\n`\\${1}` === \"${1}\"; // true\n\n```\n\n### [Multi-line strings](#multi-line%5Fstrings)\n\nAny newline characters inserted in the source are part of the template literal.\n\nUsing normal strings, you would have to use the following syntax in order to get multi-line strings:\n\n```\nconsole.log(\"string text line 1\\n\" + \"string text line 2\");\n// \"string text line 1\n// string text line 2\"\n\n```\n\nUsing template literals, you can do the same with this:\n\n```\nconsole.log(`string text line 1\nstring text line 2`);\n// \"string text line 1\n// string text line 2\"\n\n```\n\n### [String interpolation](#string%5Finterpolation)\n\nWithout template literals, when you want to combine output from expressions with strings, you'd [concatenate them](/en-US/docs/Learn/JavaScript/First%5Fsteps/Strings#concatenation%5Fusing) using the [addition operator](/en-US/docs/Web/JavaScript/Reference/Operators/Addition) `+`:\n\n```\nconst a = 5;\nconst b = 10;\nconsole.log(\"Fifteen is \" + (a + b) + \" and\\nnot \" + (2 * a + b) + \".\");\n// \"Fifteen is 15 and\n// not 20.\"\n\n```\n\nThat can be hard to read – especially when you have multiple expressions.\n\nWith template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form `${expression}` to perform substitutions for embedded expressions:\n\n```\nconst a = 5;\nconst b = 10;\nconsole.log(`Fifteen is ${a + b} and\nnot ${2 * a + b}.`);\n// \"Fifteen is 15 and\n// not 20.\"\n\n```\n\nNote that there's a mild difference between the two syntaxes. Template literals [coerce their expressions directly to strings](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String#string%5Fcoercion), while addition coerces its operands to primitives first. For more information, see the reference page for the [+ operator](/en-US/docs/Web/JavaScript/Reference/Operators/Addition).\n\n### [Nesting templates](#nesting%5Ftemplates)\n\nIn certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an `${expression}` placeholder within the template.\n\nFor example, without template literals, if you wanted to return a certain value based on a particular condition, you could do something like the following:\n\n```\nlet classes = \"header\";\nclasses += isLargeScreen()\n  ? \"\"\n  : item.isCollapsed\n  ? \" icon-expander\"\n  : \" icon-collapser\";\n\n```\n\nWith a template literal but without nesting, you could do this:\n\n```\nconst classes = `header ${\n  isLargeScreen() ? \"\" : item.isCollapsed ? \"icon-expander\" : \"icon-collapser\"\n}`;\n\n```\n\nWith nesting of template literals, you can do this:\n\n```\nconst classes = `header ${\n  isLargeScreen() ? \"\" : `icon-${item.isCollapsed ? \"expander\" : \"collapser\"}`\n}`;\n\n```\n\n### [Tagged templates](#tagged%5Ftemplates)\n\nA more advanced form of template literals are _tagged_ templates.\n\nTags allow you to parse template literals with a function. The first argument of a tag function contains an array of string values. The remaining arguments are related to the expressions.\n\nThe tag function can then perform whatever operations on these arguments you wish, and return the manipulated string. (Alternatively, it can return something completely different, as described in one of the following examples.)\n\nThe name of the function used for the tag can be whatever you want.\n\n```\nconst person = \"Mike\";\nconst age = 28;\n\nfunction myTag(strings, personExp, ageExp) {\n  const str0 = strings[0]; // \"That \"\n  const str1 = strings[1]; // \" is a \"\n  const str2 = strings[2]; // \".\"\n\n  const ageStr = ageExp > 99 ? \"centenarian\" : \"youngster\";\n\n  // We can even return a string built using a template literal\n  return `${str0}${personExp}${str1}${ageStr}${str2}`;\n}\n\nconst output = myTag`That ${person} is a ${age}.`;\n\nconsole.log(output);\n// That Mike is a youngster.\n\n```\n\nThe tag does not have to be a plain identifier. You can use any expression with [precedence](/en-US/docs/Web/JavaScript/Reference/Operators/Operator%5Fprecedence#table) greater than 16, which includes [property access](/en-US/docs/Web/JavaScript/Reference/Operators/Property%5Faccessors), function call, [new expression](/en-US/docs/Web/JavaScript/Reference/Operators/new), or even another tagged template literal.\n\n```\nconsole.log`Hello`; // [ 'Hello' ]\nconsole.log.bind(1, 2)`Hello`; // 2 [ 'Hello' ]\nnew Function(\"console.log(arguments)\")`Hello`; // [Arguments] { '0': [ 'Hello' ] }\n\nfunction recursive(strings, ...values) {\n  console.log(strings, values);\n  return recursive;\n}\nrecursive`Hello``World`;\n// [ 'Hello' ] []\n// [ 'World' ] []\n\n```\n\nWhile technically permitted by the syntax, _untagged_ template literals are strings and will throw a [TypeError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/TypeError) when chained.\n\n```\nconsole.log(`Hello``World`); // TypeError: \"Hello\" is not a function\n\n```\n\nThe only exception is optional chaining, which will throw a syntax error.\n\n```\nconsole.log?.`Hello`; // SyntaxError: Invalid tagged template on optional chain\nconsole?.log`Hello`; // SyntaxError: Invalid tagged template on optional chain\n\n```\n\nNote that these two expressions are still parsable. This means they would not be subject to [automatic semicolon insertion](/en-US/docs/Web/JavaScript/Reference/Lexical%5Fgrammar#automatic%5Fsemicolon%5Finsertion), which will only insert semicolons to fix code that's otherwise unparsable.\n\n```\n// Still a syntax error\nconst a = console?.log\n`Hello`\n\n```\n\nTag functions don't even need to return a string!\n\n```\nfunction template(strings, ...keys) {\n  return (...values) => {\n    const dict = values[values.length - 1] || {};\n    const result = [strings[0]];\n    keys.forEach((key, i) => {\n      const value = Number.isInteger(key) ? values[key] : dict[key];\n      result.push(value, strings[i + 1]);\n    });\n    return result.join(\"\");\n  };\n}\n\nconst t1Closure = template`${0}${1}${0}!`;\n// const t1Closure = template([\"\",\"\",\"\",\"!\"],0,1,0);\nt1Closure(\"Y\", \"A\"); // \"YAY!\"\n\nconst t2Closure = template`${0} ${\"foo\"}!`;\n// const t2Closure = template([\"\",\" \",\"!\"],0,\"foo\");\nt2Closure(\"Hello\", { foo: \"World\" }); // \"Hello World!\"\n\nconst t3Closure = template`I'm ${\"name\"}. I'm almost ${\"age\"} years old.`;\n// const t3Closure = template([\"I'm \", \". I'm almost \", \" years old.\"], \"name\", \"age\");\nt3Closure(\"foo\", { name: \"MDN\", age: 30 }); // \"I'm MDN. I'm almost 30 years old.\"\nt3Closure({ name: \"MDN\", age: 30 }); // \"I'm MDN. I'm almost 30 years old.\"\n\n```\n\nThe first argument received by the tag function is an array of strings. For any template literal, its length is equal to the number of substitutions (occurrences of `${…}`) plus one, and is therefore always non-empty.\n\nFor any particular tagged template literal expression, the tag function will always be called with the exact same literal array, no matter how many times the literal is evaluated.\n\n```\nconst callHistory = [];\n\nfunction tag(strings, ...values) {\n  callHistory.push(strings);\n  // Return a freshly made object\n  return {};\n}\n\nfunction evaluateLiteral() {\n  return tag`Hello, ${\"world\"}!`;\n}\n\nconsole.log(evaluateLiteral() === evaluateLiteral()); // false; each time `tag` is called, it returns a new object\nconsole.log(callHistory[0] === callHistory[1]); // true; all evaluations of the same tagged literal would pass in the same strings array\n\n```\n\nThis allows the tag to cache the result based on the identity of its first argument. To further ensure the array value's stability, the first argument and its [raw property](#raw%5Fstrings) are both [frozen](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/isFrozen), so you can't mutate them in any way.\n\n### [Raw strings](#raw%5Fstrings)\n\nThe special `raw` property, available on the first argument to the tag function, allows you to access the raw strings as they were entered, without processing [escape sequences](/en-US/docs/Web/JavaScript/Guide/Grammar%5Fand%5Ftypes#using%5Fspecial%5Fcharacters%5Fin%5Fstrings).\n\n```\nfunction tag(strings) {\n  console.log(strings.raw[0]);\n}\n\ntag`string text line 1 \\n string text line 2`;\n// Logs \"string text line 1 \\n string text line 2\" ,\n// including the two characters '\\' and 'n'\n\n```\n\nIn addition, the [String.raw()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String/raw) method exists to create raw strings just like the default template function and string concatenation would create.\n\n```\nconst str = String.raw`Hi\\n${2 + 3}!`;\n// \"Hi\\\\n5!\"\n\nstr.length;\n// 6\n\nArray.from(str).join(\",\");\n// \"H,i,\\\\,n,5,!\"\n\n```\n\n`String.raw` functions like an \"identity\" tag if the literal doesn't contain any escape sequences. In case you want an actual identity tag that always works as if the literal is untagged, you can make a custom function that passes the \"cooked\" (i.e. escape sequences are processed) literal array to `String.raw`, pretending they are raw strings.\n\n```\nconst identity = (strings, ...values) =>\n  String.raw({ raw: strings }, ...values);\nconsole.log(identity`Hi\\n${2 + 3}!`);\n// Hi\n// 5!\n\n```\n\nThis is useful for many tools which give special treatment to literals tagged by a particular name.\n\n```\nconst html = (strings, ...values) => String.raw({ raw: strings }, ...values);\n// Some formatters will format this literal's content as HTML\nconst doc = html`<!DOCTYPE html>\n  <html lang=\"en-US\">\n    <head>\n      <title>Hello</title>\n    </head>\n    <body>\n      <h1>Hello world!</h1>\n    </body>\n  </html>`;\n\n```\n\n### [Tagged templates and escape sequences](#tagged%5Ftemplates%5Fand%5Fescape%5Fsequences)\n\nIn normal template literals, [the escape sequences in string literals](/en-US/docs/Web/JavaScript/Reference/Lexical%5Fgrammar#escape%5Fsequences) are all allowed. Any other non-well-formed escape sequence is a syntax error. This includes:\n\n* `\\` followed by any decimal digit other than `0`, or `\\0` followed by a decimal digit; for example `\\9` and `\\07` (which is a [deprecated syntax](/en-US/docs/Web/JavaScript/Reference/Deprecated%5Fand%5Fobsolete%5Ffeatures#escape%5Fsequences))\n* `\\x` followed by fewer than two hex digits (including none); for example `\\xz`\n* `\\u` not followed by `{` and followed by fewer than four hex digits (including none); for example `\\uz`\n* `\\u{}` enclosing an invalid Unicode code point — it contains a non-hex digit, or its value is greater than `10FFFF`; for example `\\u{110000}` and `\\u{z}`\n\n**Note:** `\\` followed by other characters, while they may be useless since nothing is escaped, are not syntax errors.\n\nHowever, this is problematic for tagged templates, which, in addition to the \"cooked\" literal, also have access to the raw literals (escape sequences are preserved as-is).\n\nTagged templates should allow the embedding of languages (for example [DSLs](https://en.wikipedia.org/wiki/Domain-specific%5Flanguage), or [LaTeX](https://en.wikipedia.org/wiki/LaTeX)), where other escapes sequences are common. Therefore, the syntax restriction of well-formed escape sequences is removed from tagged templates.\n\n```\nlatex`\\unicode`;\n// Throws in older ECMAScript versions (ES2016 and earlier)\n// SyntaxError: malformed Unicode character escape sequence\n\n```\n\nHowever, illegal escape sequences must still be represented in the \"cooked\" representation. They will show up as [undefined](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/undefined) element in the \"cooked\" array:\n\n```\nfunction latex(str) {\n  return { cooked: str[0], raw: str.raw[0] };\n}\n\nlatex`\\unicode`;\n\n// { cooked: undefined, raw: \"\\\\unicode\" }\n\n```\n\nNote that the escape-sequence restriction is only dropped from _tagged_ templates, but not from _untagged_ template literals:\n\n```\nconst bad = `bad escape sequence: \\unicode`;\n\n```\n\n## [Specifications](#specifications)\n\n| Specification                                                                                                                                               |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [ECMAScript Language Specification  \\# sec-template-literals](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-template-literals) |\n\n## [Browser compatibility](#browser%5Fcompatibility)\n\nBCD tables only load in the browser\n\n## [See also](#see%5Falso)\n\n* [Text formatting](/en-US/docs/Web/JavaScript/Guide/Text%5Fformatting)\n* [String](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String)\n* [String.raw()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String/raw)\n* [Lexical grammar](/en-US/docs/Web/JavaScript/Reference/Lexical%5Fgrammar)\n* [ES6 in Depth: Template strings](https://hacks.mozilla.org/2015/05/es6-in-depth-template-strings-2/) on hacks.mozilla.org (May 14, 2015)\n\n### Found a content problem with this page?\n\n* [Edit the page on GitHub](https://github.com/mdn/content/edit/main/files/en-us/web/javascript/reference/template%5Fliterals/index.md \"This will take you to GitHub, where you'll need to sign in first.\").\n* [Report the content issue](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FTemplate%5Fliterals&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A%2A+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Ftemplate%5Fliterals%60%0A%2A+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FTemplate%5Fliterals%0A%2A+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Ftemplate%5Fliterals%2Findex.md%0A%2A+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Fcb8b34d86ff9326a72c421dcf4430b450e6c8d5d%0A%2A+Document+last+modified%3A+2023-05-16T14%3A55%3A46.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\").\n* [View the source on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/template%5Fliterals/index.md?plain=1 \"Folder: en-us/web/javascript/reference/template_literals (Opens in a new tab)\").\nWant to get more involved? [Learn how to contribute](https://github.com/mdn/content/blob/main/CONTRIBUTING.md \"This will take you to our contribution guidelines on GitHub.\").\n\nThis page was last modified on May 16, 2023 by [MDN contributors](/en-US/docs/Web/JavaScript/Reference/Template%5Fliterals/contributors.txt)."}