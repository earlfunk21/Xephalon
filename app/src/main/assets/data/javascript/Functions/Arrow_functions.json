{"lang":"Javascript","fullPath":"/Functions/Arrow_functions","category":"Functions","title":"Arrow_functions","url":"/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions","markdown":"# Arrow function expressions\n\nAn **arrow function expression** is a compact alternative to a traditional [function expression](/en-US/docs/Web/JavaScript/Reference/Operators/function), with some semantic differences and deliberate limitations in usage:\n\n* Arrow functions don't have their own bindings to [this](/en-US/docs/Web/JavaScript/Reference/Operators/this), [arguments](/en-US/docs/Web/JavaScript/Reference/Functions/arguments), or [super](/en-US/docs/Web/JavaScript/Reference/Operators/super), and should not be used as [methods](/en-US/docs/Glossary/Method).\n* Arrow functions cannot be used as [constructors](/en-US/docs/Glossary/Constructor). Calling them with [new](/en-US/docs/Web/JavaScript/Reference/Operators/new) throws a [TypeError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/TypeError). They also don't have access to the [new.target](/en-US/docs/Web/JavaScript/Reference/Operators/new.target) keyword.\n* Arrow functions cannot use [yield](/en-US/docs/Web/JavaScript/Reference/Operators/yield) within their body and cannot be created as generator functions.\n\n## [Try it](#try%5Fit)\n\n## [Syntax](#syntax)\n\n```\n() => expression\n\nparam => expression\n\n(param) => expression\n\n(param1, paramN) => expression\n\n() => {\n  statements\n}\n\nparam => {\n  statements\n}\n\n(param1, paramN) => {\n  statements\n}\n\n```\n\n[Rest parameters](/en-US/docs/Web/JavaScript/Reference/Functions/rest%5Fparameters), [default parameters](/en-US/docs/Web/JavaScript/Reference/Functions/Default%5Fparameters), and [destructuring](/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring%5Fassignment) within params are supported, and always require parentheses:\n\n```\n(a, b, ...r) => expression\n(a = 400, b = 20, c) => expression\n([a, b] = [10, 20]) => expression\n({ a, b } = { a: 10, b: 20 }) => expression\n\n```\n\nArrow functions can be [async](/en-US/docs/Web/JavaScript/Reference/Statements/async%5Ffunction) by prefixing the expression with the `async` keyword.\n\n```\nasync param => expression\nasync (param1, param2, ...paramN) => {\n  statements\n}\n\n```\n\n## [Description](#description)\n\nLet's decompose a traditional anonymous function down to the simplest arrow function step-by-step. Each step along the way is a valid arrow function.\n\n**Note:** Traditional function expressions and arrow functions have more differences than their syntax. We will introduce their behavior differences in more detail in the next few subsections.\n\n```\n// Traditional anonymous function\n(function (a) {\n  return a + 100;\n});\n\n// 1. Remove the word \"function\" and place arrow between the argument and opening body bracket\n(a) => {\n  return a + 100;\n};\n\n// 2. Remove the body braces and word \"return\" — the return is implied.\n(a) => a + 100;\n\n// 3. Remove the parameter parentheses\na => a + 100;\n\n```\n\nIn the example above, both the parentheses around the parameter and the braces around the function body may be omitted. However, they can only be omitted in certain cases.\n\nThe parentheses can only be omitted if the function has a single simple parameter. If it has multiple parameters, no parameters, or default, destructured, or rest parameters, the parentheses around the parameter list are required.\n\n```\n// Traditional anonymous function\n(function (a, b) {\n  return a + b + 100;\n});\n\n// Arrow function\n(a, b) => a + b + 100;\n\nconst a = 4;\nconst b = 2;\n\n// Traditional anonymous function (no parameters)\n(function () {\n  return a + b + 100;\n});\n\n// Arrow function (no parameters)\n() => a + b + 100;\n\n```\n\nThe braces can only be omitted if the function directly returns an expression. If the body has additional lines of processing, the braces are required — and so is the `return` keyword. Arrow functions cannot guess what or when you want to return.\n\n```\n// Traditional anonymous function\n(function (a, b) {\n  const chuck = 42;\n  return a + b + chuck;\n});\n\n// Arrow function\n(a, b) => {\n  const chuck = 42;\n  return a + b + chuck;\n};\n\n```\n\nArrow functions are always unnamed. If the arrow function needs to call itself, use a named function expression instead. You can also assign the arrow function to a variable so it has a name.\n\n```\n// Traditional Function\nfunction bob(a) {\n  return a + 100;\n}\n\n// Arrow Function\nconst bob2 = (a) => a + 100;\n\n```\n\n### [Function body](#function%5Fbody)\n\nArrow functions can have either a _concise body_ or the usual _block body_.\n\nIn a concise body, only a single expression is specified, which becomes the implicit return value. In a block body, you must use an explicit `return` statement.\n\n```\nconst func = (x) => x * x;\n// concise body syntax, implied \"return\"\n\nconst func2 = (x, y) => {\n  return x + y;\n};\n// with block body, explicit \"return\" needed\n\n```\n\nReturning object literals using the concise body syntax `(params) => { object: literal }` does not work as expected.\n\n```\nconst func = () => { foo: 1 };\n// Calling func() returns undefined!\n\nconst func2 = () => { foo: function () {} };\n// SyntaxError: function statement requires a name\n\nconst func3 = () => { foo() {} };\n// SyntaxError: Unexpected token '{'\n\n```\n\nThis is because JavaScript only sees the arrow function as having a concise body if the token following the arrow is not a left brace, so the code inside braces ({}) is parsed as a sequence of statements, where `foo` is a [label](/en-US/docs/Web/JavaScript/Reference/Statements/label), not a key in an object literal.\n\nTo fix this, wrap the object literal in parentheses:\n\n```\nconst func = () => ({ foo: 1 });\n\n```\n\n### [Cannot be used as methods](#cannot%5Fbe%5Fused%5Fas%5Fmethods)\n\nArrow function expressions should only be used for non-method functions because they do not have their own `this`. Let's see what happens when we try to use them as methods:\n\n```\n\"use strict\";\n\nconst obj = {\n  i: 10,\n  b: () => console.log(this.i, this),\n  c() {\n    console.log(this.i, this);\n  },\n};\n\nobj.b(); // logs undefined, Window { /* … */ } (or the global object)\nobj.c(); // logs 10, Object { /* … */ }\n\n```\n\nAnother example involving [Object.defineProperty()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/defineProperty):\n\n```\n\"use strict\";\n\nconst obj = {\n  a: 10,\n};\n\nObject.defineProperty(obj, \"b\", {\n  get: () => {\n    console.log(this.a, typeof this.a, this); // undefined 'undefined' Window { /* … */ } (or the global object)\n    return this.a + 10; // represents global object 'Window', therefore 'this.a' returns 'undefined'\n  },\n});\n\n```\n\nBecause a [class](/en-US/docs/Web/JavaScript/Reference/Classes)'s body has a `this` context, arrow functions as [class fields](/en-US/docs/Web/JavaScript/Reference/Classes/Public%5Fclass%5Ffields) close over the class's `this` context, and the `this` inside the arrow function's body will correctly point to the instance (or the class itself, for [static fields](/en-US/docs/Web/JavaScript/Reference/Classes/static)). However, because it is a [closure](/en-US/docs/Web/JavaScript/Closures), not the function's own binding, the value of `this` will not change based on the execution context.\n\n```\nclass C {\n  a = 1;\n  autoBoundMethod = () => {\n    console.log(this.a);\n  };\n}\n\nconst c = new C();\nc.autoBoundMethod(); // 1\nconst { autoBoundMethod } = c;\nautoBoundMethod(); // 1\n// If it were a normal method, it should be undefined in this case\n\n```\n\nArrow function properties are often said to be \"auto-bound methods\", because the equivalent with normal methods is:\n\n```\nclass C {\n  a = 1;\n  constructor() {\n    this.method = this.method.bind(this);\n  }\n  method() {\n    console.log(this.a);\n  }\n}\n\n```\n\n**Note:** Class fields are defined on the _instance_, not on the _prototype_, so every instance creation would create a new function reference and allocate a new closure, potentially leading to more memory usage than a normal unbound method.\n\nFor similar reasons, the [call()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Function/call), [apply()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Function/apply), and [bind()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Function/bind) methods are not useful when called on arrow functions, because arrow functions establish `this` based on the scope the arrow function is defined within, and the `this` value does not change based on how the function is invoked.\n\n### [No binding of arguments](#no%5Fbinding%5Fof%5Farguments)\n\nArrow functions do not have their own [arguments](/en-US/docs/Web/JavaScript/Reference/Functions/arguments) object. Thus, in this example, `arguments` is a reference to the arguments of the enclosing scope:\n\n```\nconst arguments = [1, 2, 3];\nconst arr = () => arguments[0];\n\narr(); // 1\n\nfunction foo(n) {\n  const f = () => arguments[0] + n; // foo's implicit arguments binding. arguments[0] is n\n  return f();\n}\n\nfoo(3); // 3 + 3 = 6\n\n```\n\n**Note:** You cannot declare a variable called `arguments` in [strict mode](/en-US/docs/Web/JavaScript/Reference/Strict%5Fmode#making%5Feval%5Fand%5Farguments%5Fsimpler), so the code above would be a syntax error. This makes the scoping effect of `arguments` much easier to comprehend.\n\n In most cases, using [rest parameters](/en-US/docs/Web/JavaScript/Reference/Functions/rest%5Fparameters) is a good alternative to using an `arguments` object.\n\n```\nfunction foo(n) {\n  const f = (...args) => args[0] + n;\n  return f(10);\n}\n\nfoo(1); // 11\n\n```\n\n### [Cannot be used as constructors](#cannot%5Fbe%5Fused%5Fas%5Fconstructors)\n\nArrow functions cannot be used as constructors and will throw an error when called with [new](/en-US/docs/Web/JavaScript/Reference/Operators/new). They also do not have a [prototype](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Function/prototype) property.\n\n```\nconst Foo = () => {};\nconst foo = new Foo(); // TypeError: Foo is not a constructor\nconsole.log(\"prototype\" in Foo); // false\n\n```\n\n### [Cannot be used as generators](#cannot%5Fbe%5Fused%5Fas%5Fgenerators)\n\nThe [yield](/en-US/docs/Web/JavaScript/Reference/Operators/yield) keyword cannot be used in an arrow function's body (except when used within generator functions further nested within the arrow function). As a consequence, arrow functions cannot be used as generators.\n\n### [Line break before arrow](#line%5Fbreak%5Fbefore%5Farrow)\n\nAn arrow function cannot contain a line break between its parameters and its arrow.\n\n```\nconst func = (a, b, c)\n  => 1;\n// SyntaxError: Unexpected token '=>'\n\n```\n\nFor the purpose of formatting, you may put the line break after the arrow or use parentheses/braces around the function body, as shown below. You can also put line breaks between parameters.\n\n```\nconst func = (a, b, c) =>\n  1;\n\nconst func2 = (a, b, c) => (\n  1\n);\n\nconst func3 = (a, b, c) => {\n  return 1;\n};\n\nconst func4 = (\n  a,\n  b,\n  c,\n) => 1;\n\n```\n\n### [Precedence of arrow](#precedence%5Fof%5Farrow)\n\nAlthough the arrow in an arrow function is not an operator, arrow functions have special parsing rules that interact differently with [operator precedence](/en-US/docs/Web/JavaScript/Reference/Operators/Operator%5Fprecedence) compared to regular functions.\n\n```\nlet callback;\n\ncallback = callback || () => {};\n// SyntaxError: invalid arrow-function arguments\n\n```\n\nBecause `=>` has a lower precedence than most operators, parentheses are necessary to avoid `callback || ()` being parsed as the arguments list of the arrow function.\n\n```\ncallback = callback || (() => {});\n\n```\n\n## [Examples](#examples)\n\n### [Using arrow functions](#using%5Farrow%5Ffunctions)\n\n```\n// An empty arrow function returns undefined\nconst empty = () => {};\n\n(() => \"foobar\")();\n// Returns \"foobar\"\n// (this is an Immediately Invoked Function Expression)\n\nconst simple = (a) => (a > 15 ? 15 : a);\nsimple(16); // 15\nsimple(10); // 10\n\nconst max = (a, b) => (a > b ? a : b);\n\n// Easy array filtering, mapping, etc.\nconst arr = [5, 6, 13, 0, 1, 18, 23];\n\nconst sum = arr.reduce((a, b) => a + b);\n// 66\n\nconst even = arr.filter((v) => v % 2 === 0);\n// [6, 0, 18]\n\nconst double = arr.map((v) => v * 2);\n// [10, 12, 26, 0, 2, 36, 46]\n\n// More concise promise chains\npromise\n  .then((a) => {\n    // …\n  })\n  .then((b) => {\n    // …\n  });\n\n// Parameterless arrow functions that are visually easier to parse\nsetTimeout(() => {\n  console.log(\"I happen sooner\");\n  setTimeout(() => {\n    // deeper code\n    console.log(\"I happen later\");\n  }, 1);\n}, 1);\n\n```\n\n### [Using call, bind, and apply](#using%5Fcall%5Fbind%5Fand%5Fapply)\n\nThe [call()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Function/call), [apply()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Function/apply), and [bind()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Function/bind) methods work as expected with traditional functions, because we establish the scope for each of the methods:\n\n```\nconst obj = {\n  num: 100,\n};\n\n// Setting \"num\" on globalThis to show how it is NOT used.\nglobalThis.num = 42;\n\n// A simple traditional function to operate on \"this\"\nconst add = function (a, b, c) {\n  return this.num + a + b + c;\n};\n\nconsole.log(add.call(obj, 1, 2, 3)); // 106\nconsole.log(add.apply(obj, [1, 2, 3])); // 106\nconst boundAdd = add.bind(obj);\nconsole.log(boundAdd(1, 2, 3)); // 106\n\n```\n\nWith arrow functions, since our `add` function is essentially created on the `globalThis` (global) scope, it will assume `this` is the `globalThis`.\n\n```\nconst obj = {\n  num: 100,\n};\n\n// Setting \"num\" on globalThis to show how it gets picked up.\nglobalThis.num = 42;\n\n// Arrow function\nconst add = (a, b, c) => this.num + a + b + c;\n\nconsole.log(add.call(obj, 1, 2, 3)); // 48\nconsole.log(add.apply(obj, [1, 2, 3])); // 48\nconst boundAdd = add.bind(obj);\nconsole.log(boundAdd(1, 2, 3)); // 48\n\n```\n\nPerhaps the greatest benefit of using arrow functions is with methods like [setTimeout()](/en-US/docs/Web/API/setTimeout) and [EventTarget.prototype.addEventListener()](/en-US/docs/Web/API/EventTarget/addEventListener \"EventTarget.prototype.addEventListener()\") that usually require some kind of closure, `call()`, `apply()`, or `bind()` to ensure that the function is executed in the proper scope.\n\nWith traditional function expressions, code like this does not work as expected:\n\n```\nconst obj = {\n  count: 10,\n  doSomethingLater() {\n    setTimeout(function () {\n      // the function executes on the window scope\n      this.count++;\n      console.log(this.count);\n    }, 300);\n  },\n};\n\nobj.doSomethingLater(); // logs \"NaN\", because the property \"count\" is not in the window scope.\n\n```\n\nWith arrow functions, the `this` scope is more easily preserved:\n\n```\nconst obj = {\n  count: 10,\n  doSomethingLater() {\n    // The method syntax binds \"this\" to the \"obj\" context.\n    setTimeout(() => {\n      // Since the arrow function doesn't have its own binding and\n      // setTimeout (as a function call) doesn't create a binding\n      // itself, the \"obj\" context of the outer method is used.\n      this.count++;\n      console.log(this.count);\n    }, 300);\n  },\n};\n\nobj.doSomethingLater(); // logs 11\n\n```\n\n## [Specifications](#specifications)\n\n| Specification                                                                                                                                                                           |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [ECMAScript Language Specification  \\# sec-arrow-function-definitions](https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-arrow-function-definitions) |\n\n## [Browser compatibility](#browser%5Fcompatibility)\n\nBCD tables only load in the browser\n\n## [See also](#see%5Falso)\n\n* [Functions guide](/en-US/docs/Web/JavaScript/Guide/Functions)\n* [Functions](/en-US/docs/Web/JavaScript/Reference/Functions)\n* [function](/en-US/docs/Web/JavaScript/Reference/Statements/function)\n* [function expression](/en-US/docs/Web/JavaScript/Reference/Operators/function)\n* [ES6 In Depth: Arrow functions](https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/) on hacks.mozilla.org (June 4, 2015)\n\n### Found a content problem with this page?\n\n* [Edit the page on GitHub](https://github.com/mdn/content/edit/main/files/en-us/web/javascript/reference/functions/arrow%5Ffunctions/index.md \"This will take you to GitHub, where you'll need to sign in first.\").\n* [Report the content issue](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FFunctions%2FArrow%5Ffunctions&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A%2A+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Ffunctions%2Farrow%5Ffunctions%60%0A%2A+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FFunctions%2FArrow%5Ffunctions%0A%2A+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Ffunctions%2Farrow%5Ffunctions%2Findex.md%0A%2A+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Fd85a7ba8cca98c2f6cf67a0c44f0ffd467532f20%0A%2A+Document+last+modified%3A+2023-04-05T04%3A57%3A48.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\").\n* [View the source on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/functions/arrow%5Ffunctions/index.md?plain=1 \"Folder: en-us/web/javascript/reference/functions/arrow_functions (Opens in a new tab)\").\nWant to get more involved? [Learn how to contribute](https://github.com/mdn/content/blob/main/CONTRIBUTING.md \"This will take you to our contribution guidelines on GitHub.\").\n\nThis page was last modified on Apr 5, 2023 by [MDN contributors](/en-US/docs/Web/JavaScript/Reference/Functions/Arrow%5Ffunctions/contributors.txt)."}