{"lang":"Javascript","fullPath":"/Operators/super","category":"Operators","title":"super","url":"/en-US/docs/Web/JavaScript/Reference/Operators/super","markdown":"# super\n\nThe **`super`** keyword is used to access properties on an object literal or class's \\[\\[Prototype\\]\\], or invoke a superclass's constructor.\n\nThe `super.prop` and `super[expr]` expressions are valid in any [method definition](/en-US/docs/Web/JavaScript/Reference/Functions/Method%5Fdefinitions) in both [classes](/en-US/docs/Web/JavaScript/Reference/Classes) and [object literals](/en-US/docs/Web/JavaScript/Reference/Operators/Object%5Finitializer). The `super(...args)` expression is valid in class constructors.\n\n## [Try it](#try%5Fit)\n\n## [Syntax](#syntax)\n\n```\nsuper([arguments]) // calls the parent constructor.\nsuper.propertyOnParent\nsuper[expression]\n\n```\n\n## [Description](#description)\n\nThe `super` keyword can be used in two ways: as a \"function call\" (`super(...args)`), or as a \"property lookup\" (`super.prop` and `super[expr]`).\n\n**Note:** `super` is a keyword and these are special syntactic constructs. `super` is not a variable that points to the prototype object. Attempting to read `super` itself is a [SyntaxError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/SyntaxError).\n\n```\nconst child = {\n  myParent() {\n    console.log(super); // SyntaxError: 'super' keyword unexpected here\n  },\n};\n\n```\n\nIn the [constructor](/en-US/docs/Web/JavaScript/Reference/Classes/constructor) body of a derived class (with `extends`), the `super` keyword may appear as a \"function call\" (`super(...args)`), which must be called before the `this` keyword is used, and before the constructor returns. It calls the parent class's constructor and binds the parent class's public fields, after which the derived class's constructor can further access and modify `this`.\n\nThe \"property lookup\" form can be used to access methods and properties of an object literal's or class's \\[\\[Prototype\\]\\]. Within a class's body, the reference of `super` can be either the superclass's constructor itself, or the constructor's `prototype`, depending on whether the execution context is instance creation or class initialization. See the Examples section for more details.\n\nNote that the reference of `super` is determined by the class or object literal `super` was declared in, not the object the method is called on. Therefore, unbinding or re-binding a method doesn't change the reference of `super` in it (although they do change the reference of [this](/en-US/docs/Web/JavaScript/Reference/Operators/this)). You can see `super` as a variable in the class or object literal scope, which the methods create a closure over. (But also beware that it's not actually a variable, as explained above.)\n\nWhen setting properties through `super`, the property is set on `this` instead.\n\n## [Examples](#examples)\n\n### [Using super in classes](#using%5Fsuper%5Fin%5Fclasses)\n\nThis code snippet is taken from the [classes sample](https://github.com/GoogleChrome/samples/blob/gh-pages/classes-es6/index.html) ([live demo](https://googlechrome.github.io/samples/classes-es6/index.html)). Here `super()` is called to avoid duplicating the constructor parts' that are common between `Rectangle` and `Square`.\n\n```\nclass Rectangle {\n  constructor(height, width) {\n    this.name = \"Rectangle\";\n    this.height = height;\n    this.width = width;\n  }\n  sayName() {\n    console.log(`Hi, I am a ${this.name}.`);\n  }\n  get area() {\n    return this.height * this.width;\n  }\n  set area(value) {\n    this._area = value;\n  }\n}\n\nclass Square extends Rectangle {\n  constructor(length) {\n    this.height; // ReferenceError, super needs to be called first!\n\n    // Here, it calls the parent class's constructor with lengths\n    // provided for the Rectangle's width and height\n    super(length, length);\n\n    // Note: In derived classes, super() must be called before you\n    // can use 'this'. Leaving this out will cause a reference error.\n    this.name = \"Square\";\n  }\n}\n\n```\n\n### [Super-calling static methods](#super-calling%5Fstatic%5Fmethods)\n\nYou are also able to call super on [static](/en-US/docs/Web/JavaScript/Reference/Classes/static) methods.\n\n```\nclass Rectangle {\n  static logNbSides() {\n    return \"I have 4 sides\";\n  }\n}\n\nclass Square extends Rectangle {\n  static logDescription() {\n    return `${super.logNbSides()} which are all equal`;\n  }\n}\nSquare.logDescription(); // 'I have 4 sides which are all equal'\n\n```\n\n### [Accessing super in class field declaration](#accessing%5Fsuper%5Fin%5Fclass%5Ffield%5Fdeclaration)\n\n`super` can also be accessed during class field initialization. The reference of `super` depends on whether the current field is an instance field or a static field.\n\n```\nclass Base {\n  static baseStaticField = 90;\n  baseMethod() {\n    return 10;\n  }\n}\n\nclass Extended extends Base {\n  extendedField = super.baseMethod(); // 10\n  static extendedStaticField = super.baseStaticField; // 90\n}\n\n```\n\nNote that instance fields are set on the instance instead of the constructor's `prototype`, so you can't use `super` to access the instance field of a superclass.\n\n```\nclass Base {\n  baseField = 10;\n}\n\nclass Extended extends Base {\n  extendedField = super.baseField; // undefined\n}\n\n```\n\nHere, `extendedField` is `undefined` instead of 10, because `baseField` is defined as an own property of the `Base` instance, instead of `Base.prototype`. `super`, in this context, only looks up properties on `Base.prototype`, because that's the \\[\\[Prototype\\]\\] of `Extended.prototype`.\n\n### [Deleting super properties will throw an error](#deleting%5Fsuper%5Fproperties%5Fwill%5Fthrow%5Fan%5Ferror)\n\nYou cannot use the [delete operator](/en-US/docs/Web/JavaScript/Reference/Operators/delete) and `super.prop` or `super[expr]` to delete a parent class' property â€” it will throw a [ReferenceError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/ReferenceError).\n\n```\nclass Base {\n  foo() {}\n}\nclass Derived extends Base {\n  delete() {\n    delete super.foo; // this is bad\n  }\n}\n\nnew Derived().delete(); // ReferenceError: invalid delete involving 'super'.\n\n```\n\n### [Using super.prop in object literals](#using%5Fsuper.prop%5Fin%5Fobject%5Fliterals)\n\nSuper can also be used in the [object initializer](/en-US/docs/Web/JavaScript/Reference/Operators/Object%5Finitializer) notation. In this example, two objects define a method. In the second object, `super` calls the first object's method. This works with the help of [Object.setPrototypeOf()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/setPrototypeOf) with which we are able to set the prototype of `obj2` to `obj1`, so that `super` is able to find `method1` on `obj1`.\n\n```\nconst obj1 = {\n  method1() {\n    console.log(\"method 1\");\n  },\n};\n\nconst obj2 = {\n  method2() {\n    super.method1();\n  },\n};\n\nObject.setPrototypeOf(obj2, obj1);\nobj2.method2(); // Logs \"method 1\"\n\n```\n\n### [Methods that read super.prop do not behave differently when bound to other objects](#methods%5Fthat%5Fread%5Fsuper.prop%5Fdo%5Fnot%5Fbehave%5Fdifferently%5Fwhen%5Fbound%5Fto%5Fother%5Fobjects)\n\nAccessing `super.x` behaves like `Reflect.get(Object.getPrototypeOf(objectLiteral), \"x\", this)`, which means the property is always seeked on the object literal/class declaration's prototype, and unbinding and re-binding a method won't change the reference of `super`.\n\n```\nclass Base {\n  baseGetX() {\n    return 1;\n  }\n}\nclass Extended extends Base {\n  getX() {\n    return super.baseGetX();\n  }\n}\n\nconst e = new Extended();\nconsole.log(e.getX()); // 1\nconst { getX } = e;\nconsole.log(getX()); // 1\n\n```\n\nThe same happens in object literals.\n\n```\nconst parent1 = { prop: 1 };\nconst parent2 = { prop: 2 };\n\nconst child = {\n  myParent() {\n    console.log(super.prop);\n  },\n};\n\nObject.setPrototypeOf(child, parent1);\nchild.myParent(); // Logs \"1\"\n\nconst myParent = child.myParent;\nmyParent(); // Still logs \"1\"\n\nconst anotherChild = { __proto__: parent2, myParent };\nanotherChild.myParent(); // Still logs \"1\"\n\n```\n\nOnly resetting the entire inheritance chain will change the reference of `super`.\n\n```\nclass Base {\n  baseGetX() {\n    return 1;\n  }\n  static staticBaseGetX() {\n    return 3;\n  }\n}\nclass AnotherBase {\n  baseGetX() {\n    return 2;\n  }\n  static staticBaseGetX() {\n    return 4;\n  }\n}\nclass Extended extends Base {\n  getX() {\n    return super.baseGetX();\n  }\n  static staticGetX() {\n    return super.staticBaseGetX();\n  }\n}\n\nconst e = new Extended();\n// Reset instance inheritance\nObject.setPrototypeOf(Extended.prototype, AnotherBase.prototype);\nconsole.log(e.getX()); // Logs \"2\" instead of \"1\", because the prototype chain has changed\nconsole.log(Extended.staticGetX()); // Still logs \"3\", because we haven't modified the static part yet\n// Reset static inheritance\nObject.setPrototypeOf(Extended, AnotherBase);\nconsole.log(Extended.staticGetX()); // Now logs \"4\"\n\n```\n\n### [Calling methods from super](#calling%5Fmethods%5Ffrom%5Fsuper)\n\nWhen calling `super.prop` as a function, the `this` value inside the `prop` function is the current `this`, not the object that `super` points to. For example, the `super.getName()` call logs `\"Extended\"`, despite the code looking like it's equivalent to `Base.getName()`.\n\n```\nclass Base {\n  static getName() {\n    console.log(this.name);\n  }\n}\n\nclass Extended extends Base {\n  static getName() {\n    super.getName();\n  }\n}\n\nExtended.getName(); // Logs \"Extended\"\n\n```\n\nThis is especially important when interacting with [static private properties](/en-US/docs/Web/JavaScript/Reference/Classes/Private%5Fclass%5Ffields#private%5Fstatic%5Ffields).\n\n### [Setting super.prop sets the property on this instead](#setting%5Fsuper.prop%5Fsets%5Fthe%5Fproperty%5Fon%5Fthis%5Finstead)\n\nSetting properties of `super`, such as `super.x = 1`, behaves like `Reflect.set(Object.getPrototypeOf(objectLiteral), \"x\", 1, this)`. This is one of the cases where understanding `super` as simply \"reference of the prototype object\" falls short, because it actually sets the property on `this` instead.\n\n```\nclass A {}\nclass B extends A {\n  setX() {\n    super.x = 1;\n  }\n}\n\nconst b = new B();\nb.setX();\nconsole.log(b); // B { x: 1 }\nconsole.log(Object.hasOwn(b, \"x\")); // true\n\n```\n\n`super.x = 1` will look for the property descriptor of `x` on `A.prototype` (and invoke the setters defined there), but the `this` value will be set to `this`, which is `b` in this context. You can read [Reflect.set](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Reflect/set) for more details on the case when `target` and `receiver` differ.\n\nThis means that while methods that _get_ `super.prop` are usually not susceptible to changes in the `this` context, those that _set_ `super.prop` are.\n\n```\n/* Reusing same declarations as above */\n\nconst b2 = new B();\nb2.setX.call(null); // TypeError: Cannot assign to read only property 'x' of object 'null'\n\n```\n\nHowever, `super.x = 1` still consults the property descriptor of the prototype object, which means you cannot rewrite non-writable properties, and setters will be invoked.\n\n```\nclass X {\n  constructor() {\n    // Create a non-writable property\n    Object.defineProperty(this, \"prop\", {\n      configurable: true,\n      writable: false,\n      value: 1,\n    });\n  }\n}\n\nclass Y extends X {\n  constructor() {\n    super();\n  }\n  foo() {\n    super.prop = 2; // Cannot overwrite the value.\n  }\n}\n\nconst y = new Y();\ny.foo(); // TypeError: \"prop\" is read-only\nconsole.log(y.prop); // 1\n\n```\n\n## [Specifications](#specifications)\n\n| Specification                                                                                                                                       |\n| --------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [ECMAScript Language Specification  \\# sec-super-keyword](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-super-keyword) |\n\n## [Browser compatibility](#browser%5Fcompatibility)\n\nBCD tables only load in the browser\n\n## [See also](#see%5Falso)\n\n* [Classes](/en-US/docs/Web/JavaScript/Reference/Classes)\n\n### Found a content problem with this page?\n\n* [Edit the page on GitHub](https://github.com/mdn/content/edit/main/files/en-us/web/javascript/reference/operators/super/index.md \"This will take you to GitHub, where you'll need to sign in first.\").\n* [Report the content issue](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fsuper&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A%2A+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Foperators%2Fsuper%60%0A%2A+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fsuper%0A%2A+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Foperators%2Fsuper%2Findex.md%0A%2A+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2F0f3738f6b1ed1aa69395ff181207186e1ad9f4d8%0A%2A+Document+last+modified%3A+2023-02-21T00%3A33%3A34.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\").\n* [View the source on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/operators/super/index.md?plain=1 \"Folder: en-us/web/javascript/reference/operators/super (Opens in a new tab)\").\nWant to get more involved? [Learn how to contribute](https://github.com/mdn/content/blob/main/CONTRIBUTING.md \"This will take you to our contribution guidelines on GitHub.\").\n\nThis page was last modified on Feb 21, 2023 by [MDN contributors](/en-US/docs/Web/JavaScript/Reference/Operators/super/contributors.txt)."}