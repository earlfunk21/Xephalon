{"lang":"Javascript","fullPath":"/Operators/Destructuring_assignment","category":"Operators","title":"Destructuring_assignment","url":"/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment","markdown":"# Destructuring assignment\n\nThe **destructuring assignment** syntax is a JavaScript expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variables.\n\n## [Try it](#try%5Fit)\n\n## [Syntax](#syntax)\n\n```\nconst [a, b] = array;\nconst [a, , b] = array;\nconst [a = aDefault, b] = array;\nconst [a, b, ...rest] = array;\nconst [a, , b, ...rest] = array;\nconst [a, b, ...{ pop, push }] = array;\nconst [a, b, ...[c, d]] = array;\n\nconst { a, b } = obj;\nconst { a: a1, b: b1 } = obj;\nconst { a: a1 = aDefault, b = bDefault } = obj;\nconst { a, b, ...rest } = obj;\nconst { a: a1, b: b1, ...rest } = obj;\nconst { [key]: a } = obj;\n\nlet a, b, a1, b1, c, d, rest, pop, push;\n[a, b] = array;\n[a, , b] = array;\n[a = aDefault, b] = array;\n[a, b, ...rest] = array;\n[a, , b, ...rest] = array;\n[a, b, ...{ pop, push }] = array;\n[a, b, ...[c, d]] = array;\n\n({ a, b } = obj); // brackets are required\n({ a: a1, b: b1 } = obj);\n({ a: a1 = aDefault, b = bDefault } = obj);\n({ a, b, ...rest } = obj);\n({ a: a1, b: b1, ...rest } = obj);\n\n```\n\n## [Description](#description)\n\nThe object and array literal expressions provide an easy way to create _ad hoc_ packages of data.\n\n```\nconst x = [1, 2, 3, 4, 5];\n\n```\n\nThe destructuring assignment uses similar syntax, but on the left-hand side of the assignment to define what values to unpack from the sourced variable.\n\n```\nconst x = [1, 2, 3, 4, 5];\nconst [y, z] = x;\nconsole.log(y); // 1\nconsole.log(z); // 2\n\n```\n\nSimilarly, you can destructure objects on the left-hand side of the assignment.\n\n```\nconst obj = { a: 1, b: 2 };\nconst { a, b } = obj;\n// is equivalent to:\n// const a = obj.a;\n// const b = obj.b;\n\n```\n\nThis capability is similar to features present in languages such as Perl and Python.\n\n### [Binding and assignment](#binding%5Fand%5Fassignment)\n\nFor both object and array destructuring, there are two kinds of destructuring patterns: _binding pattern_ and _assignment pattern_, with slightly different syntaxes.\n\nIn binding patterns, the pattern starts with a declaration keyword (`var`, `let`, or `const`). Then, each individual property must either be bound to a variable or further destructured.\n\n```\nconst obj = { a: 1, b: { c: 2 } };\nconst {\n  a,\n  b: { c: d },\n} = obj;\n// Two variables are bound: `a` and `d`\n\n```\n\nAll variables share the same declaration, so if you want some variables to be re-assignable but others to be read-only, you may have to destructure twice — once with `let`, once with `const`.\n\n```\nconst obj = { a: 1, b: { c: 2 } };\nconst { a } = obj; // a is constant\nlet {\n  b: { c: d },\n} = obj; // d is re-assignable\n\n```\n\nIn assignment patterns, the pattern does not start with a keyword. Each destructured property is assigned to a target of assignment — which may either be declared beforehand with `var` or `let`, or is a property of another object — in general, anything that can appear on the left-hand side of an assignment expression.\n\n```\nconst numbers = [];\nconst obj = { a: 1, b: 2 };\n({ a: numbers[0], b: numbers[1] } = obj);\n// The properties `a` and `b` are assigned to properties of `numbers`\n\n```\n\n**Note:** The parentheses `( ... )` around the assignment statement are required when using object literal destructuring assignment without a declaration.\n\n`{ a, b } = { a: 1, b: 2 }` is not valid stand-alone syntax, as the `{a, b}` on the left-hand side is considered a block and not an object literal. However, `({ a, b } = { a: 1, b: 2 })` is valid, as is `const { a, b } = { a: 1, b: 2 }`.\n\nIf your coding style does not include trailing semicolons, the `( ... )` expression needs to be preceded by a semicolon, or it may be used to execute a function on the previous line.\n\nNote that the equivalent _binding pattern_ of the code above is not valid syntax:\n\n```\nconst numbers = [];\nconst obj = { a: 1, b: 2 };\nconst { a: numbers[0], b: numbers[1] } = obj;\n\n// This is equivalent to:\n//   const numbers[0] = obj.a;\n//   const numbers[1] = obj.b;\n// Which definitely is not valid.\n\n```\n\n### [Default value](#default%5Fvalue)\n\nEach destructured property can have a _default value_. The default value is used when the property is not present, or has value `undefined`. It is not used if the property has value `null`.\n\n```\nconst [a = 1] = []; // a is 1\nconst { b = 2 } = { b: undefined }; // b is 2\nconst { c = 2 } = { c: null }; // c is null\n\n```\n\nThe default value can be any expression. It will only be evaluated when necessary.\n\n```\nconst { b = console.log(\"hey\") } = { b: 2 };\n// Does not log anything, because `b` is defined and there's no need\n// to evaluate the default value.\n\n```\n\n### [Rest property](#rest%5Fproperty)\n\nYou can end a destructuring pattern with a rest property `...rest`. This pattern will store all remaining properties of the object or array into a new object or array.\n\n```\nconst { a, ...others } = { a: 1, b: 2, c: 3 };\nconsole.log(others); // { b: 2, c: 3 }\n\nconst [first, ...others2] = [1, 2, 3];\nconsole.log(others2); // [2, 3]\n\n```\n\nThe rest property must be the last in the pattern, and must not have a trailing comma.\n\n```\nconst [a, ...b,] = [1, 2, 3];\n\n// SyntaxError: rest element may not have a trailing comma\n// Always consider using rest operator as the last element\n\n```\n\n### [Destructuring patterns with other syntaxes](#destructuring%5Fpatterns%5Fwith%5Fother%5Fsyntaxes)\n\nIn many syntaxes where the language binds a variable for you, you can use a destructuring pattern as well. These include:\n\n* The looping variable of [for...in](/en-US/docs/Web/JavaScript/Reference/Statements/for...in) and [for...of](/en-US/docs/Web/JavaScript/Reference/Statements/for...of) loops;\n* [Function](/en-US/docs/Web/JavaScript/Reference/Functions) parameters;\n* The [catch](/en-US/docs/Web/JavaScript/Reference/Statements/try...catch) binding variable.\n\nFor features specific to array or object destructuring, please refer to the individual examples below.\n\n## [Examples](#examples)\n\n### [Array destructuring](#array%5Fdestructuring)\n\n#### Basic variable assignment\n\n```\nconst foo = [\"one\", \"two\", \"three\"];\n\nconst [red, yellow, green] = foo;\nconsole.log(red); // \"one\"\nconsole.log(yellow); // \"two\"\nconsole.log(green); // \"three\"\n\n```\n\n#### Destructuring with more elements than the source\n\nIn an array destructuring from an array of length _N_ specified on the right-hand side of the assignment, if the number of variables specified on the left-hand side of the assignment is greater than _N_, only the first _N_ variables are assigned values. The values of the remaining variables will be undefined.\n\n```\nconst foo = [\"one\", \"two\"];\n\nconst [red, yellow, green, blue] = foo;\nconsole.log(red); // \"one\"\nconsole.log(yellow); // \"two\"\nconsole.log(green); // undefined\nconsole.log(blue); // undefined\n\n```\n\n#### Swapping variables\n\nTwo variables values can be swapped in one destructuring expression.\n\nWithout destructuring assignment, swapping two values requires a temporary variable (or, in some low-level languages, the [XOR-swap trick](https://en.wikipedia.org/wiki/XOR%5Fswap%5Falgorithm)).\n\n```\nlet a = 1;\nlet b = 3;\n\n[a, b] = [b, a];\nconsole.log(a); // 3\nconsole.log(b); // 1\n\nconst arr = [1, 2, 3];\n[arr[2], arr[1]] = [arr[1], arr[2]];\nconsole.log(arr); // [1, 3, 2]\n\n```\n\n#### Parsing an array returned from a function\n\nIt's always been possible to return an array from a function. Destructuring can make working with an array return value more concise.\n\nIn this example, `f()` returns the values `[1, 2]` as its output, which can be parsed in a single line with destructuring.\n\n```\nfunction f() {\n  return [1, 2];\n}\n\nconst [a, b] = f();\nconsole.log(a); // 1\nconsole.log(b); // 2\n\n```\n\n#### Ignoring some returned values\n\nYou can ignore return values that you're not interested in:\n\n```\nfunction f() {\n  return [1, 2, 3];\n}\n\nconst [a, , b] = f();\nconsole.log(a); // 1\nconsole.log(b); // 3\n\nconst [c] = f();\nconsole.log(c); // 1\n\n```\n\nYou can also ignore all returned values:\n\n```\n[, ,] = f();\n\n```\n\n#### Using a binding pattern as the rest property\n\nThe rest property of array destructuring assignment can be another array or object binding pattern. The inner destructuring destructures from the array created after collecting the rest elements, so you cannot access any properties present on the original iterable in this way.\n\n```\nconst [a, b, ...{ length }] = [1, 2, 3];\nconsole.log(a, b, length); // 1 2 1\n\n```\n\n```\nconst [a, b, ...[c, d]] = [1, 2, 3, 4];\nconsole.log(a, b, c, d); // 1 2 3 4\n\n```\n\nThese binding patterns can even be nested, as long as each rest property is the last in the list.\n\n```\nconst [a, b, ...[c, d, ...[e, f]]] = [1, 2, 3, 4, 5, 6];\nconsole.log(a, b, c, d, e, f); // 1 2 3 4 5 6\n\n```\n\nOn the other hand, object destructuring can only have an identifier as the rest property.\n\n```\nconst { a, ...{ b } } = { a: 1, b: 2 };\n// SyntaxError: `...` must be followed by an identifier in declaration contexts\n\nlet a, b;\n({ a, ...{ b } } = { a: 1, b: 2 });\n// SyntaxError: `...` must be followed by an assignable reference in assignment contexts\n\n```\n\n#### Unpacking values from a regular expression match\n\nWhen the regular expression [exec()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/RegExp/exec) method finds a match, it returns an array containing first the entire matched portion of the string and then the portions of the string that matched each parenthesized group in the regular expression. Destructuring assignment allows you to unpack the parts out of this array easily, ignoring the full match if it is not needed.\n\n```\nfunction parseProtocol(url) {\n  const parsedURL = /^(\\w+):\\/\\/([^/]+)\\/(.*)$/.exec(url);\n  if (!parsedURL) {\n    return false;\n  }\n  console.log(parsedURL);\n  // [\"https://developer.mozilla.org/en-US/docs/Web/JavaScript\",\n  // \"https\", \"developer.mozilla.org\", \"en-US/docs/Web/JavaScript\"]\n\n  const [, protocol, fullhost, fullpath] = parsedURL;\n  return protocol;\n}\n\nconsole.log(\n  parseProtocol(\"https://developer.mozilla.org/en-US/docs/Web/JavaScript\"),\n);\n// \"https\"\n\n```\n\n#### Using array destructuring on any iterable\n\nArray destructuring calls the [iterable protocol](/en-US/docs/Web/JavaScript/Reference/Iteration%5Fprotocols) of the right-hand side. Therefore, any iterable, not necessarily arrays, can be destructured.\n\n```\nconst [a, b] = new Map([\n  [1, 2],\n  [3, 4],\n]);\nconsole.log(a, b); // [1, 2] [3, 4]\n\n```\n\nNon-iterables cannot be destructured as arrays.\n\n```\nconst obj = { 0: \"a\", 1: \"b\", length: 2 };\nconst [a, b] = obj;\n// TypeError: obj is not iterable\n\n```\n\nIterables are only iterated until all bindings are assigned.\n\n```\nconst obj = {\n  *[Symbol.iterator]() {\n    for (const v of [0, 1, 2, 3]) {\n      console.log(v);\n      yield v;\n    }\n  },\n};\nconst [a, b] = obj; // Only logs 0 and 1\n\n```\n\nThe rest binding is eagerly evaluated and creates a new array, instead of using the old iterable.\n\n```\nconst obj = {\n  *[Symbol.iterator]() {\n    for (const v of [0, 1, 2, 3]) {\n      console.log(v);\n      yield v;\n    }\n  },\n};\nconst [a, b, ...rest] = obj; // Logs 0 1 2 3\nconsole.log(rest); // [2, 3] (an array)\n\n```\n\n### [Object destructuring](#object%5Fdestructuring)\n\n#### Basic assignment\n\n```\nconst user = {\n  id: 42,\n  isVerified: true,\n};\n\nconst { id, isVerified } = user;\n\nconsole.log(id); // 42\nconsole.log(isVerified); // true\n\n```\n\n#### Assigning to new variable names\n\nA property can be unpacked from an object and assigned to a variable with a different name than the object property.\n\n```\nconst o = { p: 42, q: true };\nconst { p: foo, q: bar } = o;\n\nconsole.log(foo); // 42\nconsole.log(bar); // true\n\n```\n\nHere, for example, `const { p: foo } = o` takes from the object `o` the property named `p` and assigns it to a local variable named `foo`.\n\n#### Assigning to new variable names and providing default values\n\nA property can be both\n\n* Unpacked from an object and assigned to a variable with a different name.\n* Assigned a default value in case the unpacked value is `undefined`.\n\n```\nconst { a: aa = 10, b: bb = 5 } = { a: 3 };\n\nconsole.log(aa); // 3\nconsole.log(bb); // 5\n\n```\n\n#### Unpacking properties from objects passed as a function parameter\n\n Objects passed into function parameters can also be unpacked into variables, which may then be accessed within the function body. As for object assignment, the destructuring syntax allows for the new variable to have the same name or a different name than the original property, and to assign default values for the case when the original object does not define the property.\n\nConsider this object, which contains information about a user.\n\n```\nconst user = {\n  id: 42,\n  displayName: \"jdoe\",\n  fullName: {\n    firstName: \"Jane\",\n    lastName: \"Doe\",\n  },\n};\n\n```\n\n Here we show how to unpack a property of the passed object into a variable with the same name. The parameter value `{ id }` indicates that the `id` property of the object passed to the function should be unpacked into a variable with the same name, which can then be used within the function.\n\n```\nfunction userId({ id }) {\n  return id;\n}\n\nconsole.log(userId(user)); // 42\n\n```\n\n You can define the name of the unpacked variable. Here we unpack the property named `displayName`, and rename it to `dname` for use within the function body.\n\n```\nfunction userDisplayName({ displayName: dname }) {\n  return dname;\n}\n\nconsole.log(userDisplayName(user)); // \"jdoe\"\n\n```\n\n Nested objects can also be unpacked. The example below shows the property `fullname.firstName` being unpacked into a variable called `name`.\n\n```\nfunction whois({ displayName, fullName: { firstName: name } }) {\n  return `${displayName} is ${name}`;\n}\n\nconsole.log(whois(user)); // \"jdoe is Jane\"\n\n```\n\n#### Setting a function parameter's default value\n\nDefault values can be specified using `=`, and will be used as variable values if a specified property does not exist in the passed object.\n\nBelow we show a function where the default size is `'big'`, default co-ordinates are `x: 0, y: 0` and default radius is 25.\n\n```\nfunction drawChart({\n  size = \"big\",\n  coords = { x: 0, y: 0 },\n  radius = 25,\n} = {}) {\n  console.log(size, coords, radius);\n  // do some chart drawing\n}\n\ndrawChart({\n  coords: { x: 18, y: 30 },\n  radius: 30,\n});\n\n```\n\nIn the function signature for `drawChart` above, the destructured left-hand side has a default value of an empty object `= {}`.\n\nYou could have also written the function without that default. However, if you leave out that default value, the function will look for at least one argument to be supplied when invoked, whereas in its current form, you can call `drawChart()` without supplying any parameters. Otherwise, you need to at least supply an empty object literal.\n\nFor more information, see [Default parameters > Destructured parameter with default value assignment](/en-US/docs/Web/JavaScript/Reference/Functions/Default%5Fparameters#destructured%5Fparameter%5Fwith%5Fdefault%5Fvalue%5Fassignment).\n\n#### Nested object and array destructuring\n\n```\nconst metadata = {\n  title: \"Scratchpad\",\n  translations: [\n    {\n      locale: \"de\",\n      localizationTags: [],\n      lastEdit: \"2014-04-14T08:43:37\",\n      url: \"/de/docs/Tools/Scratchpad\",\n      title: \"JavaScript-Umgebung\",\n    },\n  ],\n  url: \"/en-US/docs/Tools/Scratchpad\",\n};\n\nconst {\n  title: englishTitle, // rename\n  translations: [\n    {\n      title: localeTitle, // rename\n    },\n  ],\n} = metadata;\n\nconsole.log(englishTitle); // \"Scratchpad\"\nconsole.log(localeTitle); // \"JavaScript-Umgebung\"\n\n```\n\n#### For of iteration and destructuring\n\n```\nconst people = [\n  {\n    name: \"Mike Smith\",\n    family: {\n      mother: \"Jane Smith\",\n      father: \"Harry Smith\",\n      sister: \"Samantha Smith\",\n    },\n    age: 35,\n  },\n  {\n    name: \"Tom Jones\",\n    family: {\n      mother: \"Norah Jones\",\n      father: \"Richard Jones\",\n      brother: \"Howard Jones\",\n    },\n    age: 25,\n  },\n];\n\nfor (const {\n  name: n,\n  family: { father: f },\n} of people) {\n  console.log(`Name: ${n}, Father: ${f}`);\n}\n\n// \"Name: Mike Smith, Father: Harry Smith\"\n// \"Name: Tom Jones, Father: Richard Jones\"\n\n```\n\n#### Computed object property names and destructuring\n\nComputed property names, like on [object literals](/en-US/docs/Web/JavaScript/Reference/Operators/Object%5Finitializer#computed%5Fproperty%5Fnames), can be used with destructuring.\n\n```\nconst key = \"z\";\nconst { [key]: foo } = { z: \"bar\" };\n\nconsole.log(foo); // \"bar\"\n\n```\n\n#### Invalid JavaScript identifier as a property name\n\nDestructuring can be used with property names that are not valid JavaScript [identifiers](/en-US/docs/Glossary/Identifier) by providing an alternative identifier that is valid.\n\n```\nconst foo = { \"fizz-buzz\": true };\nconst { \"fizz-buzz\": fizzBuzz } = foo;\n\nconsole.log(fizzBuzz); // true\n\n```\n\n### [Destructuring primitive values](#destructuring%5Fprimitive%5Fvalues)\n\nObject destructuring is almost equivalent to [property accessing](/en-US/docs/Web/JavaScript/Reference/Operators/Property%5Faccessors). This means if you try to destruct a primitive value, the value will get wrapped into the corresponding wrapper object and the property is accessed on the wrapper object.\n\n```\nconst { a, toFixed } = 1;\nconsole.log(a, toFixed); // undefined ƒ toFixed() { [native code] }\n\n```\n\nSame as accessing properties, destructuring `null` or `undefined` throws a [TypeError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/TypeError).\n\n```\nconst { a } = undefined; // TypeError: Cannot destructure property 'a' of 'undefined' as it is undefined.\nconst { b } = null; // TypeError: Cannot destructure property 'b' of 'null' as it is null.\n\n```\n\nThis happens even when the pattern is empty.\n\n```\nconst {} = null; // TypeError: Cannot destructure 'null' as it is null.\n\n```\n\n#### Combined array and object destructuring\n\nArray and object destructuring can be combined. Say you want the third element in the array `props` below, and then you want the `name` property in the object, you can do the following:\n\n```\nconst props = [\n  { id: 1, name: \"Fizz\" },\n  { id: 2, name: \"Buzz\" },\n  { id: 3, name: \"FizzBuzz\" },\n];\n\nconst [, , { name }] = props;\n\nconsole.log(name); // \"FizzBuzz\"\n\n```\n\n#### The prototype chain is looked up when the object is deconstructed\n\nWhen deconstructing an object, if a property is not accessed in itself, it will continue to look up along the prototype chain.\n\n```\nconst obj = {\n  self: \"123\",\n  __proto__: {\n    prot: \"456\",\n  },\n};\nconst { self, prot } = obj;\n\nconsole.log(self); // \"123\"\nconsole.log(prot); // \"456\"\n\n```\n\n## [Specifications](#specifications)\n\n| Specification                                                                                                                                                                                         |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [ECMAScript Language Specification  \\# sec-destructuring-assignment](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-destructuring-assignment)                             |\n| [ECMAScript Language Specification  \\# sec-destructuring-binding-patterns](https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-destructuring-binding-patterns) |\n\n## [Browser compatibility](#browser%5Fcompatibility)\n\nBCD tables only load in the browser\n\n## [See also](#see%5Falso)\n\n* [Assignment operators](/en-US/docs/Web/JavaScript/Reference/Operators#assignment%5Foperators)\n* [\"ES6 in Depth: Destructuring\" on hacks.mozilla.org](https://hacks.mozilla.org/2015/05/es6-in-depth-destructuring/)\n\n### Found a content problem with this page?\n\n* [Edit the page on GitHub](https://github.com/mdn/content/edit/main/files/en-us/web/javascript/reference/operators/destructuring%5Fassignment/index.md \"This will take you to GitHub, where you'll need to sign in first.\").\n* [Report the content issue](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FDestructuring%5Fassignment&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A%2A+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Foperators%2Fdestructuring%5Fassignment%60%0A%2A+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FDestructuring%5Fassignment%0A%2A+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Foperators%2Fdestructuring%5Fassignment%2Findex.md%0A%2A+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2F359272f811718db9d74ffe9de3806353b9e36827%0A%2A+Document+last+modified%3A+2023-04-18T00%3A49%3A40.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\").\n* [View the source on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/operators/destructuring%5Fassignment/index.md?plain=1 \"Folder: en-us/web/javascript/reference/operators/destructuring_assignment (Opens in a new tab)\").\nWant to get more involved? [Learn how to contribute](https://github.com/mdn/content/blob/main/CONTRIBUTING.md \"This will take you to our contribution guidelines on GitHub.\").\n\nThis page was last modified on Apr 18, 2023 by [MDN contributors](/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring%5Fassignment/contributors.txt)."}