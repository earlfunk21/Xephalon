{"lang":"Javascript","fullPath":"/Operators/Optional_chaining","category":"Operators","title":"Optional_chaining","url":"/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining","markdown":"# Optional chaining (?.)\n\nThe **optional chaining (`?.`)** operator accesses an object's property or calls a function. If the object accessed or function called using this operator is [undefined](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/undefined) or [null](/en-US/docs/Web/JavaScript/Reference/Operators/null), the expression short circuits and evaluates to [undefined](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/undefined) instead of throwing an error.\n\n## [Try it](#try%5Fit)\n\n## [Syntax](#syntax)\n\n```\nobj.val?.prop\nobj.val?.[expr]\nobj.func?.(args)\n\n```\n\n## [Description](#description)\n\nThe `?.` operator is like the `.` chaining operator, except that instead of causing an error if a reference is [nullish](/en-US/docs/Glossary/Nullish) ([null](/en-US/docs/Web/JavaScript/Reference/Operators/null) or [undefined](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/undefined)), the expression short-circuits with a return value of `undefined`. When used with function calls, it returns `undefined` if the given function does not exist.\n\nThis results in shorter and simpler expressions when accessing chained properties when the possibility exists that a reference may be missing. It can also be helpful while exploring the content of an object when there's no known guarantee as to which properties are required.\n\n For example, consider an object `obj` which has a nested structure. Without optional chaining, looking up a deeply-nested subproperty requires validating the references in between, such as:\n\n```\nconst nestedProp = obj.first && obj.first.second;\n\n```\n\n The value of `obj.first` is confirmed to be non-`null` (and non-`undefined`) before then accessing the value of`obj.first.second`. This prevents the error that would occur if you accessed`obj.first.second` directly without testing `obj.first`.\n\nThis is an idiomatic pattern in JavaScript, but it gets verbose when the chain is long, and it's not safe. For example, if `obj.first` is a [Falsy](/en-US/docs/Glossary/Falsy) value that's not `null` or `undefined`, such as `0`, it would still short-circuit and make `nestedProp` become `0`, which may not be desirable.\n\n With the optional chaining operator (`?.`), however, you don't have to explicitly test and short-circuit based on the state of `obj.first` before trying to access `obj.first.second`:\n\n```\nconst nestedProp = obj.first?.second;\n\n```\n\n By using the `?.` operator instead of just `.`, JavaScript knows to implicitly check to be sure `obj.first` is not `null` or`undefined` before attempting to access `obj.first.second`. If`obj.first` is `null` or `undefined`, the expression automatically short-circuits, returning `undefined`.\n\n This is equivalent to the following, except that the temporary variable is in fact not created:\n\n```\nconst temp = obj.first;\nconst nestedProp =\n  temp === null || temp === undefined ? undefined : temp.second;\n\n```\n\nOptional chaining cannot be used on a non-declared root object, but can be used with a root object with value `undefined`.\n\n```\nundeclaredVar?.prop; // ReferenceError: undeclaredVar is not defined\n\n```\n\n### [Optional chaining with function calls](#optional%5Fchaining%5Fwith%5Ffunction%5Fcalls)\n\n You can use optional chaining when attempting to call a method which may not exist. This can be helpful, for example, when using an API in which a method might be unavailable, either due to the age of the implementation or because of a feature which isn't available on the user's device.\n\n Using optional chaining with function calls causes the expression to automatically return `undefined` instead of throwing an exception if the method isn't found:\n\n```\nconst result = someInterface.customMethod?.();\n\n```\n\nHowever, if there is a property with such a name which is not a function, using `?.` will still raise a [TypeError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/TypeError) exception \"someInterface.customMethod is not a function\".\n\n**Note:** If `someInterface` itself is `null` or`undefined`, a [TypeError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/TypeError) exception will still be raised (\"someInterface is null\"). If you expect that`someInterface` itself may be `null` or `undefined`, you have to use `?.` at this position as well: `someInterface?.customMethod?.()`.\n\n`eval?.()` is the shortest way to enter [_indirect eval_](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/eval#direct%5Fand%5Findirect%5Feval) mode.\n\n### [Optional chaining with expressions](#optional%5Fchaining%5Fwith%5Fexpressions)\n\nYou can also use the optional chaining operator with [bracket notation](/en-US/docs/Web/JavaScript/Reference/Operators/Property%5Faccessors#bracket%5Fnotation), which allows passing an expression as the property name:\n\n```\nconst nestedProp = obj?.[\"prop\" + \"Name\"];\n\n```\n\nThis is particularly useful for arrays, since array indices must be accessed with brackets.\n\n```\nfunction printMagicIndex(arr) {\n  console.log(arr?.[42]);\n}\n\nprintMagicIndex([0, 1, 2, 3, 4, 5]); // undefined\nprintMagicIndex(); // undefined; if not using ?., this would throw\n\n```\n\n### [Optional chaining not valid on the left-hand side of an assignment](#optional%5Fchaining%5Fnot%5Fvalid%5Fon%5Fthe%5Fleft-hand%5Fside%5Fof%5Fan%5Fassignment)\n\nIt is invalid to try to assign to the result of an optional chaining expression:\n\n```\nconst object = {};\nobject?.property = 1; // SyntaxError: Invalid left-hand side in assignment\n\n```\n\n### [Short-circuiting](#short-circuiting)\n\nWhen using optional chaining with expressions, if the left operand is `null` or `undefined`, the expression will not be evaluated. For instance:\n\n```\nconst potentiallyNullObj = null;\nlet x = 0;\nconst prop = potentiallyNullObj?.[x++];\n\nconsole.log(x); // 0 as x was not incremented\n\n```\n\nSubsequent property accesses will not be evaluated either.\n\n```\nconst potentiallyNullObj = null;\nconst prop = potentiallyNullObj?.a.b;\n// This does not throw, because evaluation has already stopped at\n// the first optional chain\n\n```\n\nThis is equivalent to:\n\n```\nconst potentiallyNullObj = null;\nconst prop =\n  potentiallyNullObj === null || potentiallyNullObj === undefined\n    ? undefined\n    : potentiallyNullObj.a.b;\n\n```\n\nHowever, this short-circuiting behavior only happens along one continuous \"chain\" of property accesses. If you [group](/en-US/docs/Web/JavaScript/Reference/Operators/Grouping) one part of the chain, then subsequent property accesses will still be evaluated.\n\n```\nconst potentiallyNullObj = null;\nconst prop = (potentiallyNullObj?.a).b;\n// TypeError: Cannot read properties of undefined (reading 'b')\n\n```\n\nThis is equivalent to:\n\n```\nconst potentiallyNullObj = null;\nconst temp = potentiallyNullObj?.a;\nconst prop = temp.b;\n\n```\n\nExcept the `temp` variable isn't created.\n\n## [Examples](#examples)\n\n### [Basic example](#basic%5Fexample)\n\n This example looks for the value of the `name` property for the member`bar` in a map when there is no such member. The result is therefore`undefined`.\n\n```\nconst myMap = new Map();\nmyMap.set(\"foo\", { name: \"baz\", desc: \"inga\" });\n\nconst nameBar = myMap.get(\"bar\")?.name;\n\n```\n\n### [Dealing with optional callbacks or event handlers](#dealing%5Fwith%5Foptional%5Fcallbacks%5For%5Fevent%5Fhandlers)\n\n If you use callbacks or fetch methods from an object with[a destructuring assignment](/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring%5Fassignment#object%5Fdestructuring), you may have non-existent values that you cannot call as functions unless you have tested their existence. Using `?.`, you can avoid this extra test:\n\n```\n// Code written without optional chaining\nfunction doSomething(onContent, onError) {\n  try {\n    // Do something with the data\n  } catch (err) {\n    // Testing if onError really exists\n    if (onError) {\n      onError(err.message);\n    }\n  }\n}\n\n```\n\n```\n// Using optional chaining with function calls\nfunction doSomething(onContent, onError) {\n  try {\n    // Do something with the data\n  } catch (err) {\n    onError?.(err.message); // No exception if onError is undefined\n  }\n}\n\n```\n\n### [Stacking the optional chaining operator](#stacking%5Fthe%5Foptional%5Fchaining%5Foperator)\n\nWith nested structures, it is possible to use optional chaining multiple times:\n\n```\nconst customer = {\n  name: \"Carl\",\n  details: {\n    age: 82,\n    location: \"Paradise Falls\", // Detailed address is unknown\n  },\n};\nconst customerCity = customer.details?.address?.city;\n\n// This also works with optional chaining function call\nconst customerName = customer.name?.getName?.(); // Method does not exist, customerName is undefined\n\n```\n\n### [Combining with the nullish coalescing operator](#combining%5Fwith%5Fthe%5Fnullish%5Fcoalescing%5Foperator)\n\nThe [nullish coalescing operator](/en-US/docs/Web/JavaScript/Reference/Operators/Nullish%5Fcoalescing) may be used after optional chaining in order to build a default value when none was found:\n\n```\nfunction printCustomerCity(customer) {\n  const customerCity = customer?.city ?? \"Unknown city\";\n  console.log(customerCity);\n}\n\nprintCustomerCity({\n  name: \"Nathan\",\n  city: \"Paris\",\n}); // \"Paris\"\nprintCustomerCity({\n  name: \"Carl\",\n  details: { age: 82 },\n}); // \"Unknown city\"\n\n```\n\n## [Specifications](#specifications)\n\n| Specification                                                                                                                                                   |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [ECMAScript Language Specification  \\# prod-OptionalExpression](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#prod-OptionalExpression) |\n\n## [Browser compatibility](#browser%5Fcompatibility)\n\nBCD tables only load in the browser\n\n## [See also](#see%5Falso)\n\n* The [nullish coalescing operator](/en-US/docs/Web/JavaScript/Reference/Operators/Nullish%5Fcoalescing)\n\n### Found a content problem with this page?\n\n* [Edit the page on GitHub](https://github.com/mdn/content/edit/main/files/en-us/web/javascript/reference/operators/optional%5Fchaining/index.md \"This will take you to GitHub, where you'll need to sign in first.\").\n* [Report the content issue](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FOptional%5Fchaining&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A%2A+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Foperators%2Foptional%5Fchaining%60%0A%2A+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FOptional%5Fchaining%0A%2A+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Foperators%2Foptional%5Fchaining%2Findex.md%0A%2A+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Fd85a7ba8cca98c2f6cf67a0c44f0ffd467532f20%0A%2A+Document+last+modified%3A+2023-04-05T04%3A57%3A48.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\").\n* [View the source on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/operators/optional%5Fchaining/index.md?plain=1 \"Folder: en-us/web/javascript/reference/operators/optional_chaining (Opens in a new tab)\").\nWant to get more involved? [Learn how to contribute](https://github.com/mdn/content/blob/main/CONTRIBUTING.md \"This will take you to our contribution guidelines on GitHub.\").\n\nThis page was last modified on Apr 5, 2023 by [MDN contributors](/en-US/docs/Web/JavaScript/Reference/Operators/Optional%5Fchaining/contributors.txt)."}