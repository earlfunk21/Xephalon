{"lang":"Javascript","fullPath":"/Operators/new","category":"Operators","title":"new","url":"/en-US/docs/Web/JavaScript/Reference/Operators/new","markdown":"# new operator\n\nThe **`new`** operator lets developers create an instance of a user-defined object type or of one of the built-in object types that has a constructor function.\n\n## [Try it](#try%5Fit)\n\n## [Syntax](#syntax)\n\n```\nnew constructor\nnew constructor()\nnew constructor(arg1)\nnew constructor(arg1, arg2)\nnew constructor(arg1, arg2, /* …, */ argN)\n\n```\n\n### [Parameters](#parameters)\n\n`constructor`\n\nA class or function that specifies the type of the object instance.\n\n`arg1`, `arg2`, …, `argN`\n\nA list of values that the `constructor` will be called with. `new Foo` is equivalent to `new Foo()`, i.e. if no argument list is specified, `Foo` is called without arguments.\n\n## [Description](#description)\n\nWhen a function is called with the **`new`** keyword, the function will be used as a constructor. `new` will do the following things:\n\n1. Creates a blank, plain JavaScript object. For convenience, let's call it `newInstance`.\n2. Points `newInstance`'s \\[\\[Prototype\\]\\] to the constructor function's `prototype` property, if the `prototype` is an [Object](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object). Otherwise, `newInstance` stays as a plain object with `Object.prototype` as its \\[\\[Prototype\\]\\].  \n**Note:** Properties/objects added to the constructor function's `prototype` property are therefore accessible to all instances created from the constructor function.\n3. Executes the constructor function with the given arguments, binding `newInstance` as the [this](/en-US/docs/Web/JavaScript/Reference/Operators/this) context (i.e. all references to `this` in the constructor function now refer to `newInstance`).\n4. If the constructor function returns a [non-primitive](/en-US/docs/Web/JavaScript/Data%5Fstructures#primitive%5Fvalues), this return value becomes the result of the whole `new` expression. Otherwise, if the constructor function doesn't return anything or returns a primitive, `newInstance` is returned instead. (Normally constructors don't return a value, but they can choose to do so to override the normal object creation process.)\n\n[Classes](/en-US/docs/Web/JavaScript/Reference/Classes) can only be instantiated with the `new` operator — attempting to call a class without `new` will throw a `TypeError`.\n\nCreating an object with a user-defined constructor function requires two steps:\n\n1. Define the object type by writing a function that specifies its name and properties. For example, a constructor function to create an object `Foo` might look like this:  \n```  \nfunction Foo(bar1, bar2) {  \n  this.bar1 = bar1;  \n  this.bar2 = bar2;  \n}  \n```\n2. Create an instance of the object with `new`.  \n```  \nconst myFoo = new Foo(\"Bar 1\", 2021);  \n```\n\n**Note:** An object can have a property that is itself another object. See the examples below.\n\nYou can always add a property to a previously defined object instance. For example, the statement `car1.color = \"black\"` adds a property `color` to `car1`, and assigns it a value of `\"black\"`.\n\nHowever, this does not affect any other objects. To add the new property to all objects of the same type, you must add the property to the constructor's `prototype` property. This defines a property that is shared by all objects created with that function, rather than by just one instance of the object type. The following code adds a `color` property with value `\"original color\"` to all objects of type `Car`, and then overwrites that value with the string `\"black\"` only in the instance object `car1`. For more information, see [prototype](/en-US/docs/Learn/JavaScript/Objects/Object%5Fprototypes).\n\n```\nfunction Car() {}\nconst car1 = new Car();\nconst car2 = new Car();\n\nconsole.log(car1.color); // undefined\n\nCar.prototype.color = \"original color\";\nconsole.log(car1.color); // 'original color'\n\ncar1.color = \"black\";\nconsole.log(car1.color); // 'black'\n\nconsole.log(Object.getPrototypeOf(car1).color); // 'original color'\nconsole.log(Object.getPrototypeOf(car2).color); // 'original color'\nconsole.log(car1.color); // 'black'\nconsole.log(car2.color); // 'original color'\n\n```\n\n**Note:** While the constructor function can be invoked like any regular function (i.e. without the `new` operator), in this case a new object is not created and the value of `this` is also different.\n\nA function can know whether it is invoked with `new` by checking [new.target](/en-US/docs/Web/JavaScript/Reference/Operators/new.target). `new.target` is only `undefined` when the function is invoked without `new`. For example, you can have a function that behaves differently when it's called versus when it's constructed:\n\n```\nfunction Car(color) {\n  if (!new.target) {\n    // Called as function.\n    return `${color} car`;\n  }\n  // Called with new.\n  this.color = color;\n}\n\nconst a = Car(\"red\"); // a is \"red car\"\nconst b = new Car(\"red\"); // b is `Car { color: \"red\" }`\n\n```\n\nPrior to ES6, which introduced [classes](/en-US/docs/Web/JavaScript/Reference/Classes), most JavaScript built-ins are both callable and constructible, although many of them exhibit different behaviors. To name a few:\n\n* [Array()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Array/Array), [Error()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Error/Error), and [Function()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Function/Function) behave the same when called as a function or a constructor.\n* [Boolean()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Boolean/Boolean), [Number()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number/Number), and [String()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String/String) coerce their argument to the respective primitive type when called, and return wrapper objects when constructed.\n* [Date()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Date/Date) returns a string representing the current date when called, equivalent to `new Date().toString()`.\n\nAfter ES6, the language is stricter about which are constructors and which are functions. For example:\n\n* [Symbol()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Symbol/Symbol) and [BigInt()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/BigInt/BigInt) can only be called without `new`. Attempting to construct them will throw a `TypeError`.\n* [Proxy](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Proxy/Proxy) and [Map](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Map/Map) can only be constructed with `new`. Attempting to call them will throw a `TypeError`.\n\n## [Examples](#examples)\n\n### [Object type and object instance](#object%5Ftype%5Fand%5Fobject%5Finstance)\n\n Suppose you want to create an object type for cars. You want this type of object to be called `Car`, and you want it to have properties for make, model, and year. To do this, you would write the following function:\n\n```\nfunction Car(make, model, year) {\n  this.make = make;\n  this.model = model;\n  this.year = year;\n}\n\n```\n\nNow you can create an object called `myCar` as follows:\n\n```\nconst myCar = new Car(\"Eagle\", \"Talon TSi\", 1993);\n\n```\n\n This statement creates `myCar` and assigns it the specified values for its properties. Then the value of `myCar.make` is the string \"Eagle\",`myCar.year` is the integer 1993, and so on.\n\n You can create any number of `car` objects by calls to `new`. For example:\n\n```\nconst kensCar = new Car(\"Nissan\", \"300ZX\", 1992);\n\n```\n\n### [Object property that is itself another object](#object%5Fproperty%5Fthat%5Fis%5Fitself%5Fanother%5Fobject)\n\nSuppose you define an object called `Person` as follows:\n\n```\nfunction Person(name, age, sex) {\n  this.name = name;\n  this.age = age;\n  this.sex = sex;\n}\n\n```\n\nAnd then instantiate two new `Person` objects as follows:\n\n```\nconst rand = new Person(\"Rand McNally\", 33, \"M\");\nconst ken = new Person(\"Ken Jones\", 39, \"M\");\n\n```\n\n Then you can rewrite the definition of `Car` to include an`owner` property that takes a `Person` object, as follows:\n\n```\nfunction Car(make, model, year, owner) {\n  this.make = make;\n  this.model = model;\n  this.year = year;\n  this.owner = owner;\n}\n\n```\n\nTo instantiate the new objects, you then use the following:\n\n```\nconst car1 = new Car(\"Eagle\", \"Talon TSi\", 1993, rand);\nconst car2 = new Car(\"Nissan\", \"300ZX\", 1992, ken);\n\n```\n\n Instead of passing a literal string or integer value when creating the new objects, the above statements pass the objects `rand` and `ken` as the parameters for the owners. To find out the name of the owner of `car2`, you can access the following property:\n\n```\ncar2.owner.name;\n\n```\n\n### [Using new with classes](#using%5Fnew%5Fwith%5Fclasses)\n\n```\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n  greet() {\n    console.log(`Hello, my name is ${this.name}`);\n  }\n}\n\nconst p = new Person(\"Caroline\");\np.greet(); // Hello, my name is Caroline\n\n```\n\n## [Specifications](#specifications)\n\n| Specification                                                                                                                                     |\n| ------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [ECMAScript Language Specification  \\# sec-new-operator](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-new-operator) |\n\n## [Browser compatibility](#browser%5Fcompatibility)\n\nBCD tables only load in the browser\n\n## [See also](#see%5Falso)\n\n* [Function](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Function)\n* [Reflect.construct()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Reflect/construct)\n* [Object](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object)\n\n### Found a content problem with this page?\n\n* [Edit the page on GitHub](https://github.com/mdn/content/edit/main/files/en-us/web/javascript/reference/operators/new/index.md \"This will take you to GitHub, where you'll need to sign in first.\").\n* [Report the content issue](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fnew&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A%2A+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Foperators%2Fnew%60%0A%2A+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fnew%0A%2A+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Foperators%2Fnew%2Findex.md%0A%2A+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2F0f3738f6b1ed1aa69395ff181207186e1ad9f4d8%0A%2A+Document+last+modified%3A+2023-02-21T00%3A33%3A34.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\").\n* [View the source on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/operators/new/index.md?plain=1 \"Folder: en-us/web/javascript/reference/operators/new (Opens in a new tab)\").\nWant to get more involved? [Learn how to contribute](https://github.com/mdn/content/blob/main/CONTRIBUTING.md \"This will take you to our contribution guidelines on GitHub.\").\n\nThis page was last modified on Feb 21, 2023 by [MDN contributors](/en-US/docs/Web/JavaScript/Reference/Operators/new/contributors.txt)."}