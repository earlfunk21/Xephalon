{"lang":"Javascript","fullPath":"/Operators/Object_initializer","category":"Operators","title":"Object_initializer","url":"/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer","markdown":"# Object initializer\n\nAn **object initializer** is a comma-delimited list of zero or more pairs of property names and associated values of an object, enclosed in curly braces (`{}`). Objects can also be initialized using [Object.create()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/create) or [by invoking a constructor function](/en-US/docs/Web/JavaScript/Guide/Working%5Fwith%5Fobjects#using%5Fa%5Fconstructor%5Ffunction) with the [new](/en-US/docs/Web/JavaScript/Reference/Operators/new) operator.\n\n## [Try it](#try%5Fit)\n\n## [Syntax](#syntax)\n\n```\no = {\n  a: \"foo\",\n  b: 42,\n  c: {},\n  1: \"number literal property\",\n  \"foo:bar\": \"string literal property\",\n\n  shorthandProperty,\n\n  method(parameters) {\n    // …\n  },\n\n  get property() {},\n  set property(value) {},\n\n  [expression]: \"computed property\",\n\n  __proto__: prototype,\n\n  ...spreadProperty,\n};\n\n```\n\n## [Description](#description)\n\nAn object initializer is an expression that describes the initialization of an [Object](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object). Objects consist of _properties_, which are used to describe an object. The values of object properties can either contain [primitive](/en-US/docs/Glossary/Primitive) data types or other objects.\n\n### [Object literal syntax vs. JSON](#object%5Fliteral%5Fsyntax%5Fvs.%5Fjson)\n\nThe object literal syntax is not the same as the **J**ava**S**cript **O**bject **N**otation ([JSON](/en-US/docs/Glossary/JSON)). Although they look similar, there are differences between them:\n\n* JSON _only_ permits property definition using the `\"property\": value` syntax. The property name must be double-quoted, and the definition cannot be a shorthand. Computed property names are not allowed either.\n* JSON object property values can only be strings, numbers, `true`, `false`, `null`, arrays, or another JSON object. This means JSON cannot express methods or non-plain objects like [Date](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Date) or [RegExp](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/RegExp).\n* In JSON, `\"__proto__\"` is a normal property key. In an object literal, it [sets the object's prototype](#prototype%5Fsetter).\n\nJSON is a _strict subset_ of the object literal syntax, meaning that every valid JSON text can be parsed as an object literal, and would likely not cause syntax errors. The only exception is that the object literal syntax prohibits duplicate `__proto__` keys, which does not apply to [JSON.parse()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/JSON/parse). The latter treats `__proto__` like a normal property and takes the last occurrence as the property's value. The only time when the object value they represent (a.k.a. their semantic) differ is also when the source contains the `__proto__` key — for object literals, it sets the object's prototype; for JSON, it's a normal property.\n\n```\nconsole.log(JSON.parse('{ \"__proto__\": 0, \"__proto__\": 1 }')); // {__proto__: 1}\nconsole.log({ \"__proto__\": 0, \"__proto__\": 1 }); // SyntaxError: Duplicate __proto__ fields are not allowed in object literals\n\nconsole.log(JSON.parse('{ \"__proto__\": {} }')); // { __proto__: {} }\nconsole.log({ \"__proto__\": {} }); // {} (with {} as prototype)\n\n```\n\n## [Examples](#examples)\n\n### [Creating objects](#creating%5Fobjects)\n\nAn empty object with no properties can be created like this:\n\n```\nconst object = {};\n\n```\n\nHowever, the advantage of the _literal_ or _initializer_ notation is, that you are able to quickly create objects with properties inside the curly braces. You notate a list of `key: value` pairs delimited by commas.\n\nThe following code creates an object with three properties and the keys are `\"foo\"`, `\"age\"` and `\"baz\"`. The values of these keys are a string `\"bar\"`, the number `42`, and another object.\n\n```\nconst object = {\n  foo: \"bar\",\n  age: 42,\n  baz: { myProp: 12 },\n};\n\n```\n\n### [Accessing properties](#accessing%5Fproperties)\n\nOnce you have created an object, you might want to read or change them. Object properties can be accessed by using the dot notation or the bracket notation. (See [property accessors](/en-US/docs/Web/JavaScript/Reference/Operators/Property%5Faccessors) for detailed information.)\n\n```\nobject.foo; // \"bar\"\nobject[\"age\"]; // 42\nobject.baz; // {myProp: 12}\nobject.baz.myProp; //12\n\n```\n\n### [Property definitions](#property%5Fdefinitions)\n\nWe have already learned how to notate properties using the initializer syntax. Oftentimes, there are variables in your code that you would like to put into an object. You will see code like this:\n\n```\nconst a = \"foo\";\nconst b = 42;\nconst c = {};\n\nconst o = {\n  a: a,\n  b: b,\n  c: c,\n};\n\n```\n\nThere is a shorter notation available to achieve the same:\n\n```\nconst a = \"foo\";\nconst b = 42;\nconst c = {};\n\n// Shorthand property names\nconst o = { a, b, c };\n\n// In other words,\nconsole.log(o.a === { a }.a); // true\n\n```\n\n#### Duplicate property names\n\nWhen using the same name for your properties, the second property will overwrite the first.\n\n```\nconst a = { x: 1, x: 2 };\nconsole.log(a); // {x: 2}\n\n```\n\nAfter ES2015, duplicate property names are allowed everywhere, including [strict mode](/en-US/docs/Web/JavaScript/Reference/Strict%5Fmode#duplicate%5Fproperty%5Fnames). You can also have duplicate property names in [classes](/en-US/docs/Web/JavaScript/Reference/Classes). The only exception is [private properties](/en-US/docs/Web/JavaScript/Reference/Classes/Private%5Fclass%5Ffields), which must be unique in the class body.\n\n### [Method definitions](#method%5Fdefinitions)\n\nA property of an object can also refer to a [function](/en-US/docs/Web/JavaScript/Reference/Functions) or a [getter](/en-US/docs/Web/JavaScript/Reference/Functions/get) or [setter](/en-US/docs/Web/JavaScript/Reference/Functions/set) method.\n\n```\nconst o = {\n  property: function (parameters) {},\n  get property() {},\n  set property(value) {},\n};\n\n```\n\nA shorthand notation is available, so that the keyword `function` is no longer necessary.\n\n```\n// Shorthand method names\nconst o = {\n  property(parameters) {},\n};\n\n```\n\nThere is also a way to concisely define generator methods.\n\n```\nconst o = {\n  *generator() {\n    // …\n  },\n};\n\n```\n\nWhich is equivalent to this ES5-like notation (but note that ECMAScript 5 has no generators):\n\n```\nconst o = {\n  generator: function* () {\n    // …\n  },\n};\n\n```\n\nFor more information and examples about methods, see [method definitions](/en-US/docs/Web/JavaScript/Reference/Functions/Method%5Fdefinitions).\n\n### [Computed property names](#computed%5Fproperty%5Fnames)\n\nThe object initializer syntax also supports computed property names. That allows you to put an expression in brackets `[]`, that will be computed and used as the property name. This is reminiscent of the bracket notation of the [property accessor](/en-US/docs/Web/JavaScript/Reference/Operators/Property%5Faccessors) syntax, which you may have used to read and set properties already.\n\nNow you can use a similar syntax in object literals, too:\n\n```\n// Computed property names\nlet i = 0;\nconst a = {\n  [`foo${++i}`]: i,\n  [`foo${++i}`]: i,\n  [`foo${++i}`]: i,\n};\n\nconsole.log(a.foo1); // 1\nconsole.log(a.foo2); // 2\nconsole.log(a.foo3); // 3\n\nconst items = [\"A\", \"B\", \"C\"];\nconst obj = {\n  [items]: \"Hello\",\n};\nconsole.log(obj); // A,B,C: \"Hello\"\nconsole.log(obj[\"A,B,C\"]); // \"Hello\"\n\nconst param = \"size\";\nconst config = {\n  [param]: 12,\n  [`mobile${param.charAt(0).toUpperCase()}${param.slice(1)}`]: 4,\n};\n\nconsole.log(config); // {size: 12, mobileSize: 4}\n\n```\n\n### [Spread properties](#spread%5Fproperties)\n\nObject literals support the [spread syntax](/en-US/docs/Web/JavaScript/Reference/Operators/Spread%5Fsyntax). It copies own enumerable properties from a provided object onto a new object.\n\nShallow-cloning (excluding `prototype`) or merging objects is now possible using a shorter syntax than [Object.assign()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/assign).\n\n```\nconst obj1 = { foo: \"bar\", x: 42 };\nconst obj2 = { foo: \"baz\", y: 13 };\n\nconst clonedObj = { ...obj1 };\n// { foo: \"bar\", x: 42 }\n\nconst mergedObj = { ...obj1, ...obj2 };\n// { foo: \"baz\", x: 42, y: 13 }\n\n```\n\n**Warning:** Note that [Object.assign()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/assign) triggers [setters](/en-US/docs/Web/JavaScript/Reference/Functions/set), whereas the spread syntax doesn't!\n\n### [Prototype setter](#prototype%5Fsetter)\n\nA property definition of the form `__proto__: value` or `\"__proto__\": value` does not create a property with the name `__proto__`. Instead, if the provided value is an object or [null](/en-US/docs/Web/JavaScript/Reference/Operators/null), it points the `[[Prototype]]` of the created object to that value. (If the value is not an object or `null`, the object is not changed.)\n\nNote that the `__proto__` key is standardized syntax, in contrast to the non-standard and non-performant [Object.prototype.\\_\\_proto\\_\\_](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/proto) accessors. It sets the `[[Prototype]]` during object creation, similar to [Object.create](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/create) — instead of mutating the prototype chain.\n\n```\nconst obj1 = {};\nconsole.log(Object.getPrototypeOf(obj1) === Object.prototype); // true\n\nconst obj2 = { __proto__: null };\nconsole.log(Object.getPrototypeOf(obj2)); // null\n\nconst protoObj = {};\nconst obj3 = { \"__proto__\": protoObj };\nconsole.log(Object.getPrototypeOf(obj3) === protoObj); // true\n\nconst obj4 = { __proto__: \"not an object or null\" };\nconsole.log(Object.getPrototypeOf(obj4) === Object.prototype); // true\nconsole.log(Object.hasOwn(obj4, \"__proto__\")); // false\n\n```\n\nOnly a single prototype setter is permitted in an object literal. Multiple prototype setters are a syntax error.\n\nProperty definitions that do not use \"colon\" notation are not prototype setters. They are property definitions that behave identically to similar definitions using any other name.\n\n```\nconst __proto__ = \"variable\";\n\nconst obj1 = { __proto__ };\nconsole.log(Object.getPrototypeOf(obj1) === Object.prototype); // true\nconsole.log(Object.hasOwn(obj1, \"__proto__\")); // true\nconsole.log(obj1.__proto__); // \"variable\"\n\nconst obj2 = { __proto__() { return \"hello\"; } };\nconsole.log(obj2.__proto__()); // \"hello\"\n\nconst obj3 = { [\"__proto__\"]: 17 };\nconsole.log(obj3.__proto__); // 17\n\n// Mixing prototype setter with normal own properties with \"__proto__\" key\nconst obj4 = { [\"__proto__\"]: 17, __proto__: {} }; // {__proto__: 17} (with {} as prototype)\nconst obj5 = {\n  [\"__proto__\"]: 17,\n  __proto__: {},\n  __proto__: null, // SyntaxError: Duplicate __proto__ fields are not allowed in object literals\n};\nconst obj6 = {\n  [\"__proto__\"]: 17,\n  [\"__proto__\"]: \"hello\",\n  __proto__: null,\n}; // {__proto__: \"hello\"} (with null as prototype)\nconst obj7 =  {\n  [\"__proto__\"]: 17,\n  __proto__,\n  __proto__: null,\n}; // {__proto__: \"variable\"} (with null as prototype)\n\n```\n\n## [Specifications](#specifications)\n\n| Specification                                                                                                                                                 |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [ECMAScript Language Specification  \\# sec-object-initializer](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-object-initializer) |\n\n## [Browser compatibility](#browser%5Fcompatibility)\n\nBCD tables only load in the browser\n\n## [See also](#see%5Falso)\n\n* [Property accessors](/en-US/docs/Web/JavaScript/Reference/Operators/Property%5Faccessors)\n* [get](/en-US/docs/Web/JavaScript/Reference/Functions/get) / [set](/en-US/docs/Web/JavaScript/Reference/Functions/set)\n* [Method definitions](/en-US/docs/Web/JavaScript/Reference/Functions/Method%5Fdefinitions)\n* [Lexical grammar](/en-US/docs/Web/JavaScript/Reference/Lexical%5Fgrammar)\n\n### Found a content problem with this page?\n\n* [Edit the page on GitHub](https://github.com/mdn/content/edit/main/files/en-us/web/javascript/reference/operators/object%5Finitializer/index.md \"This will take you to GitHub, where you'll need to sign in first.\").\n* [Report the content issue](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FObject%5Finitializer&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A%2A+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Foperators%2Fobject%5Finitializer%60%0A%2A+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2FObject%5Finitializer%0A%2A+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Foperators%2Fobject%5Finitializer%2Findex.md%0A%2A+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Fd85a7ba8cca98c2f6cf67a0c44f0ffd467532f20%0A%2A+Document+last+modified%3A+2023-04-05T04%3A57%3A48.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\").\n* [View the source on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/operators/object%5Finitializer/index.md?plain=1 \"Folder: en-us/web/javascript/reference/operators/object_initializer (Opens in a new tab)\").\nWant to get more involved? [Learn how to contribute](https://github.com/mdn/content/blob/main/CONTRIBUTING.md \"This will take you to our contribution guidelines on GitHub.\").\n\nThis page was last modified on Apr 5, 2023 by [MDN contributors](/en-US/docs/Web/JavaScript/Reference/Operators/Object%5Finitializer/contributors.txt)."}