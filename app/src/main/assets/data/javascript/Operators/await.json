{"lang":"Javascript","fullPath":"/Operators/await","category":"Operators","title":"await","url":"/en-US/docs/Web/JavaScript/Reference/Operators/await","markdown":"# await\n\nThe **`await`** operator is used to wait for a [Promise](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) and get its fulfillment value. It can only be used inside an [async function](/en-US/docs/Web/JavaScript/Reference/Statements/async%5Ffunction) or at the top level of a [module](/en-US/docs/Web/JavaScript/Guide/Modules).\n\n## [Syntax](#syntax)\n\n```\nawait expression\n\n```\n\n### [Parameters](#parameters)\n\n`expression`\n\nA [Promise](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise), a [thenable object](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise#thenables), or any value to wait for.\n\n### [Return value](#return%5Fvalue)\n\nThe fulfillment value of the promise or thenable object, or, if the expression is not thenable, the expression's own value.\n\n### [Exceptions](#exceptions)\n\nThrows the rejection reason if the promise or thenable object is rejected.\n\n## [Description](#description)\n\n`await` is usually used to unwrap promises by passing a [Promise](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise) as the `expression`. Using `await` pauses the execution of its surrounding `async` function until the promise is settled (that is, fulfilled or rejected). When execution resumes, the value of the `await` expression becomes that of the fulfilled promise.\n\nIf the promise is rejected, the `await` expression throws the rejected value. The function containing the `await` expression will [appear in the stack trace](#improving%5Fstack%5Ftrace) of the error. Otherwise, if the rejected promise is not awaited or is immediately returned, the caller function will not appear in the stack trace.\n\nThe `expression` is resolved in the same way as [Promise.resolve()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/resolve): it's always converted to a native `Promise` and then awaited. If the `expression` is a:\n\n* Native `Promise` (which means `expression` belongs to `Promise` or a subclass, and `expression.constructor === Promise`): The promise is directly used and awaited natively, without calling `then()`.\n* [Thenable object](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise#thenables) (including non-native promises, polyfill, proxy, child class, etc.): A new promise is constructed with the native [Promise()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/Promise) constructor by calling the object's `then()` method and passing in a handler that calls the `resolve` callback.\n* Non-thenable value: An already-fulfilled `Promise` is constructed and used.\n\nEven when the used promise is already fulfilled, the async function's execution still pauses until the next tick. In the meantime, the caller of the async function resumes execution. [See example below.](#control%5Fflow%5Feffects%5Fof%5Fawait)\n\nBecause `await` is only valid inside async functions and modules, which themselves are asynchronous and return promises, the `await` expression never blocks the main thread and only defers execution of code that actually depends on the result, i.e. anything after the `await` expression.\n\n## [Examples](#examples)\n\n### [Awaiting a promise to be fulfilled](#awaiting%5Fa%5Fpromise%5Fto%5Fbe%5Ffulfilled)\n\nIf a `Promise` is passed to an `await` expression, it waits for the `Promise` to be fulfilled and returns the fulfilled value.\n\n```\nfunction resolveAfter2Seconds(x) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(x);\n    }, 2000);\n  });\n}\n\nasync function f1() {\n  const x = await resolveAfter2Seconds(10);\n  console.log(x); // 10\n}\n\nf1();\n\n```\n\n### [Thenable objects](#thenable%5Fobjects)\n\n[Thenable objects](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise#thenables) are resolved just the same as actual `Promise` objects.\n\n```\nasync function f() {\n  const thenable = {\n    then(resolve, _reject) {\n      resolve(\"resolved!\");\n    },\n  };\n  console.log(await thenable); // \"resolved!\"\n}\n\nf();\n\n```\n\nThey can also be rejected:\n\n```\nasync function f() {\n  const thenable = {\n    then(resolve, reject) {\n      reject(new Error(\"rejected!\"));\n    },\n  };\n  await thenable; // Throws Error: rejected!\n}\n\nf();\n\n```\n\n### [Conversion to promise](#conversion%5Fto%5Fpromise)\n\nIf the value is not a `Promise`, `await` converts the value to a resolved `Promise`, and waits for it. The awaited value's identity doesn't change as long as it doesn't have a `then` property that's callable.\n\n```\nasync function f3() {\n  const y = await 20;\n  console.log(y); // 20\n\n  const obj = {};\n  console.log((await obj) === obj); // true\n}\n\nf3();\n\n```\n\n### [Handling rejected promises](#handling%5Frejected%5Fpromises)\n\nIf the `Promise` is rejected, the rejected value is thrown.\n\n```\nasync function f4() {\n  try {\n    const z = await Promise.reject(30);\n  } catch (e) {\n    console.error(e); // 30\n  }\n}\n\nf4();\n\n```\n\nYou can handle rejected promises without a `try` block by chaining a [catch()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/catch) handler before awaiting the promise.\n\n```\nconst response = await promisedFunction().catch((err) => {\n  console.error(err);\n  return \"default response\";\n});\n// response will be \"default response\" if the promise is rejected\n\n```\n\nThis is built on the assumption that `promisedFunction()` never synchronously throws an error, but always returns a rejected promise. This is the case for most properly-designed promise-based functions, which usually look like:\n\n```\nfunction promisedFunction() {\n  // Immediately return a promise to minimize chance of an error being thrown\n  return new Promise((resolve, reject) => {\n    // do something async\n  });\n}\n\n```\n\nHowever, if `promisedFunction()` does throw an error synchronously, the error won't be caught by the `catch()` handler. In this case, the `try...catch` statement is necessary.\n\n### [Top level await](#top%5Flevel%5Fawait)\n\nYou can use the `await` keyword on its own (outside of an async function) at the top level of a [module](/en-US/docs/Web/JavaScript/Guide/Modules). This means that modules with child modules that use `await` will wait for the child modules to execute before they themselves run, all while not blocking other child modules from loading.\n\nHere is an example of a simple module using the [Fetch API](/en-US/docs/Web/API/Fetch%5FAPI) and specifying await within the [export](/en-US/docs/Web/JavaScript/Reference/Statements/export) statement. Any modules that include this will wait for the fetch to resolve before running any code.\n\n```\n// fetch request\nconst colors = fetch(\"../data/colors.json\").then((response) => response.json());\n\nexport default await colors;\n\n```\n\n### [Control flow effects of await](#control%5Fflow%5Feffects%5Fof%5Fawait)\n\nWhen an `await` is encountered in code (either in an async function or in a module), the awaited expression is executed, while all code that depends on the expression's value is paused and pushed into the [microtask queue](/en-US/docs/Web/JavaScript/Event%5Floop). The main thread is then freed for the next task in the event loop. This happens even if the awaited value is an already-resolved promise or not a promise. For example, consider the following code:\n\n```\nasync function foo(name) {\n  console.log(name, \"start\");\n  console.log(name, \"middle\");\n  console.log(name, \"end\");\n}\n\nfoo(\"First\");\nfoo(\"Second\");\n\n// First start\n// First middle\n// First end\n// Second start\n// Second middle\n// Second end\n\n```\n\nIn this case, the two async functions are synchronous in effect, because they don't contain any `await` expression. The three statements happen in the same tick. In promise terms, the function corresponds to:\n\n```\nfunction foo(name) {\n  return new Promise((resolve) => {\n    console.log(name, \"start\");\n    console.log(name, \"middle\");\n    console.log(name, \"end\");\n    resolve();\n  });\n}\n\n```\n\nHowever, as soon as there's one `await`, the function becomes asynchronous, and execution of following statements is deferred to the next tick.\n\n```\nasync function foo(name) {\n  console.log(name, \"start\");\n  await console.log(name, \"middle\");\n  console.log(name, \"end\");\n}\n\nfoo(\"First\");\nfoo(\"Second\");\n\n// First start\n// First middle\n// Second start\n// Second middle\n// First end\n// Second end\n\n```\n\nThis corresponds to:\n\n```\nfunction foo(name) {\n  return new Promise((resolve) => {\n    console.log(name, \"start\");\n    resolve(console.log(name, \"middle\"));\n  }).then(() => {\n    console.log(name, \"end\");\n  });\n}\n\n```\n\nWhile the extra `then()` handler is not necessary, and the handler can be merged with the executor passed to the constructor, the `then()` handler's existence means the code will take one extra tick to complete. The same happens for `await`. Therefore, make sure to use `await` only when necessary (to unwrap promises into their values).\n\nOther microtasks can execute before the async function resumes. This example uses [queueMicrotask()](/en-US/docs/Web/API/queueMicrotask) to demonstrate how the microtask queue is processed when each `await` expression is encountered.\n\n```\nlet i = 0;\n\nqueueMicrotask(function test() {\n  i++;\n  console.log(\"microtask\", i);\n  if (i < 3) {\n    queueMicrotask(test);\n  }\n});\n\n(async () => {\n  console.log(\"async function start\");\n  for (let i = 1; i < 3; i++) {\n    await null;\n    console.log(\"async function resume\", i);\n  }\n  await null;\n  console.log(\"async function end\");\n})();\n\nqueueMicrotask(() => {\n  console.log(\"queueMicrotask() after calling async function\");\n});\n\nconsole.log(\"script sync part end\");\n\n// Logs:\n// async function start\n// script sync part end\n// microtask 1\n// async function resume 1\n// queueMicrotask() after calling async function\n// microtask 2\n// async function resume 2\n// microtask 3\n// async function end\n\n```\n\nIn this example, the `test()` function is always called before the async function resumes, so the microtasks they each schedule are always executed in an intertwined fashion. On the other hand, because both `await` and `queueMicrotask()` schedule microtasks, the order of execution is always based on the order of scheduling. This is why the \"queueMicrotask() after calling async function\" log happens after the async function resumes for the first time.\n\n### [Improving stack trace](#improving%5Fstack%5Ftrace)\n\nSometimes, the `await` is omitted when a promise is directly returned from an async function.\n\n```\nasync function noAwait() {\n  // Some actions...\n\n  return /* await */ lastAsyncTask();\n}\n\n```\n\nHowever, consider the case where `lastAsyncTask` asynchronously throws an error.\n\n```\nasync function lastAsyncTask() {\n  await null;\n  throw new Error(\"failed\");\n}\n\nasync function noAwait() {\n  return lastAsyncTask();\n}\n\nnoAwait();\n\n// Error: failed\n//    at lastAsyncTask\n\n```\n\nOnly `lastAsyncTask` appears in the stack trace, because the promise is rejected after it has already been returned from `noAwait` — in some sense, the promise is unrelated to `noAwait`. To improve the stack trace, you can use `await` to unwrap the promise, so that the exception gets thrown into the current function. The exception will then be immediately wrapped into a new rejected promise, but during error creation, the caller will appear in the stack trace.\n\n```\nasync function lastAsyncTask() {\n  await null;\n  throw new Error(\"failed\");\n}\n\nasync function withAwait() {\n  return await lastAsyncTask();\n}\n\nwithAwait();\n\n// Error: failed\n//    at lastAsyncTask\n//    at async withAwait\n\n```\n\nHowever, there's a little performance penalty coming with `return await` because the promise has to be unwrapped and wrapped again.\n\n## [Specifications](#specifications)\n\n| Specification                                                                                                                                                                           |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [ECMAScript Language Specification  \\# sec-async-function-definitions](https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-async-function-definitions) |\n\n## [Browser compatibility](#browser%5Fcompatibility)\n\nBCD tables only load in the browser\n\n## [See also](#see%5Falso)\n\n* [async function](/en-US/docs/Web/JavaScript/Reference/Statements/async%5Ffunction)\n* [async function expression](/en-US/docs/Web/JavaScript/Reference/Operators/async%5Ffunction)\n* [AsyncFunction](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/AsyncFunction)\n* [Top-level await](https://v8.dev/features/top-level-await) on v8.dev (October 8, 2019)\n\n### Found a content problem with this page?\n\n* [Edit the page on GitHub](https://github.com/mdn/content/edit/main/files/en-us/web/javascript/reference/operators/await/index.md \"This will take you to GitHub, where you'll need to sign in first.\").\n* [Report the content issue](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fawait&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A%2A+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Foperators%2Fawait%60%0A%2A+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fawait%0A%2A+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Foperators%2Fawait%2Findex.md%0A%2A+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Fd85a7ba8cca98c2f6cf67a0c44f0ffd467532f20%0A%2A+Document+last+modified%3A+2023-04-05T04%3A57%3A48.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\").\n* [View the source on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/operators/await/index.md?plain=1 \"Folder: en-us/web/javascript/reference/operators/await (Opens in a new tab)\").\nWant to get more involved? [Learn how to contribute](https://github.com/mdn/content/blob/main/CONTRIBUTING.md \"This will take you to our contribution guidelines on GitHub.\").\n\nThis page was last modified on Apr 5, 2023 by [MDN contributors](/en-US/docs/Web/JavaScript/Reference/Operators/await/contributors.txt)."}