{"lang":"Javascript","fullPath":"/Operators/this","category":"Operators","title":"this","url":"/en-US/docs/Web/JavaScript/Reference/Operators/this","markdown":"# this\n\nA function's **`this`** keyword behaves a little differently in JavaScript compared to other languages. It also has some differences between [strict mode](/en-US/docs/Web/JavaScript/Reference/Strict%5Fmode) and non-strict mode.\n\nIn most cases, the value of `this` is determined by how a function is called (runtime binding). It can't be set by assignment during execution, and it may be different each time the function is called. The [bind()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Function/bind) method can [set the value of a function's this regardless of how it's called](#the%5Fbind%5Fmethod), and [arrow functions](/en-US/docs/Web/JavaScript/Reference/Functions/Arrow%5Ffunctions) don't provide their own `this` binding (it retains the `this` value of the enclosing lexical context).\n\n## [Try it](#try%5Fit)\n\n## [Syntax](#syntax)\n\n```\nthis\n\n```\n\n### [Value](#value)\n\nIn non–strict mode, `this` is always a reference to an object. In strict mode, it can be any value. For more information on how the value is determined, see the description below.\n\n## [Description](#description)\n\nThe value of `this` depends on in which context it appears: function, class, or global.\n\n### [Function context](#function%5Fcontext)\n\nInside a function, the value of `this` depends on how the function is called. Think about `this` as a hidden parameter of a function — just like the parameters declared in the function definition, `this` is a binding that the language creates for you when the function body is evaluated.\n\nFor a typical function, the value of `this` is the object that the function is accessed on. In other words, if the function call is in the form `obj.f()`, then `this` refers to `obj`. For example:\n\n```\nfunction getThis() {\n  return this;\n}\n\nconst obj1 = { name: \"obj1\" };\nconst obj2 = { name: \"obj2\" };\n\nobj1.getThis = getThis;\nobj2.getThis = getThis;\n\nconsole.log(obj1.getThis()); // { name: 'obj1', getThis: [Function: getThis] }\nconsole.log(obj2.getThis()); // { name: 'obj2', getThis: [Function: getThis] }\n\n```\n\nNote how the function is the same, but based on how it's invoked, the value of `this` is different. This is analogous to how function parameters work.\n\nThe value of `this` is not the object that has the function as an own property, but the object that is used to call the function. You can prove this by calling a method of an object up in the [prototype chain](/en-US/docs/Web/JavaScript/Inheritance%5Fand%5Fthe%5Fprototype%5Fchain).\n\n```\nconst obj3 = {\n  __proto__: obj1,\n  name: \"obj3\",\n};\n\nconsole.log(obj3.getThis()); // { name: 'obj3' }\n\n```\n\nThe value of `this` always changes based on how a function is called, even when the function was defined on an object at creation:\n\n```\nconst obj4 = {\n  name: \"obj4\",\n  getThis() {\n    return this;\n  },\n};\n\nconst obj5 = { name: \"obj5\" };\n\nobj5.getThis = obj4.getThis;\nconsole.log(obj5.getThis()); // { name: 'obj5', getThis: [Function: getThis] }\n\n```\n\nIf the value that the method is accessed on is a primitive, `this` will be a primitive value as well — but only if the function is in strict mode.\n\n```\nfunction getThisStrict() {\n  \"use strict\"; // Enter strict mode\n  return this;\n}\n\n// Only for demonstration — you should not mutate built-in prototypes\nNumber.prototype.getThisStrict = getThisStrict;\nconsole.log(typeof (1).getThisStrict()); // \"number\"\n\n```\n\nIf the function is called without being accessed on anything, `this` will be `undefined` — but only if the function is in strict mode.\n\n```\nconsole.log(typeof getThisStrict()); // \"undefined\"\n\n```\n\nIn non-strict mode, a special process called [this substitution](/en-US/docs/Web/JavaScript/Reference/Strict%5Fmode#no%5Fthis%5Fsubstitution) ensures that the value of `this` is always an object. This means:\n\n* If a function is called with `this` set to `undefined` or `null`, `this` gets substituted with [globalThis](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/globalThis).\n* If the function is called with `this` set to a primitive value, `this` gets substituted with the primitive value's wrapper object.\n\n```\nfunction getThis() {\n  return this;\n}\n\n// Only for demonstration — you should not mutate built-in prototypes\nNumber.prototype.getThis = getThis;\nconsole.log(typeof (1).getThis()); // \"object\"\nconsole.log(getThis() === globalThis); // true\n\n```\n\nIn typical function calls, `this` is implicitly passed like a parameter through the function's prefix (the part before the dot). You can also explicitly set the value of `this` using the [Function.prototype.call()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Function/call), [Function.prototype.apply()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Function/apply), or [Reflect.apply()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Reflect/apply) methods. Using [Function.prototype.bind()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Function/bind), you can create a new function with a specific value of `this` that doesn't change regardless of how the function is called. When using these methods, the `this` substitution rules above still apply if the function is non-strict.\n\n#### Callbacks\n\nWhen a function is passed as a callback, the value of `this` depends on how the callback is called, which is determined by the implementor of the API. Callbacks are _typically_ called with a `this` value of `undefined` (calling it directly without attaching it to any object), which means if the function is non–strict, the value of `this` is the global object ([globalThis](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/globalThis)). This is the case for [iterative array methods](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Array#iterative%5Fmethods), the [Promise()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/Promise) constructor, etc.\n\n```\nfunction logThis() {\n  \"use strict\";\n  console.log(this);\n}\n\n[1, 2, 3].forEach(logThis); // undefined, undefined, undefined\n\n```\n\nSome APIs allow you to set a `this` value for invocations of the callback. For example, all iterative array methods and related ones like [Set.prototype.forEach()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Set/forEach) accept an optional `thisArg` parameter.\n\n```\n[1, 2, 3].forEach(logThis, { name: \"obj\" });\n// { name: 'obj' }, { name: 'obj' }, { name: 'obj' }\n\n```\n\nOccasionally, a callback is called with a `this` value other than `undefined`. For example, the `reviver` parameter of [JSON.parse()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/JSON/parse) and the `replacer` parameter of [JSON.stringify()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/JSON/stringify) are both called with `this` set to the object that the property being parsed/serialized belongs to.\n\n#### Arrow functions\n\nIn [arrow functions](/en-US/docs/Web/JavaScript/Reference/Functions/Arrow%5Ffunctions), `this` retains the value of the enclosing lexical context's `this`. In other words, when evaluating an arrow function's body, the language does not create a new `this` binding.\n\nFor example, in global code, `this` is always `globalThis` regardless of strictness, because of the [global context](#global%5Fcontext) binding:\n\n```\nconst globalObject = this;\nconst foo = () => this;\nconsole.log(foo() === globalObject); // true\n\n```\n\nArrow functions create a [closure](/en-US/docs/Web/JavaScript/Closures) over the `this` value of its surrounding scope, which means arrow functions behave as if they are \"auto-bound\" — no matter how it's invoked, `this` is set to what it was when the function was created (in the example above, the global object). The same applies to arrow functions created inside other functions: their `this` remains that of the enclosing lexical context. [See example below](#this%5Fin%5Farrow%5Ffunctions).\n\nFurthermore, when invoking arrow functions using `call()`, `bind()`, or `apply()`, the `thisArg` parameter is ignored. You can still pass other arguments using these methods, though.\n\n```\nconst obj = { name: \"obj\" };\n\n// Attempt to set this using call\nconsole.log(foo.call(obj) === globalObject); // true\n\n// Attempt to set this using bind\nconst boundFoo = foo.bind(obj);\nconsole.log(boundFoo() === globalObject); // true\n\n```\n\n#### Constructors\n\nWhen a function is used as a constructor (with the [new](/en-US/docs/Web/JavaScript/Reference/Operators/new) keyword), its `this` is bound to the new object being constructed, no matter which object the constructor function is accessed on. The value of `this` becomes the value of the `new` expression unless the constructor returns another non–primitive value.\n\n```\nfunction C() {\n  this.a = 37;\n}\n\nlet o = new C();\nconsole.log(o.a); // 37\n\nfunction C2() {\n  this.a = 37;\n  return { a: 38 };\n}\n\no = new C2();\nconsole.log(o.a); // 38\n\n```\n\nIn the second example (`C2`), because an object was returned during construction, the new object that `this` was bound to gets discarded. (This essentially makes the statement `this.a = 37;` dead code. It's not exactly dead because it gets executed, but it can be eliminated with no outside effects.)\n\n#### super\n\nWhen a function is invoked in the `super.method()` form, the `this` inside the `method` function is the same value as the `this` value around the `super.method()` call, and is generally not equal to the object that `super` refers to. This is because `super.method` is not an object member access like the ones above — it's a special syntax with different binding rules. For examples, see the [super reference](/en-US/docs/Web/JavaScript/Reference/Operators/super#calling%5Fmethods%5Ffrom%5Fsuper).\n\n### [Class context](#class%5Fcontext)\n\nA [class](/en-US/docs/Web/JavaScript/Reference/Classes) can be split into two contexts: static and instance. [Constructors](/en-US/docs/Web/JavaScript/Reference/Classes/constructor), methods, and instance field initializers ([public](/en-US/docs/Web/JavaScript/Reference/Classes/Public%5Fclass%5Ffields) or [private](/en-US/docs/Web/JavaScript/Reference/Classes/Private%5Fclass%5Ffields)) belong to the instance context. [Static](/en-US/docs/Web/JavaScript/Reference/Classes/static) methods, static field initializers, and [static initialization blocks](/en-US/docs/Web/JavaScript/Reference/Classes/Static%5Finitialization%5Fblocks) belong to the static context. The `this` value is different in each context.\n\nClass constructors are always called with `new`, so their behavior is the same as [function constructors](#constructors): the `this` value is the new instance being created. Class methods behave like methods in object literals — the `this` value is the object that the method was accessed on. If the method is not transferred to another object, `this` is generally an instance of the class.\n\nStatic methods are not properties of `this`. They are properties of the class itself. Therefore, they are generally accessed on the class, and `this` is the value of the class (or a subclass). Static initialization blocks are also evaluated with `this` set to the current class.\n\nField initializers are also evaluated in the context of the class. Instance fields are evaluated with `this` set to the instance being constructed. Static fields are evaluated with `this` set to the current class. This is why arrow functions in field initializers are [bound to the class](/en-US/docs/Web/JavaScript/Reference/Functions/Arrow%5Ffunctions#cannot%5Fbe%5Fused%5Fas%5Fmethods).\n\n```\nclass C {\n  instanceField = this;\n  static staticField = this;\n}\n\nconst c = new C();\nconsole.log(c.instanceField === c); // true\nconsole.log(C.staticField === C); // true\n\n```\n\n#### Derived class constructors\n\nUnlike base class constructors, derived constructors have no initial `this` binding. Calling [super()](/en-US/docs/Web/JavaScript/Reference/Operators/super) creates a `this` binding within the constructor and essentially has the effect of evaluating the following line of code, where `Base` is the base class:\n\n```\nthis = new Base();\n\n```\n\n**Warning:** Referring to `this` before calling `super()` will throw an error.\n\nDerived classes must not return before calling `super()`, unless the constructor returns an object (so the `this` value is overridden) or the class has no constructor at all.\n\n```\nclass Base {}\nclass Good extends Base {}\nclass AlsoGood extends Base {\n  constructor() {\n    return { a: 5 };\n  }\n}\nclass Bad extends Base {\n  constructor() {}\n}\n\nnew Good();\nnew AlsoGood();\nnew Bad(); // ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor\n\n```\n\n### [Global context](#global%5Fcontext)\n\nIn the global execution context (outside of any functions or classes; may be inside [blocks](/en-US/docs/Web/JavaScript/Reference/Statements/block) or [arrow functions](#arrow%5Ffunctions) defined in the global scope), the `this` value depends on what execution context the script runs in. Like [callbacks](#callbacks), the `this` value is determined by the runtime environment (the caller).\n\nAt the top level of a script, `this` refers to [globalThis](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/globalThis) whether in strict mode or not. This is generally the same as the global object — for example, if the source is put inside an HTML [<script>](/en-US/docs/Web/HTML/Element/script) element and executed as a script, `this === window`.\n\n**Note:** `globalThis` is generally the same concept as the global object (i.e. adding properties to `globalThis` makes them global variables) — this is the case for browsers and Node — but hosts are allowed to provide a different value for `globalThis` that's unrelated to the global object.\n\n```\n// In web browsers, the window object is also the global object:\nconsole.log(this === window); // true\n\nthis.b = \"MDN\";\nconsole.log(window.b); // \"MDN\"\nconsole.log(b); // \"MDN\"\n\n```\n\nIf the source is loaded as a [module](/en-US/docs/Web/JavaScript/Guide/Modules) (for HTML, this means adding `type=\"module\"` to the `<script>` tag), `this` is always `undefined` at the top level.\n\nIf the source is executed with [eval()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/eval), `this` is the same as the enclosing context for [direct eval](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/eval#direct%5Fand%5Findirect%5Feval), or `globalThis` (as if it's run in a separate global script) for indirect eval.\n\n```\nfunction test() {\n  // Direct eval\n  console.log(eval(\"this\") === this);\n  // Indirect eval, non-strict\n  console.log(eval?.(\"this\") === globalThis);\n  // Indirect eval, strict\n  console.log(eval?.(\"'use strict'; this\") === globalThis);\n}\n\ntest.call({ name: \"obj\" }); // Logs 3 \"true\"\n\n```\n\nNote that some source code, while looking like the global scope, is actually wrapped in a function when executed. For example, Node.js CommonJS modules are wrapped in a function and executed with the `this` value set to `module.exports`. [Event handler attributes](#this%5Fin%5Finline%5Fevent%5Fhandlers) are executed with `this` set to the element they are attached to.\n\nObject literals don't create a `this` scope — only functions (methods) defined within the object do. Using `this` in an object literal inherits the value from the surrounding scope.\n\n```\nconst obj = {\n  a: this,\n};\n\nconsole.log(obj.a === window); // true\n\n```\n\n## [Examples](#examples)\n\n### [this in function contexts](#this%5Fin%5Ffunction%5Fcontexts)\n\nThe value of `this` depends on how the function is called, not how it's defined.\n\n```\n// An object can be passed as the first argument to call\n// or apply and this will be bound to it.\nconst obj = { a: \"Custom\" };\n\n// Variables declared with var become properties of the global object.\nvar a = \"Global\";\n\nfunction whatsThis() {\n  return this.a; // The value of this is dependent on how the function is called\n}\n\nwhatsThis(); // 'Global'; this in the function isn't set, so it defaults to the global/window object in non–strict mode\nobj.whatsThis = whatsThis;\nobj.whatsThis(); // 'Custom'; this in the function is set to obj\n\n```\n\nUsing `call()` and `apply()`, you can pass the value of `this` as if it's an actual parameter.\n\n```\nfunction add(c, d) {\n  return this.a + this.b + c + d;\n}\n\nconst o = { a: 1, b: 3 };\n\n// The first parameter is the object to use as 'this'; subsequent\n// parameters are used as arguments in the function call\nadd.call(o, 5, 7); // 16\n\n// The first parameter is the object to use as 'this', the second is an\n// array whose members are used as arguments in the function call\nadd.apply(o, [10, 20]); // 34\n\n```\n\n### [this and object conversion](#this%5Fand%5Fobject%5Fconversion)\n\nIn non–strict mode, if a function is called with a `this` value that's not an object, the `this` value is substituted with an object. `null` and `undefined` become `globalThis`. Primitives like `7` or `'foo'` are converted to an object using the related constructor, so the primitive number `7` is converted to a [Number](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number) wrapper class and the string `'foo'` to a [String](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String) wrapper class.\n\n```\nfunction bar() {\n  console.log(Object.prototype.toString.call(this));\n}\n\nbar.call(7); // [object Number]\nbar.call(\"foo\"); // [object String]\nbar.call(undefined); // [object Window]\n\n```\n\n### [The bind() method](#the%5Fbind%5Fmethod)\n\nCalling [f.bind(someObject)](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Function/bind) creates a new function with the same body and scope as `f`, but the value of `this` is permanently bound to the first argument of `bind`, regardless of how the function is being called.\n\n```\nfunction f() {\n  return this.a;\n}\n\nconst g = f.bind({ a: \"azerty\" });\nconsole.log(g()); // azerty\n\nconst h = g.bind({ a: \"yoo\" }); // bind only works once!\nconsole.log(h()); // azerty\n\nconst o = { a: 37, f, g, h };\nconsole.log(o.a, o.f(), o.g(), o.h()); // 37,37, azerty, azerty\n\n```\n\n### [this in arrow functions](#this%5Fin%5Farrow%5Ffunctions)\n\nArrow functions create closures over the `this` value of the enclosing execution context. In the following example, we create `obj` with a method `getThisGetter` that returns a function that returns the value of `this`. The returned function is created as an arrow function, so its `this` is permanently bound to the `this` of its enclosing function. The value of `this` inside `getThisGetter` can be set in the call, which in turn sets the return value of the returned function.\n\n```\nconst obj = {\n  getThisGetter() {\n    const getter = () => this;\n    return getter;\n  },\n};\n\n```\n\nWe can call `getThisGetter` as a method of `obj`, which sets `this` inside the body to `obj`. The returned function is assigned to a variable `fn`. Now, when calling `fn`, the value of `this` returned is still the one set by the call to `getThisGetter`, which is `obj`. If the returned function is not an arrow function, such calls would cause the `this` value to be `globalThis` or `undefined` in strict mode.\n\n```\nconst fn = obj.getThisGetter();\nconsole.log(fn() === obj); // true\n\n```\n\nBut be careful if you unbind the method of `obj` without calling it, because `getThisGetter` is still a method that has a varying `this` value. Calling `fn2()()` in the following example returns `globalThis`, because it follows the `this` from `fn2`, which is `globalThis` since it's called without being attached to any object.\n\n```\nconst fn2 = obj.getThisGetter;\nconsole.log(fn2()() === globalThis); // true\n\n```\n\nThis behavior is very useful when defining callbacks. Usually, each function expression creates its own `this` binding, which shadows the `this` value of the upper scope. Now, you can define functions as arrow functions if you don't care about the `this` value, and only create `this` bindings where you do (e.g. in class methods). See [example with setTimeout()](/en-US/docs/Web/JavaScript/Reference/Functions/Arrow%5Ffunctions#using%5Fcall%5Fbind%5Fand%5Fapply).\n\n### [this with a getter or setter](#this%5Fwith%5Fa%5Fgetter%5For%5Fsetter)\n\n`this` in getters and setters is based on which object the property is accessed on, not which object the property is defined on. A function used as getter or setter has its `this` bound to the object from which the property is being set or gotten.\n\n```\nfunction sum() {\n  return this.a + this.b + this.c;\n}\n\nconst o = {\n  a: 1,\n  b: 2,\n  c: 3,\n  get average() {\n    return (this.a + this.b + this.c) / 3;\n  },\n};\n\nObject.defineProperty(o, \"sum\", {\n  get: sum,\n  enumerable: true,\n  configurable: true,\n});\n\nconsole.log(o.average, o.sum); // 2, 6\n\n```\n\n### [As a DOM event handler](#as%5Fa%5Fdom%5Fevent%5Fhandler)\n\nWhen a function is used as an event handler, its `this` is set to the element on which the listener is placed (some browsers do not follow this convention for listeners added dynamically with methods other than [addEventListener()](/en-US/docs/Web/API/EventTarget/addEventListener \"addEventListener()\")).\n\n```\n// When called as a listener, turns the related element blue\nfunction bluify(e) {\n  // Always true\n  console.log(this === e.currentTarget);\n  // true when currentTarget and target are the same object\n  console.log(this === e.target);\n  this.style.backgroundColor = \"#A5D9F3\";\n}\n\n// Get a list of every element in the document\nconst elements = document.getElementsByTagName(\"*\");\n\n// Add bluify as a click listener so when the\n// element is clicked on, it turns blue\nfor (const element of elements) {\n  element.addEventListener(\"click\", bluify, false);\n}\n\n```\n\n### [this in inline event handlers](#this%5Fin%5Finline%5Fevent%5Fhandlers)\n\nWhen the code is called from an inline [event handler attribute](/en-US/docs/Web/HTML/Attributes#event%5Fhandler%5Fattributes), its `this` is set to the DOM element on which the listener is placed:\n\n```\n<button onclick=\"alert(this.tagName.toLowerCase());\">Show this</button>\n\n```\n\nThe above alert shows `button`. Note, however, that only the outer code has its `this` set this way:\n\n```\n<button onclick=\"alert((function () { return this; })());\">\n  Show inner this\n</button>\n\n```\n\nIn this case, the inner function's `this` isn't set, so it returns the global/window object (i.e. the default object in non–strict mode where `this` isn't set by the call).\n\n### [Bound methods in classes](#bound%5Fmethods%5Fin%5Fclasses)\n\nJust like with regular functions, the value of `this` within methods depends on how they are called. Sometimes it is useful to override this behavior so that `this` within classes always refers to the class instance. To achieve this, bind the class methods in the constructor:\n\n```\nclass Car {\n  constructor() {\n    // Bind sayBye but not sayHi to show the difference\n    this.sayBye = this.sayBye.bind(this);\n  }\n  sayHi() {\n    console.log(`Hello from ${this.name}`);\n  }\n  sayBye() {\n    console.log(`Bye from ${this.name}`);\n  }\n  get name() {\n    return \"Ferrari\";\n  }\n}\n\nclass Bird {\n  get name() {\n    return \"Tweety\";\n  }\n}\n\nconst car = new Car();\nconst bird = new Bird();\n\n// The value of 'this' in methods depends on their caller\ncar.sayHi(); // Hello from Ferrari\nbird.sayHi = car.sayHi;\nbird.sayHi(); // Hello from Tweety\n\n// For bound methods, 'this' doesn't depend on the caller\nbird.sayBye = car.sayBye;\nbird.sayBye(); // Bye from Ferrari\n\n```\n\n**Note:** Classes are always in strict mode. Calling methods with an undefined `this` will throw an error if the method tries to access properties on `this`.\n\nNote, however, that auto-bound methods suffer from the same problem as [using arrow functions for class properties](/en-US/docs/Web/JavaScript/Reference/Functions/Arrow%5Ffunctions#cannot%5Fbe%5Fused%5Fas%5Fmethods): each instance of the class will have its own copy of the method, which increases memory usage. Only use it where absolutely necessary. You can also mimic the implementation of [Intl.NumberFormat.prototype.format()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Intl/DateTimeFormat/format#using%5Fformat%5Fwith%5Fmap): define the property as a getter that returns a bound function when accessed and saves it, so that the function is only created once and only created when necessary.\n\n### [this in with statements](#this%5Fin%5Fwith%5Fstatements)\n\nAlthough [with](/en-US/docs/Web/JavaScript/Reference/Statements/with) statements are deprecated and not available in strict mode, they still serve as an exception to the normal `this` binding rules. If a function is called within a `with` statement and that function is a property of the scope object, the `this` value is set to the scope object, as if the `obj1.` prefix exists.\n\n```\nconst obj1 = {\n  foo() {\n    return this;\n  },\n};\n\nwith (obj1) {\n  console.log(foo() === obj1); // true\n}\n\n```\n\n## [Specifications](#specifications)\n\n| Specification                                                                                                                                     |\n| ------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [ECMAScript Language Specification  \\# sec-this-keyword](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-this-keyword) |\n\n## [Browser compatibility](#browser%5Fcompatibility)\n\nBCD tables only load in the browser\n\n## [See also](#see%5Falso)\n\n* [Strict mode](/en-US/docs/Web/JavaScript/Reference/Strict%5Fmode)\n* [Gentle explanation of 'this' keyword in JavaScript](https://dmitripavlutin.com/gentle-explanation-of-this-in-javascript/)\n* Getting the global context: [globalThis](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/globalThis)\n\n### Found a content problem with this page?\n\n* [Edit the page on GitHub](https://github.com/mdn/content/edit/main/files/en-us/web/javascript/reference/operators/this/index.md \"This will take you to GitHub, where you'll need to sign in first.\").\n* [Report the content issue](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fthis&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A%2A+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Foperators%2Fthis%60%0A%2A+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fthis%0A%2A+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Foperators%2Fthis%2Findex.md%0A%2A+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2F0f3738f6b1ed1aa69395ff181207186e1ad9f4d8%0A%2A+Document+last+modified%3A+2023-02-21T00%3A33%3A34.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\").\n* [View the source on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/operators/this/index.md?plain=1 \"Folder: en-us/web/javascript/reference/operators/this (Opens in a new tab)\").\nWant to get more involved? [Learn how to contribute](https://github.com/mdn/content/blob/main/CONTRIBUTING.md \"This will take you to our contribution guidelines on GitHub.\").\n\nThis page was last modified on Feb 21, 2023 by [MDN contributors](/en-US/docs/Web/JavaScript/Reference/Operators/this/contributors.txt)."}