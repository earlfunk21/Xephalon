{"lang":"Javascript","fullPath":"/Operators/import","category":"Operators","title":"import","url":"/en-US/docs/Web/JavaScript/Reference/Operators/import","markdown":"# import()\n\nThe **`import()`** syntax, commonly called _dynamic import_, is a function-like expression that allows loading an ECMAScript module asynchronously and dynamically into a potentially non-module environment.\n\nUnlike the [declaration-style counterpart](/en-US/docs/Web/JavaScript/Reference/Statements/import), dynamic imports are only evaluated when needed, and permit greater syntactic flexibility.\n\n## [Syntax](#syntax)\n\n```\nimport(moduleName)\n\n```\n\nThe `import()` call is a syntax that closely resembles a function call, but `import` itself is a keyword, not a function. You cannot alias it like `const myImport = import`, which will throw a [SyntaxError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/SyntaxError).\n\n### [Parameters](#parameters)\n\n`moduleName`\n\nThe module to import from. The evaluation of the specifier is host-specified, but always follows the same algorithm as static [import declarations](/en-US/docs/Web/JavaScript/Reference/Statements/import).\n\n### [Return value](#return%5Fvalue)\n\nReturns a promise which fulfills to a [module namespace object](#module%5Fnamespace%5Fobject): an object containing all exports from `moduleName`.\n\nThe evaluation of `import()` never synchronously throws an error. `moduleName` is [coerced to a string](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String#string%5Fcoercion), and if coercion throws, the promise is rejected with the thrown error.\n\n## [Description](#description)\n\nThe import declaration syntax (`import something from \"somewhere\"`) is static and will always result in the imported module being evaluated at load time. Dynamic imports allow one to circumvent the syntactic rigidity of import declarations and load a module conditionally or on demand. The following are some reasons why you might need to use dynamic import:\n\n* When importing statically significantly slows the loading of your code and there is a low likelihood that you will need the code you are importing, or you will not need it until a later time.\n* When importing statically significantly increases your program's memory usage and there is a low likelihood that you will need the code you are importing.\n* When the module you are importing does not exist at load time.\n* When the import specifier string needs to be constructed dynamically. (Static import only supports static specifiers.)\n* When the module being imported has side effects, and you do not want those side effects unless some condition is true. (It is recommended not to have any side effects in a module, but you sometimes cannot control this in your module dependencies.)\n* When you are in a non-module environment (for example, `eval` or a script file).\n\nUse dynamic import only when necessary. The static form is preferable for loading initial dependencies, and can benefit more readily from static analysis tools and [tree shaking](/en-US/docs/Glossary/Tree%5Fshaking).\n\nIf your file is not run as a module (if it's referenced in an HTML file, the script tag must have `type=\"module\"`), you will not be able to use static import declarations, but the asynchronous dynamic import syntax will always be available, allowing you to import modules into non-module environments.\n\n Dynamic module import is not permitted in all execution contexts. For example, `import()` can be used in the main thread, a shared worker, or a dedicated worker, but will throw if called within a [service worker](/en-US/docs/Web/API/Service%5FWorker%5FAPI) or a [worklet](/en-US/docs/Web/API/Worklet).\n\n### [Module namespace object](#module%5Fnamespace%5Fobject)\n\nA _module namespace object_ is an object that describes all exports from a module. It is a static object that is created when the module is evaluated. There are two ways to access the module namespace object of a module: through a [namespace import](/en-US/docs/Web/JavaScript/Reference/Statements/import#namespace%5Fimport) (`import * as name from moduleName`), or through the fulfillment value of a dynamic import.\n\nThe module namespace object is a [sealed](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/isSealed) object with [null prototype](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object#null-prototype%5Fobjects). This means all string keys of the object correspond to the exports of the module and there are never extra keys. All keys are [enumerable](/en-US/docs/Web/JavaScript/Enumerability%5Fand%5Fownership%5Fof%5Fproperties) in lexicographic order (i.e. the default behavior of [Array.prototype.sort()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Array/sort#description)), with the default export available as a key called `default`. In addition, the module namespace object has a [@@toStringTag](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Symbol/toStringTag) property with the value `\"Module\"`, used in [Object.prototype.toString()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/toString).\n\nThe string properties are non-configurable and writable when you use [Object.getOwnPropertyDescriptors()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/getOwnPropertyDescriptors) to get their descriptors. However, they are effectively read-only, because you cannot re-assign a property to a new value. This behavior mirrors the fact that static imports create \"[live bindings](/en-US/docs/Web/JavaScript/Reference/Statements/import#imported%5Fvalues%5Fcan%5Fonly%5Fbe%5Fmodified%5Fby%5Fthe%5Fexporter)\" â€” the values can be re-assigned by the module exporting them, but not by the module importing them. The writability of the properties reflects the possibility of the values changing, because non-configurable and non-writable properties must be constant. For example, you can re-assign the exported value of a variable, and the new value can be observed in the module namespace object.\n\nEach module specifier corresponds to a unique module namespace object, so the following is generally true:\n\n```\nimport * as mod from \"/my-module.js\";\n\nimport(\"/my-module.js\").then((mod2) => {\n  console.log(mod === mod2); // true\n});\n\n```\n\nExcept in one curious case: because a promise never fulfills to a [thenable](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise#thenables), if the `my-module.js` module exports a function called `then()`, that function will automatically get called when the dynamic import's promise is fulfilled, as part of the [promise resolution](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/Promise#resolver%5Ffunction) process.\n\n```\n// my-module.js\nexport function then(resolve) {\n  console.log(\"then() called\");\n  resolve(1);\n}\n\n```\n\n```\n// main.js\nimport * as mod from \"/my-module.js\";\n\nimport(\"/my-module.js\").then((mod2) => {\n  // Logs \"then() called\"\n  console.log(mod === mod2); // false\n});\n\n```\n\n**Warning:** Do not export a function called `then()` from a module. This will cause the module to behave differently when imported dynamically than when imported statically.\n\n## [Examples](#examples)\n\n### [Import a module for its side effects only](#import%5Fa%5Fmodule%5Ffor%5Fits%5Fside%5Feffects%5Fonly)\n\n```\n(async () => {\n  if (somethingIsTrue) {\n    // import module for side effects\n    await import(\"/modules/my-module.js\");\n  }\n})();\n\n```\n\n If your project uses packages that export ESM, you can also import them for side effects only. This will run the code in the package entry point file (and any files it imports) only.\n\n### [Importing defaults](#importing%5Fdefaults)\n\nYou need to destructure and rename the \"default\" key from the returned object.\n\n```\n(async () => {\n  if (somethingIsTrue) {\n    const {\n      default: myDefault,\n      foo,\n      bar,\n    } = await import(\"/modules/my-module.js\");\n  }\n})();\n\n```\n\n### [Importing on-demand in response to user action](#importing%5Fon-demand%5Fin%5Fresponse%5Fto%5Fuser%5Faction)\n\nThis example shows how to load functionality on to a page based on a user action, in this case a button click, and then call a function within that module. This is not the only way to implement this functionality. The `import()` function also supports `await`.\n\n```\nconst main = document.querySelector(\"main\");\nfor (const link of document.querySelectorAll(\"nav > a\")) {\n  link.addEventListener(\"click\", (e) => {\n    e.preventDefault();\n\n    import(\"/modules/my-module.js\")\n      .then((module) => {\n        module.loadPageInto(main);\n      })\n      .catch((err) => {\n        main.textContent = err.message;\n      });\n  });\n}\n\n```\n\n### [Importing different modules based on environment](#importing%5Fdifferent%5Fmodules%5Fbased%5Fon%5Fenvironment)\n\nIn processes such as server-side rendering, you may need to load different logic on server or in browser because they interact with different globals or modules (for example, browser code has access to web APIs like `document` and `navigator`, while server code has access to the server file system). You can do so through a conditional dynamic import.\n\n```\nlet myModule;\n\nif (typeof window === \"undefined\") {\n  myModule = await import(\"module-used-on-server\");\n} else {\n  myModule = await import(\"module-used-in-browser\");\n}\n\n```\n\n### [Importing modules with a non-literal specifier](#importing%5Fmodules%5Fwith%5Fa%5Fnon-literal%5Fspecifier)\n\nDynamic imports allow any expression as the module specifier, not necessarily string literals.\n\nHere, we load 10 modules, `/modules/module-0.js`, `/modules/module-1.js`, etc., in parallel, and call the `load` functions that each one exports.\n\n```\nPromise.all(\n  Array.from({ length: 10 }).map((_, index) =>\n    import(`/modules/module-${index}.js`),\n  ),\n).then((modules) => modules.forEach((module) => module.load()));\n\n```\n\n## [Specifications](#specifications)\n\n| Specification                                                                                                                                     |\n| ------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [ECMAScript Language Specification  \\# sec-import-calls](https://tc39.es/ecma262/multipage/ecmascript-language-expressions.html#sec-import-calls) |\n\n## [Browser compatibility](#browser%5Fcompatibility)\n\nBCD tables only load in the browser\n\n## [See also](#see%5Falso)\n\n* [import declaration](/en-US/docs/Web/JavaScript/Reference/Statements/import)\n\n### Found a content problem with this page?\n\n* [Edit the page on GitHub](https://github.com/mdn/content/edit/main/files/en-us/web/javascript/reference/operators/import/index.md \"This will take you to GitHub, where you'll need to sign in first.\").\n* [Report the content issue](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fimport&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A%2A+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Foperators%2Fimport%60%0A%2A+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FOperators%2Fimport%0A%2A+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Foperators%2Fimport%2Findex.md%0A%2A+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2F0fd3c765308cac8dc9bfd850afd4b468103ade65%0A%2A+Document+last+modified%3A+2023-03-27T15%3A19%3A54.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\").\n* [View the source on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/operators/import/index.md?plain=1 \"Folder: en-us/web/javascript/reference/operators/import (Opens in a new tab)\").\nWant to get more involved? [Learn how to contribute](https://github.com/mdn/content/blob/main/CONTRIBUTING.md \"This will take you to our contribution guidelines on GitHub.\").\n\nThis page was last modified on Mar 27, 2023 by [MDN contributors](/en-US/docs/Web/JavaScript/Reference/Operators/import/contributors.txt)."}