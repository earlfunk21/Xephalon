{"lang":"Javascript","fullPath":"/Classes/Public_class_fields","category":"Classes","title":"Public_class_fields","url":"/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields","markdown":"# Public class fields\n\nBoth static and instance **public fields** are writable, enumerable, and configurable properties. As such, unlike their private counterparts, they participate in prototype inheritance.\n\n## [Syntax](#syntax)\n\n```\nclass ClassWithField {\n  instanceField;\n  instanceFieldWithInitializer = \"instance field\";\n  static staticField;\n  static staticFieldWithInitializer = \"static field\";\n}\n\n```\n\nThere are some additional syntax restrictions:\n\n* The name of a static property (field or method) cannot be `prototype`.\n* The name of a class field (static or instance) cannot be `constructor`.\n\n## [Description](#description)\n\nThis page introduces public instance fields in detail.\n\n* For public static fields, see [static](/en-US/docs/Web/JavaScript/Reference/Classes/static).\n* For private fields, see [private class features](/en-US/docs/Web/JavaScript/Reference/Classes/Private%5Fclass%5Ffields).\n* For public methods, see [method definitions](/en-US/docs/Web/JavaScript/Reference/Functions/Method%5Fdefinitions).\n* For public accessors, see [getter](/en-US/docs/Web/JavaScript/Reference/Functions/get) and [setter](/en-US/docs/Web/JavaScript/Reference/Functions/set).\n\nPublic instance fields exist on every created instance of a class. By declaring a public field, you can ensure the field is always present, and the class definition is more self-documenting.\n\nPublic instance fields are added to the instance either at construction time in the base class (before the constructor body runs), or just after `super()` returns in a subclass. Fields without initializers are initialized to `undefined`. Like properties, field names may be computed.\n\n```\nconst PREFIX = \"prefix\";\n\nclass ClassWithField {\n  field;\n  fieldWithInitializer = \"instance field\";\n  [`${PREFIX}Field`] = \"prefixed field\";\n}\n\nconst instance = new ClassWithField();\nconsole.log(Object.hasOwn(instance, \"field\")); // true\nconsole.log(instance.field); // undefined\nconsole.log(instance.fieldWithInitializer); // \"instance field\"\nconsole.log(instance.prefixField); // \"prefixed field\"\n\n```\n\nComputed field names are only evaluated once, at [class definition time](/en-US/docs/Web/JavaScript/Reference/Classes#evaluation%5Forder). This means that each class always has a fixed set of field names, and two instances cannot have different field names via computed names. The `this` value in the computed expression is the `this` surrounding the class definition, and referring to the class's name is a [ReferenceError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/ReferenceError) because the class is not initialized yet. [await](/en-US/docs/Web/JavaScript/Reference/Operators/await) and [yield](/en-US/docs/Web/JavaScript/Reference/Operators/yield) work as expected in this expression.\n\n```\nclass C {\n  [Math.random()] = 1;\n}\n\nconsole.log(new C());\nconsole.log(new C());\n// Both instances have the same field name\n\n```\n\nIn the field initializer, [this](/en-US/docs/Web/JavaScript/Reference/Operators/this) refers to the class instance under construction, and [super](/en-US/docs/Web/JavaScript/Reference/Operators/super) refers to the `prototype` property of the base class, which contains the base class's instance methods, but not its instance fields.\n\n```\nclass Base {\n  baseField = \"base field\";\n  anotherBaseField = this.baseField;\n  baseMethod() {\n    return \"base method output\";\n  }\n}\n\nclass Derived extends Base {\n  subField = super.baseMethod();\n}\n\nconst base = new Base();\nconst sub = new Derived();\n\nconsole.log(base.anotherBaseField); // \"base field\"\n\nconsole.log(sub.subField); // \"base method output\"\n\n```\n\nThe field initializer expression is evaluated each time a new instance is created. (Because the `this` value is different for each instance, the initializer expression can access instance-specific properties.)\n\n```\nclass C {\n  obj = {};\n}\n\nconst instance1 = new C();\nconst instance2 = new C();\nconsole.log(instance1.obj === instance2.obj); // false\n\n```\n\nThe expression is evaluated synchronously. You cannot use [Operators/await](/en-US/docs/Web/JavaScript/Reference/Operators/await) or [Operators/yield](/en-US/docs/Web/JavaScript/Reference/Operators/yield) in the initializer expression. (Think of the initializer expression as being implicitly wrapped in a function.)\n\nBecause instance fields of a class are added before the respective constructor runs, you can access the fields' values within the constructor. However, because instance fields of a derived class are defined after `super()` returns, the base class's constructor does not have access to the derived class's fields.\n\n```\nclass Base {\n  constructor() {\n    console.log(\"Base constructor:\", this.field);\n  }\n}\n\nclass Derived extends Base {\n  field = 1;\n  constructor() {\n    super();\n    console.log(\"Derived constructor:\", this.field);\n    this.field = 2;\n  }\n}\n\nconst instance = new Derived();\n// Base constructor: undefined\n// Derived constructor: 1\nconsole.log(instance.field); // 2\n\n```\n\nFields are added one-by-one. Field initializers can refer to field values above it, but not below it. All instance and static methods are added beforehand and can be accessed, although calling them may not behave as expected if they refer to fields below the one being initialized.\n\n```\nclass C {\n  a = 1;\n  b = this.c;\n  c = this.a + 1;\n  d = this.c + 1;\n}\n\nconst instance = new C();\nconsole.log(instance.d); // 3\nconsole.log(instance.b); // undefined\n\n```\n\n**Note:** This is more important with [private fields](/en-US/docs/Web/JavaScript/Reference/Classes/Private%5Fclass%5Ffields), because accessing a non-initialized private field throws a [TypeError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/TypeError), even if the private field is declared below. (If the private field is not declared, it would be an early [SyntaxError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/SyntaxError).)\n\nBecause class fields are added using the [\\[\\[DefineOwnProperty\\]\\]](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Proxy/Proxy/defineProperty) semantic (which is essentially [Object.defineProperty()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/defineProperty)), field declarations in derived classes do not invoke setters in the base class. This behavior differs from using `this.field = â€¦` in the constructor.\n\n```\nclass Base {\n  set field(val) {\n    console.log(val);\n  }\n}\n\nclass DerivedWithField extends Base {\n  field = 1;\n}\n\nconst instance = new DerivedWithField(); // No log\n\nclass DerivedWithConstructor extends Base {\n  constructor() {\n    super();\n    this.field = 1;\n  }\n}\n\nconst instance2 = new DerivedWithConstructor(); // Logs 1\n\n```\n\n**Note:** Before the class fields specification was finalized with the `[[DefineOwnProperty]]` semantic, most transpilers, including [Babel](https://babeljs.io/) and [tsc](https://www.typescriptlang.org/), transformed class fields to the `DerivedWithConstructor` form, which has caused subtle bugs after class fields were standardized.\n\n## [Examples](#examples)\n\n### [Using class fields](#using%5Fclass%5Ffields)\n\nClass fields cannot depend on arguments of the constructor, so field initializers usually evaluate to the same value for each instance (unless the same expression can evaluate to different values each time, such as [Date.now()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Date/now) or object initializers).\n\n```\nclass Person {\n  name = nameArg; // nameArg is out of scope of the constructor\n  constructor(nameArg) {}\n}\n\n```\n\n```\nclass Person {\n  // All instances of Person will have the same name\n  name = \"Dragomir\";\n}\n\n```\n\nHowever, even declaring an empty class field is beneficial, because it indicates the existence of the field, which allows type checkers as well as human readers to statically analyze the shape of the class.\n\n```\nclass Person {\n  name;\n  age;\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n}\n\n```\n\nThe code above seems repetitive, but consider the case where `this` is dynamically mutated: the explicit field declaration makes it clear which fields will definitely be present on the instance.\n\n```\nclass Person {\n  name;\n  age;\n  constructor(properties) {\n    Object.assign(this, properties);\n  }\n}\n\n```\n\nBecause initializers are evaluated after the base class has executed, you can access properties created by the base class constructor.\n\n```\nclass Person {\n  name;\n  age;\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n}\n\nclass Professor extends Person {\n  name = `Professor ${this.name}`;\n}\n\nconsole.log(new Professor(\"Radev\", 54).name); // \"Professor Radev\"\n\n```\n\n## [Specifications](#specifications)\n\n| Specification                                                                                                                                                       |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [ECMAScript Language Specification  \\# prod-FieldDefinition](https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#prod-FieldDefinition) |\n\n## [Browser compatibility](#browser%5Fcompatibility)\n\nBCD tables only load in the browser\n\n## [See also](#see%5Falso)\n\n* [Using classes](/en-US/docs/Web/JavaScript/Guide/Using%5Fclasses)\n* [Classes](/en-US/docs/Web/JavaScript/Reference/Classes)\n* [Private class features](/en-US/docs/Web/JavaScript/Reference/Classes/Private%5Fclass%5Ffields)\n* [class](/en-US/docs/Web/JavaScript/Reference/Statements/class)\n* [The semantics of all JS class elements](https://rfrn.org/~shu/2018/05/02/the-semantics-of-all-js-class-elements.html) by Shu-yu Guo (May 2, 2018)\n* [Public and private class fields](https://v8.dev/features/class-fields) on v8.dev (December 13, 2018)\n\n### Found a content problem with this page?\n\n* [Edit the page on GitHub](https://github.com/mdn/content/edit/main/files/en-us/web/javascript/reference/classes/public%5Fclass%5Ffields/index.md \"This will take you to GitHub, where you'll need to sign in first.\").\n* [Report the content issue](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FClasses%2FPublic%5Fclass%5Ffields&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A%2A+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Fclasses%2Fpublic%5Fclass%5Ffields%60%0A%2A+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FClasses%2FPublic%5Fclass%5Ffields%0A%2A+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Fclasses%2Fpublic%5Fclass%5Ffields%2Findex.md%0A%2A+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2F47776bb0037d2dbd61e3eece2163acd8631d5761%0A%2A+Document+last+modified%3A+2023-04-19T04%3A54%3A15.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\").\n* [View the source on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/classes/public%5Fclass%5Ffields/index.md?plain=1 \"Folder: en-us/web/javascript/reference/classes/public_class_fields (Opens in a new tab)\").\nWant to get more involved? [Learn how to contribute](https://github.com/mdn/content/blob/main/CONTRIBUTING.md \"This will take you to our contribution guidelines on GitHub.\").\n\nThis page was last modified on Apr 19, 2023 by [MDN contributors](/en-US/docs/Web/JavaScript/Reference/Classes/Public%5Fclass%5Ffields/contributors.txt)."}