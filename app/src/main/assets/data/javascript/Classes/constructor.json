{"lang":"Javascript","fullPath":"/Classes/constructor","category":"Classes","title":"constructor","url":"/en-US/docs/Web/JavaScript/Reference/Classes/constructor","markdown":"# constructor\n\nThe **`constructor`** method is a special method of a [class](/en-US/docs/Web/JavaScript/Reference/Classes) for creating and initializing an object instance of that class.\n\n**Note:** This page introduces the `constructor` syntax. For the `constructor` property present on all objects, see [Object.prototype.constructor](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/constructor).\n\n## [Try it](#try%5Fit)\n\n## [Syntax](#syntax)\n\n```\nconstructor() { /* … */ }\nconstructor(argument0) { /* … */ }\nconstructor(argument0, argument1) { /* … */ }\nconstructor(argument0, argument1, /* … ,*/ argumentN) { /* … */ }\n\n```\n\nThere are some additional syntax restrictions:\n\n* A class method called `constructor` cannot be a [getter](/en-US/docs/Web/JavaScript/Reference/Functions/get), [setter](/en-US/docs/Web/JavaScript/Reference/Functions/set), [async](/en-US/docs/Web/JavaScript/Reference/Statements/async%5Ffunction), or [generator](/en-US/docs/Web/JavaScript/Reference/Statements/function%2A).\n* A class cannot have more than one `constructor` method.\n\n## [Description](#description)\n\nA constructor enables you to provide any custom initialization that must be done before any other methods can be called on an instantiated object.\n\n```\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n\n  introduce() {\n    console.log(`Hello, my name is ${this.name}`);\n  }\n}\n\nconst otto = new Person(\"Otto\");\n\notto.introduce(); // Hello, my name is Otto\n\n```\n\n If you don't provide your own constructor, then a default constructor will be supplied for you. If your class is a base class, the default constructor is empty:\n\n```\nconstructor() {}\n\n```\n\nIf your class is a derived class, the default constructor calls the parent constructor, passing along any arguments that were provided:\n\n```\nconstructor(...args) {\n  super(...args);\n}\n\n```\n\n**Note:** The difference between an explicit constructor like the one above and the default constructor is that the latter doesn't actually invoke [the array iterator](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Array/@@iterator) through [argument spreading](/en-US/docs/Web/JavaScript/Reference/Operators/Spread%5Fsyntax).\n\nThat enables code like this to work:\n\n```\nclass ValidationError extends Error {\n  printCustomerMessage() {\n    return `Validation failed :-( (details: ${this.message})`;\n  }\n}\n\ntry {\n  throw new ValidationError(\"Not a valid phone number\");\n} catch (error) {\n  if (error instanceof ValidationError) {\n    console.log(error.name); // This is Error instead of ValidationError!\n    console.log(error.printCustomerMessage());\n  } else {\n    console.log(\"Unknown error\", error);\n    throw error;\n  }\n}\n\n```\n\n The `ValidationError` class doesn't need an explicit constructor, because it doesn't need to do any custom initialization. The default constructor then takes care of initializing the parent `Error` from the argument it is given.\n\n However, if you provide your own constructor, and your class derives from some parent class, then you must explicitly call the parent class constructor using [super()](/en-US/docs/Web/JavaScript/Reference/Operators/super). For example:\n\n```\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message); // call parent class constructor\n    this.name = \"ValidationError\";\n    this.code = \"42\";\n  }\n\n  printCustomerMessage() {\n    return `Validation failed :-( (details: ${this.message}, code: ${this.code})`;\n  }\n}\n\ntry {\n  throw new ValidationError(\"Not a valid phone number\");\n} catch (error) {\n  if (error instanceof ValidationError) {\n    console.log(error.name); // Now this is ValidationError!\n    console.log(error.printCustomerMessage());\n  } else {\n    console.log(\"Unknown error\", error);\n    throw error;\n  }\n}\n\n```\n\nUsing [new](/en-US/docs/Web/JavaScript/Reference/Operators/new) on a class goes through the following steps:\n\n1. (If it's a derived class) The `constructor` body before the `super()` call is evaluated. This part should not access `this` because it's not yet initialized.\n2. (If it's a derived class) The `super()` call is evaluated, which initializes the parent class through the same process.\n3. The current class's [fields](/en-US/docs/Web/JavaScript/Reference/Classes/Public%5Fclass%5Ffields) are initialized.\n4. The `constructor` body after the `super()` call (or the entire body, if it's a base class) is evaluated.\n\nWithin the `constructor` body, you can access the object being created through [this](/en-US/docs/Web/JavaScript/Reference/Operators/this) and access the class that is called with [new](/en-US/docs/Web/JavaScript/Reference/Operators/new) through [new.target](/en-US/docs/Web/JavaScript/Reference/Operators/new.target). Note that methods (including [getters](/en-US/docs/Web/JavaScript/Reference/Functions/get) and [setters](/en-US/docs/Web/JavaScript/Reference/Functions/set)) and the [prototype chain](/en-US/docs/Web/JavaScript/Inheritance%5Fand%5Fthe%5Fprototype%5Fchain) are already initialized on `this` before the `constructor` is executed, so you can even access methods of the subclass from the constructor of the superclass. However, if those methods use `this`, the `this` will not have been fully initialized yet. This means reading public fields of the derived class will result in `undefined`, while reading private fields will result in a `TypeError`.\n\n```\nnew (class C extends class B {\n  constructor() {\n    console.log(this.foo());\n  }\n} {\n  #a = 1;\n  foo() {\n    return this.#a; // TypeError: Cannot read private member #a from an object whose class did not declare it\n    // It's not really because the class didn't declare it,\n    // but because the private field isn't initialized yet\n    // when the superclass constructor is running\n  }\n})();\n\n```\n\nThe `constructor` method may have a return value. While the base class may return anything from its constructor, the derived class must return an object or `undefined`, or a [TypeError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/TypeError) will be thrown.\n\n```\nclass ParentClass {\n  constructor() {\n    return 1;\n  }\n}\n\nconsole.log(new ParentClass()); // ParentClass {}\n// The return value is ignored because it's not an object\n// This is consistent with function constructors\n\nclass ChildClass extends ParentClass {\n  constructor() {\n    return 1;\n  }\n}\n\nconsole.log(new ChildClass()); // TypeError: Derived constructors may only return object or undefined\n\n```\n\nIf the parent class constructor returns an object, that object will be used as the `this` value on which [class fields](/en-US/docs/Web/JavaScript/Reference/Classes/Public%5Fclass%5Ffields) of the derived class will be defined. This trick is called [\"return overriding\"](/en-US/docs/Web/JavaScript/Reference/Classes/Private%5Fclass%5Ffields#returning%5Foverriding%5Fobject), which allows a derived class's fields (including [private](/en-US/docs/Web/JavaScript/Reference/Classes/Private%5Fclass%5Ffields) ones) to be defined on unrelated objects.\n\nThe `constructor` follows normal [method](/en-US/docs/Web/JavaScript/Reference/Functions/Method%5Fdefinitions) syntax, so [parameter default values](/en-US/docs/Web/JavaScript/Reference/Functions/Default%5Fparameters), [rest parameters](/en-US/docs/Web/JavaScript/Reference/Functions/rest%5Fparameters), etc. can all be used.\n\n```\nclass Person {\n  constructor(name = \"Anonymous\") {\n    this.name = name;\n  }\n  introduce() {\n    console.log(`Hello, my name is ${this.name}`);\n  }\n}\n\nconst person = new Person();\nperson.introduce(); // Hello, my name is Anonymous\n\n```\n\nThe constructor must be a literal name. Computed properties cannot become constructors.\n\n```\nclass Foo {\n  // This is a computed property. It will not be picked up as a constructor.\n  [\"constructor\"]() {\n    console.log(\"called\");\n    this.a = 1;\n  }\n}\n\nconst foo = new Foo(); // No log\nconsole.log(foo); // Foo {}\nfoo.constructor(); // Logs \"called\"\nconsole.log(foo); // Foo { a: 1 }\n\n```\n\nAsync methods, generator methods, accessors, and class fields are forbidden from being called `constructor`. Private names cannot be called `#constructor`. Any member named `constructor` must be a plain method.\n\n## [Examples](#examples)\n\n### [Using the constructor](#using%5Fthe%5Fconstructor)\n\nThis code snippet is taken from the [classes sample](https://github.com/GoogleChrome/samples/blob/gh-pages/classes-es6/index.html) ([live demo](https://googlechrome.github.io/samples/classes-es6/index.html)).\n\n```\nclass Square extends Polygon {\n  constructor(length) {\n    // Here, it calls the parent class' constructor with lengths\n    // provided for the Polygon's width and height\n    super(length, length);\n    // NOTE: In derived classes, `super()` must be called before you\n    // can use `this`. Leaving this out will cause a ReferenceError.\n    this.name = \"Square\";\n  }\n\n  get area() {\n    return this.height * this.width;\n  }\n\n  set area(value) {\n    this.height = value ** 0.5;\n    this.width = value ** 0.5;\n  }\n}\n\n```\n\n### [Calling super in a constructor bound to a different prototype](#calling%5Fsuper%5Fin%5Fa%5Fconstructor%5Fbound%5Fto%5Fa%5Fdifferent%5Fprototype)\n\n`super()` calls the constructor that's the prototype of the current class. If you change the prototype of the current class itself, `super()` will call the constructor that's the new prototype. Changing the prototype of the current class's `prototype` property doesn't affect which constructor `super()` calls.\n\n```\nclass Polygon {\n  constructor() {\n    this.name = \"Polygon\";\n  }\n}\n\nclass Rectangle {\n  constructor() {\n    this.name = \"Rectangle\";\n  }\n}\n\nclass Square extends Polygon {\n  constructor() {\n    super();\n  }\n}\n\n// Make Square extend Rectangle (which is a base class) instead of Polygon\nObject.setPrototypeOf(Square, Rectangle);\n\nconst newInstance = new Square();\n\n// newInstance is still an instance of Polygon, because we didn't\n// change the prototype of Square.prototype, so the prototype chain\n// of newInstance is still\n//   newInstance --> Square.prototype --> Polygon.prototype\nconsole.log(newInstance instanceof Polygon); // true\nconsole.log(newInstance instanceof Rectangle); // false\n\n// However, because super() calls Rectangle as constructor, the name property\n// of newInstance is initialized with the logic in Rectangle\nconsole.log(newInstance.name); // Rectangle\n\n```\n\n## [Specifications](#specifications)\n\n| Specification                                                                                                                                                                                           |\n| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [ECMAScript Language Specification  \\# sec-static-semantics-constructormethod](https://tc39.es/ecma262/multipage/ecmascript-language-functions-and-classes.html#sec-static-semantics-constructormethod) |\n\n## [Browser compatibility](#browser%5Fcompatibility)\n\nBCD tables only load in the browser\n\n## [See also](#see%5Falso)\n\n* [Using classes](/en-US/docs/Web/JavaScript/Guide/Using%5Fclasses)\n* [Classes](/en-US/docs/Web/JavaScript/Reference/Classes)\n* [Static initialization blocks](/en-US/docs/Web/JavaScript/Reference/Classes/Static%5Finitialization%5Fblocks)\n* [class](/en-US/docs/Web/JavaScript/Reference/Statements/class)\n* [super()](/en-US/docs/Web/JavaScript/Reference/Operators/super)\n* [Object.prototype.constructor](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/constructor)\n\n### Found a content problem with this page?\n\n* [Edit the page on GitHub](https://github.com/mdn/content/edit/main/files/en-us/web/javascript/reference/classes/constructor/index.md \"This will take you to GitHub, where you'll need to sign in first.\").\n* [Report the content issue](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FClasses%2Fconstructor&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A%2A+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Fclasses%2Fconstructor%60%0A%2A+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FClasses%2Fconstructor%0A%2A+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Fclasses%2Fconstructor%2Findex.md%0A%2A+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Fa62ca04161a2ee84e0d150379cd6594b1a3879a5%0A%2A+Document+last+modified%3A+2023-04-14T13%3A04%3A47.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\").\n* [View the source on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/classes/constructor/index.md?plain=1 \"Folder: en-us/web/javascript/reference/classes/constructor (Opens in a new tab)\").\nWant to get more involved? [Learn how to contribute](https://github.com/mdn/content/blob/main/CONTRIBUTING.md \"This will take you to our contribution guidelines on GitHub.\").\n\nThis page was last modified on Apr 14, 2023 by [MDN contributors](/en-US/docs/Web/JavaScript/Reference/Classes/constructor/contributors.txt)."}