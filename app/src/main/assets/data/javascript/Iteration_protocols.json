{"lang":"Javascript","fullPath":"/Iteration_protocols","category":"","title":"Iteration_protocols","url":"/en-US/docs/Web/JavaScript/Reference/Iteration_protocols","markdown":"# Iteration protocols\n\n**Iteration protocols** aren't new built-ins or syntax, but _protocols_. These protocols can be implemented by any object by following some conventions.\n\nThere are two protocols: The [iterable protocol](#the%5Fiterable%5Fprotocol) and the [iterator protocol](#the%5Fiterator%5Fprotocol).\n\n## [The iterable protocol](#the%5Fiterable%5Fprotocol)\n\n**The iterable protocol** allows JavaScript objects to define or customize their iteration behavior, such as what values are looped over in a [for...of](/en-US/docs/Web/JavaScript/Reference/Statements/for...of) construct. Some built-in types are [built-in iterables](#built-in%5Fiterables) with a default iteration behavior, such as [Array](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Array) or [Map](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Map), while other types (such as [Object](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object)) are not.\n\nIn order to be **iterable**, an object must implement the **`@@iterator`** method, meaning that the object (or one of the objects up its [prototype chain](/en-US/docs/Web/JavaScript/Inheritance%5Fand%5Fthe%5Fprototype%5Fchain)) must have a property with a `@@iterator` key which is available via constant [Symbol.iterator](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Symbol/iterator):\n\n`[Symbol.iterator]`\n\nA zero-argument function that returns an object, conforming to the [iterator protocol](#the%5Fiterator%5Fprotocol).\n\nWhenever an object needs to be iterated (such as at the beginning of a [for...of](/en-US/docs/Web/JavaScript/Reference/Statements/for...of) loop), its `@@iterator` method is called with no arguments, and the returned **iterator** is used to obtain the values to be iterated.\n\nNote that when this zero-argument function is called, it is invoked as a method on the iterable object. Therefore inside of the function, the `this` keyword can be used to access the properties of the iterable object, to decide what to provide during the iteration.\n\nThis function can be an ordinary function, or it can be a generator function, so that when invoked, an iterator object is returned. Inside of this generator function, each entry can be provided by using `yield`.\n\n## [The iterator protocol](#the%5Fiterator%5Fprotocol)\n\n**The iterator protocol** defines a standard way to produce a sequence of values (either finite or infinite), and potentially a return value when all values have been generated.\n\nAn object is an iterator when it implements a **`next()`** method with the following semantics:\n\n`next()`\n\nA function that accepts zero or one argument and returns an object conforming to the `IteratorResult` interface (see below). If a non-object value gets returned (such as `false` or `undefined`) when a built-in language feature (such as `for...of`) is using the iterator, a [TypeError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/TypeError) (`\"iterator.next() returned a non-object value\"`) will be thrown.\n\nAll iterator protocol methods (`next()`, `return()`, and `throw()`) are expected to return an object implementing the `IteratorResult` interface. It must have the following properties:\n\n`done` Optional\n\nA boolean that's `false` if the iterator was able to produce the next value in the sequence. (This is equivalent to not specifying the `done` property altogether.)\n\nHas the value `true` if the iterator has completed its sequence. In this case, `value` optionally specifies the return value of the iterator.\n\n`value` Optional\n\nAny JavaScript value returned by the iterator. Can be omitted when `done` is `true`.\n\nIn practice, neither property is strictly required; if an object without either property is returned, it's effectively equivalent to `{ done: false, value: undefined }`.\n\nIf an iterator returns a result with `done: true`, any subsequent calls to `next()` are expected to return `done: true` as well, although this is not enforced on the language level.\n\nThe `next` method can receive a value which will be made available to the method body. No built-in language feature will pass any value. The value passed to the `next` method of [generators](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Generator) will become the value of the corresponding `yield` expression.\n\nOptionally, the iterator can also implement the **`return(value)`** and **`throw(exception)`** methods, which, when called, tells the iterator that the caller is done with iterating it and can perform any necessary cleanup (such as closing database connection).\n\n`return(value)` Optional\n\nA function that accepts zero or one argument and returns an object conforming to the `IteratorResult` interface, typically with `value` equal to the `value` passed in and `done` equal to `true`. Calling this method tells the iterator that the caller does not intend to make any more `next()` calls and can perform any cleanup actions.\n\n`throw(exception)` Optional\n\nA function that accepts zero or one argument and returns an object conforming to the `IteratorResult` interface, typically with `done` equal to `true`. Calling this method tells the iterator that the caller detects an error condition, and `exception` is typically an [Error](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Error) instance.\n\n**Note:** It is not possible to know reflectively (i.e. without actually calling `next()` and validating the returned result) whether a particular object implements the iterator protocol.\n\nIt is very easy to make an iterator also iterable: just implement an `[@@iterator]()` method that returns `this`.\n\n```\n// Satisfies both the Iterator Protocol and Iterable\nconst myIterator = {\n  next() {\n    // ...\n  },\n  [Symbol.iterator]() {\n    return this;\n  },\n};\n\n```\n\nSuch object is called an _iterable iterator_. Doing so allows an iterator to be consumed by the various syntaxes expecting iterables — therefore, it is seldom useful to implement the Iterator Protocol without also implementing Iterable. (In fact, almost all syntaxes and APIs expect _iterables_, not _iterators_.) The [generator object](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Generator) is an example:\n\n```\nconst aGeneratorObject = (function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n})();\n\nconsole.log(typeof aGeneratorObject.next);\n// \"function\" — it has a next method (which returns the right result), so it's an iterator\n\nconsole.log(typeof aGeneratorObject[Symbol.iterator]);\n// \"function\" — it has an @@iterator method (which returns the right iterator), so it's an iterable\n\nconsole.log(aGeneratorObject[Symbol.iterator]() === aGeneratorObject);\n// true — its @@iterator method returns itself (an iterator), so it's an iterable iterator\n\n```\n\nAll built-in iterators inherit from [Iterator.prototype](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Iterator), which implements the `[@@iterator]()` method as returning `this`, so that built-in iterators are also iterable.\n\nHowever, when possible, it's better for `iterable[Symbol.iterator]` to return different iterators that always start from the beginning, like [Set.prototype\\[@@iterator\\]()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Set/@@iterator) does.\n\n## [The async iterator and async iterable protocols](#the%5Fasync%5Fiterator%5Fand%5Fasync%5Fiterable%5Fprotocols)\n\nThere are another pair of protocols used for async iteration, named **async iterator** and **async iterable** protocols. They have very similar interfaces compared to the iterable and iterator protocols, except that each return value from the calls to the iterator methods is wrapped in a promise.\n\nAn object implements the async iterable protocol when it implements the following methods:\n\n[\\[Symbol.asyncIterator\\]](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Symbol/asyncIterator)\n\nA zero-argument function that returns an object, conforming to the async iterator protocol.\n\nAn object implements the async iterator protocol when it implements the following methods:\n\n`next()`\n\nA function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the `IteratorResult` interface, and the properties have the same semantics as those of the sync iterator's.\n\n`return(value)` Optional\n\nA function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the `IteratorResult` interface, and the properties have the same semantics as those of the sync iterator's.\n\n`throw(exception)` Optional\n\nA function that accepts zero or one argument and returns a promise. The promise fulfills to an object conforming to the `IteratorResult` interface, and the properties have the same semantics as those of the sync iterator's.\n\n## [Interactions between the language and iteration protocols](#interactions%5Fbetween%5Fthe%5Flanguage%5Fand%5Fiteration%5Fprotocols)\n\nThe language specifies APIs that either produce or consume iterables and iterators.\n\n### [Built-in iterables](#built-in%5Fiterables)\n\n[String](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String), [Array](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Array), [TypedArray](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/TypedArray), [Map](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Map), [Set](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Set), and [Segments](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Intl/Segmenter/segment/Segments) (returned by [Intl.Segmenter.prototype.segment()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Intl/Segmenter/segment)) are all built-in iterables, because each of their `prototype` objects implements an `@@iterator` method. In addition, the [arguments](/en-US/docs/Web/JavaScript/Reference/Functions/arguments) object and some DOM collection types such as [NodeList](/en-US/docs/Web/API/NodeList) are also iterables.[ReadableStream](/en-US/docs/Web/API/ReadableStream) is the only built-in async iterable at the time of writing.\n\n[Generator functions](/en-US/docs/Web/JavaScript/Reference/Statements/function%2A) return [generator objects](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Generator), which are iterable iterators. [Async generator functions](/en-US/docs/Web/JavaScript/Reference/Statements/async%5Ffunction%2A) return [async generator objects](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/AsyncGenerator), which are async iterable iterators.\n\nThe iterators returned from built-in iterables actually all inherit from a common class [Iterator](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Iterator) (currently unexposed), which implements the aforementioned `[Symbol.iterator]() { return this; }` method, making them all iterable iterators. In the future, these built-in iterators may have additional [helper methods](https://github.com/tc39/proposal-iterator-helpers) in addition to the `next()` method required by the iterator protocol. You can inspect an iterator's prototype chain by logging it in a graphical console.\n\nconsole.log([][Symbol.iterator]());\n\nArray Iterator {}\n  [[Prototype]]: Array Iterator     ==> This is the prototype shared by all array iterators\n    next: ƒ next()\n    Symbol(Symbol.toStringTag): \"Array Iterator\"\n    [[Prototype]]: Object           ==> This is the prototype shared by all built-in iterators\n      Symbol(Symbol.iterator): ƒ [Symbol.iterator]()\n      [[Prototype]]: Object         ==> This is Object.prototype\n\n### [Built-in APIs accepting iterables](#built-in%5Fapis%5Faccepting%5Fiterables)\n\nThere are many APIs that accept iterables. Some examples include:\n\n* [Map()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Map/Map)\n* [WeakMap()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/WeakMap/WeakMap)\n* [Set()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Set/Set)\n* [WeakSet()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/WeakSet/WeakSet)\n* [Promise.all()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/all)\n* [Promise.allSettled()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/allSettled)\n* [Promise.race()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/race)\n* [Promise.any()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/any)\n* [Array.from()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Array/from)\n\n```\nconst myObj = {};\n\nnew WeakSet(\n  (function* () {\n    yield {};\n    yield myObj;\n    yield {};\n  })(),\n).has(myObj); // true\n\n```\n\n### [Syntaxes expecting iterables](#syntaxes%5Fexpecting%5Fiterables)\n\nSome statements and expressions expect iterables, for example the [for...of](/en-US/docs/Web/JavaScript/Reference/Statements/for...of) loops, [array and parameter spreading](/en-US/docs/Web/JavaScript/Reference/Operators/Spread%5Fsyntax), [yield\\*](/en-US/docs/Web/JavaScript/Reference/Operators/yield%2A), and [array destructuring](/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring%5Fassignment):\n\n```\nfor (const value of [\"a\", \"b\", \"c\"]) {\n  console.log(value);\n}\n// \"a\"\n// \"b\"\n// \"c\"\n\nconsole.log([...\"abc\"]); // [\"a\", \"b\", \"c\"]\n\nfunction* gen() {\n  yield* [\"a\", \"b\", \"c\"];\n}\n\nconsole.log(gen().next()); // { value: \"a\", done: false }\n\n[a, b, c] = new Set([\"a\", \"b\", \"c\"]);\nconsole.log(a); // \"a\"\n\n```\n\nWhen built-in syntaxes are iterating an iterator, and the last result's `done` is `false` (i.e. the iterator is able to produce more values) but no more values are needed, the `return` method will get called if present. This can happen, for example, if a `break` or `return` is encountered in a `for...of` loop, or if all identifiers are already bound in an array destructuring.\n\n```\nconst obj = {\n  [Symbol.iterator]() {\n    let i = 0;\n    return {\n      next() {\n        i++;\n        console.log(\"Returning\", i);\n        if (i === 3) return { done: true, value: i };\n        return { done: false, value: i };\n      },\n      return() {\n        console.log(\"Closing\");\n        return { done: true };\n      },\n    };\n  },\n};\n\nconst [b] = obj;\n// Returning 1\n// Closing\n\nconst [a, b, c] = obj;\n// Returning 1\n// Returning 2\n// Returning 3\n// Already reached the end (the last call returned `done: true`),\n// so `return` is not called\n\nfor (const b of obj) {\n  break;\n}\n// Returning 1\n// Closing\n\n```\n\nThe [for await...of](/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of) loop and [yield\\*](/en-US/docs/Web/JavaScript/Reference/Operators/yield%2A) in [async generator functions](/en-US/docs/Web/JavaScript/Reference/Statements/async%5Ffunction%2A) (but not [sync generator functions](/en-US/docs/Web/JavaScript/Reference/Statements/function%2A)) are the only ways to interact with async iterables. Using `for...of`, array spreading, etc. on an async iterable that's not also a sync iterable (i.e. it has `[@@asyncIterator]()` but no `[@@iterator]()`) will throw a TypeError: x is not iterable.\n\n### [Non-well-formed iterables](#non-well-formed%5Fiterables)\n\nIf an iterable's `@@iterator` method doesn't return an iterator object, then it's considered a _non-well-formed_ iterable.\n\nUsing one is likely to result in runtime errors or buggy behavior:\n\n```\nconst nonWellFormedIterable = {};\nnonWellFormedIterable[Symbol.iterator] = () => 1;\n[...nonWellFormedIterable]; // TypeError: [Symbol.iterator]() returned a non-object value\n\n```\n\n## [Examples](#examples)\n\n### [User-defined iterables](#user-defined%5Fiterables)\n\nYou can make your own iterables like this:\n\n```\nconst myIterable = {\n  *[Symbol.iterator]() {\n    yield 1;\n    yield 2;\n    yield 3;\n  },\n};\n\nconsole.log([...myIterable]); // [1, 2, 3]\n\n```\n\n### [Simple iterator](#simple%5Fiterator)\n\nIterators are stateful by nature. If you don't define it as a [generator function](/en-US/docs/Web/JavaScript/Reference/Statements/function%2A) (as the example above shows), you would likely want to encapsulate the state in a closure.\n\n```\nfunction makeIterator(array) {\n  let nextIndex = 0;\n  return {\n    next() {\n      return nextIndex < array.length\n        ? {\n            value: array[nextIndex++],\n            done: false,\n          }\n        : {\n            done: true,\n          };\n    },\n  };\n}\n\nconst it = makeIterator([\"yo\", \"ya\"]);\n\nconsole.log(it.next().value); // 'yo'\nconsole.log(it.next().value); // 'ya'\nconsole.log(it.next().done); // true\n\n```\n\n### [Infinite iterator](#infinite%5Fiterator)\n\n```\nfunction idMaker() {\n  let index = 0;\n  return {\n    next() {\n      return {\n        value: index++,\n        done: false,\n      };\n    },\n  };\n}\n\nconst it = idMaker();\n\nconsole.log(it.next().value); // 0\nconsole.log(it.next().value); // 1\nconsole.log(it.next().value); // 2\n// ...\n\n```\n\n### [Defining an iterable with a generator](#defining%5Fan%5Fiterable%5Fwith%5Fa%5Fgenerator)\n\n```\nfunction* makeSimpleGenerator(array) {\n  let nextIndex = 0;\n  while (nextIndex < array.length) {\n    yield array[nextIndex++];\n  }\n}\n\nconst gen = makeSimpleGenerator([\"yo\", \"ya\"]);\n\nconsole.log(gen.next().value); // 'yo'\nconsole.log(gen.next().value); // 'ya'\nconsole.log(gen.next().done); // true\n\nfunction* idMaker() {\n  let index = 0;\n  while (true) {\n    yield index++;\n  }\n}\n\nconst it = idMaker();\n\nconsole.log(it.next().value); // 0\nconsole.log(it.next().value); // 1\nconsole.log(it.next().value); // 2\n// ...\n\n```\n\n### [Defining an iterable with a class](#defining%5Fan%5Fiterable%5Fwith%5Fa%5Fclass)\n\nState encapsulation can be done with [private properties](/en-US/docs/Web/JavaScript/Reference/Classes/Private%5Fclass%5Ffields) as well.\n\n```\nclass SimpleClass {\n  #data;\n\n  constructor(data) {\n    this.#data = data;\n  }\n\n  [Symbol.iterator]() {\n    // Use a new index for each iterator. This makes multiple\n    // iterations over the iterable safe for non-trivial cases,\n    // such as use of break or nested looping over the same iterable.\n    let index = 0;\n\n    return {\n      // Note: using an arrow function allows `this` to point to the\n      // one of `[@@iterator]()` instead of `next()`\n      next: () => {\n        if (index < this.#data.length) {\n          return { value: this.#data[index++], done: false };\n        } else {\n          return { done: true };\n        }\n      },\n    };\n  }\n}\n\nconst simple = new SimpleClass([1, 2, 3, 4, 5]);\n\nfor (const val of simple) {\n  console.log(val); // 1 2 3 4 5\n}\n\n```\n\n### [Overriding built-in iterables](#overriding%5Fbuilt-in%5Fiterables)\n\nFor example, a [String](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String) is a built-in iterable object:\n\n```\nconst someString = \"hi\";\nconsole.log(typeof someString[Symbol.iterator]); // \"function\"\n\n```\n\n`String`'s [default iterator](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String/@@iterator) returns the string's code points one by one:\n\n```\nconst iterator = someString[Symbol.iterator]();\nconsole.log(`${iterator}`); // \"[object String Iterator]\"\n\nconsole.log(iterator.next()); // { value: \"h\", done: false }\nconsole.log(iterator.next()); // { value: \"i\", done: false }\nconsole.log(iterator.next()); // { value: undefined, done: true }\n\n```\n\nYou can redefine the iteration behavior by supplying our own `@@iterator`:\n\n```\n// need to construct a String object explicitly to avoid auto-boxing\nconst someString = new String(\"hi\");\n\nsomeString[Symbol.iterator] = function () {\n  return {\n    // this is the iterator object, returning a single element (the string \"bye\")\n    next() {\n      return this._first\n        ? { value: \"bye\", done: (this._first = false) }\n        : { done: true };\n    },\n    _first: true,\n  };\n};\n\n```\n\nNotice how redefining `@@iterator` affects the behavior of built-in constructs that use the iteration protocol:\n\n```\nconsole.log([...someString]); // [\"bye\"]\nconsole.log(`${someString}`); // \"hi\"\n\n```\n\n## [Specifications](#specifications)\n\n| Specification                                                                                                                           |\n| --------------------------------------------------------------------------------------------------------------------------------------- |\n| [ECMAScript Language Specification  \\# sec-iteration](https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-iteration) |\n\n## [See also](#see%5Falso)\n\n* [Iterators and generators](/en-US/docs/Web/JavaScript/Guide/Iterators%5Fand%5Fgenerators)\n* [function\\*](/en-US/docs/Web/JavaScript/Reference/Statements/function%2A)\n* [Symbol.iterator](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Symbol/iterator)\n* [Iterator](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Iterator)\n\n### Found a content problem with this page?\n\n* [Edit the page on GitHub](https://github.com/mdn/content/edit/main/files/en-us/web/javascript/reference/iteration%5Fprotocols/index.md \"This will take you to GitHub, where you'll need to sign in first.\").\n* [Report the content issue](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FIteration%5Fprotocols&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A%2A+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Fiteration%5Fprotocols%60%0A%2A+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FIteration%5Fprotocols%0A%2A+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Fiteration%5Fprotocols%2Findex.md%0A%2A+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Fc2274293475b0a5b4febf85a49c1f91bf43ebac7%0A%2A+Document+last+modified%3A+2023-05-03T02%3A24%3A26.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\").\n* [View the source on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/iteration%5Fprotocols/index.md?plain=1 \"Folder: en-us/web/javascript/reference/iteration_protocols (Opens in a new tab)\").\nWant to get more involved? [Learn how to contribute](https://github.com/mdn/content/blob/main/CONTRIBUTING.md \"This will take you to our contribution guidelines on GitHub.\").\n\nThis page was last modified on May 3, 2023 by [MDN contributors](/en-US/docs/Web/JavaScript/Reference/Iteration%5Fprotocols/contributors.txt)."}