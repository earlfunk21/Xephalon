{"lang":"Javascript","fullPath":"/Statements/with","category":"Statements","title":"with","url":"/en-US/docs/Web/JavaScript/Reference/Statements/with","markdown":"# with\n\n**Deprecated:** This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the [compatibility table](#browser%5Fcompatibility) at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.\n\n**Note:** Use of the `with` statement is not recommended, as it may be the source of confusing bugs and compatibility issues, makes optimization impossible, and is forbidden in [strict mode](/en-US/docs/Web/JavaScript/Reference/Strict%5Fmode). The recommended alternative is to assign the object whose properties you want to access to a temporary variable.\n\nThe **`with`** statement extends the scope chain for a statement.\n\n## [Syntax](#syntax)\n\n```\nwith (expression)\n  statement\n\n```\n\n`expression`\n\nAdds the given expression to the scope chain used when evaluating the statement. The parentheses around the expression are required.\n\n`statement`\n\nAny statement. To execute multiple statements, use a [block](/en-US/docs/Web/JavaScript/Reference/Statements/block) statement (`{ ... }`) to group those statements.\n\n## [Description](#description)\n\nThere are two types of identifiers: a _qualified_ identifier and an _unqualified_ identifier. An unqualified identifier is one that does not indicate where it comes from.\n\n```\nfoo; // unqualified identifier\nfoo.bar; // bar is a qualified identifier\n\n```\n\nNormally, an unqualified identifier is resolved by searching the scope chain for a variable with that name, while a qualified identifier is resolved by searching the prototype chain of an object for a property with that name.\n\n```\nconst foo = { bar: 1 };\nconsole.log(foo.bar);\n// foo is found in the scope chain as a variable;\n// bar is found in foo as a property\n\n```\n\nOne exception to this is the [global object](/en-US/docs/Glossary/Global%5Fobject), which sits on top of the scope chain, and whose properties automatically become global variables that can be referred to without qualifiers.\n\n```\nconsole.log(globalThis.Math === Math); // true\n\n```\n\nThe `with` statement adds the given object to the head of this scope chain during the evaluation of its statement body. Every unqualified name would first be searched within the object (through a [in](/en-US/docs/Web/JavaScript/Reference/Operators/in) check) before searching in the upper scope chain.\n\nNote that if the unqualified reference refers to a method of the object, the method is called with the object as its `this` value.\n\n```\nwith ([1, 2, 3]) {\n  console.log(toString()); // 1,2,3\n}\n\n```\n\nThe object may have an [@@unscopables](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Symbol/unscopables) property, which defines a list of properties that should not be added to the scope chain (for backward compatibility). See the [Symbol.unscopables](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Symbol/unscopables) documentation for more information.\n\nThe reasons to use a `with` statement include saving one temporary variable and reducing file size by avoiding repeating a lengthy object reference. However, there are far more reasons why `with` statements are not desirable:\n\n* Performance: The `with` statement forces the specified object to be searched first for all name lookups. Therefore, all identifiers that aren't members of the specified object will be found more slowly in a `with` block. Moreover, the optimizer cannot make any assumptions about what each unqualified identifier refers to, so it must repeat the same property lookup every time the identifier is used.\n* Readability: The `with` statement makes it hard for a human reader or JavaScript compiler to decide whether an unqualified name will be found along the scope chain, and if so, in which object. For example:  \n```  \nfunction f(x, o) {  \n  with (o) {  \n    console.log(x);  \n  }  \n}  \n```  \nIf you look just at the definition of `f`, it's impossible to tell what the `x` in the `with` body refers to. Only when `f` is called can `x` be determined to be `o.x` or `f`'s first formal parameter. If you forget to define `x` in the object you pass as the second parameter, you won't get an error — instead you'll just get unexpected results. It's also unclear what the actual intent of such code would be.\n* Forward compatibility: Code using `with` may not be forward compatible, especially when used with something other than a plain object, which may gain more properties in the future. Consider this example:  \n```  \nfunction f(foo, values) {  \n  with (foo) {  \n    console.log(values);  \n  }  \n}  \n```  \nIf you call `f([1, 2, 3], obj)` in an ECMAScript 5 environment, the `values` reference inside the `with` statement will resolve to `obj`. However, ECMAScript 2015 introduces a [values](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Array/values) property on `Array.prototype` (so it will be available on every array). So, after upgrading the environment, the `values` reference inside the `with` statement resolves to `[1, 2, 3].values` instead, and is likely to cause bugs. In this particular example, `values` is defined as unscopable through [Array.prototype\\[@@unscopables\\]](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Array/@@unscopables), so it still correctly resolves to the `values` parameter. If it were not defined as unscopable, one can see how this would be a difficult issue to debug.\n\n## [Examples](#examples)\n\n### [Using the with statement](#using%5Fthe%5Fwith%5Fstatement)\n\nThe following `with` statement specifies that the [Math](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Math) object is the default object. The statements following the `with` statement refer to the [PI](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Math/PI) property and the [cos](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Math/cos) and [sin](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Math/sin) methods, without specifying an object. JavaScript assumes the `Math` object for these references.\n\n```\nlet a, x, y;\nconst r = 10;\n\nwith (Math) {\n  a = PI * r * r;\n  x = r * cos(PI);\n  y = r * sin(PI / 2);\n}\n\n```\n\n### [Avoiding the with statement by destructuring properties into the current scope](#avoiding%5Fthe%5Fwith%5Fstatement%5Fby%5Fdestructuring%5Fproperties%5Finto%5Fthe%5Fcurrent%5Fscope)\n\nYou can usually avoid using `with` through [property destructuring](/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring%5Fassignment). Here we create an extra block to mimic the behavior of `with` creating an extra scope — but in actual usage, this block can usually be omitted.\n\n```\nlet a, x, y;\nconst r = 10;\n\n{\n  const { PI, cos, sin } = Math;\n  a = PI * r * r;\n  x = r * cos(PI);\n  y = r * sin(PI / 2);\n}\n\n```\n\n### [Avoiding the with statement by using an IIFE](#avoiding%5Fthe%5Fwith%5Fstatement%5Fby%5Fusing%5Fan%5Fiife)\n\nIf you're producing an expression that must reuse a long-named reference multiple times, and your goal is to eliminate that lengthy name within your expression, you can wrap the expression in an [IIFE](/en-US/docs/Glossary/IIFE) and provide the long name as an argument.\n\n```\nconst objectHavingAnEspeciallyLengthyName = { foo: true, bar: false };\n\nif (((o) => o.foo && !o.bar)(objectHavingAnEspeciallyLengthyName)) {\n  // This branch runs.\n}\n\n```\n\n### [Creating dynamic namespaces using the with statement and a proxy](#creating%5Fdynamic%5Fnamespaces%5Fusing%5Fthe%5Fwith%5Fstatement%5Fand%5Fa%5Fproxy)\n\n`with` will transform every variable lookup to a property lookup, while [Proxies](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Proxy) allow trapping every property lookup call. You can create a dynamic namespace by combining them.\n\n```\nconst namespace = new Proxy(\n  {},\n  {\n    has(target, key) {\n      // Avoid trapping global properties like `console`\n      if (key in globalThis) {\n        return false;\n      }\n      // Trap all property lookups\n      return true;\n    },\n    get(target, key) {\n      return key;\n    },\n  },\n);\n\nwith (namespace) {\n  console.log(a, b, c); // \"a\" \"b\" \"c\"\n}\n\n```\n\n## [Specifications](#specifications)\n\n| Specification                                                                                                                                                         |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [ECMAScript Language Specification  \\# sec-with-statement](https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-with-statement) |\n\n## [Browser compatibility](#browser%5Fcompatibility)\n\nBCD tables only load in the browser\n\n## [See also](#see%5Falso)\n\n* [block](/en-US/docs/Web/JavaScript/Reference/Statements/block)\n* [Strict mode](/en-US/docs/Web/JavaScript/Reference/Strict%5Fmode)\n* [Symbol.unscopables](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Symbol/unscopables)\n* [Array.prototype\\[@@unscopables\\]](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Array/@@unscopables)\n\n### Found a content problem with this page?\n\n* [Edit the page on GitHub](https://github.com/mdn/content/edit/main/files/en-us/web/javascript/reference/statements/with/index.md \"This will take you to GitHub, where you'll need to sign in first.\").\n* [Report the content issue](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Fwith&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A%2A+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Fstatements%2Fwith%60%0A%2A+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Fwith%0A%2A+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Fstatements%2Fwith%2Findex.md%0A%2A+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Fb5c766f4eecb4fcf9d8ba175caddb94f7c3e9d20%0A%2A+Document+last+modified%3A+2023-05-01T00%3A22%3A52.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\").\n* [View the source on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/statements/with/index.md?plain=1 \"Folder: en-us/web/javascript/reference/statements/with (Opens in a new tab)\").\nWant to get more involved? [Learn how to contribute](https://github.com/mdn/content/blob/main/CONTRIBUTING.md \"This will take you to our contribution guidelines on GitHub.\").\n\nThis page was last modified on May 1, 2023 by [MDN contributors](/en-US/docs/Web/JavaScript/Reference/Statements/with/contributors.txt)."}