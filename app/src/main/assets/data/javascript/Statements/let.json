{"lang":"Javascript","fullPath":"/Statements/let","category":"Statements","title":"let","url":"/en-US/docs/Web/JavaScript/Reference/Statements/let","markdown":"# let\n\nThe **`let`** declaration declares a block-scoped local variable, optionally initializing it to a value.\n\n## [Try it](#try%5Fit)\n\n## [Syntax](#syntax)\n\n```\nlet name1;\nlet name1 = value1;\nlet name1 = value1, name2 = value2;\nlet name1, name2 = value2;\nlet name1 = value1, name2, /* …, */ nameN = valueN;\n\n```\n\n### [Parameters](#parameters)\n\n`nameN`\n\nThe names of the variable or variables to declare. Each must be a legal JavaScript identifier.\n\n`valueN` Optional\n\nFor each variable declared, you may optionally specify its initial value to any legal JavaScript expression.\n\nThe [destructuring assignment](/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring%5Fassignment) syntax can also be used to declare variables.\n\n```\nlet { bar } = foo; // where foo = { bar: 10, baz: 12 };\n// This creates a variable with the name 'bar', which has a value of 10\n\n```\n\n## [Description](#description)\n\n`let` allows you to declare variables that are limited to the scope of a [block](/en-US/docs/Web/JavaScript/Reference/Statements/block) statement, or expression on which it is used, unlike the [var](/en-US/docs/Web/JavaScript/Reference/Statements/var) keyword, which declares a variable globally, or locally to an entire function regardless of block scope. The other difference between [var](/en-US/docs/Web/JavaScript/Reference/Statements/var) and `let` is that the latter can only be accessed after its declaration is reached (see [temporal dead zone](#temporal%5Fdead%5Fzone%5Ftdz)). For this reason, `let` declarations are commonly regarded as [non-hoisted](/en-US/docs/Glossary/Hoisting).\n\nJust like [const](/en-US/docs/Web/JavaScript/Reference/Statements/const#description) the `let` does _not_ create properties of the [window](/en-US/docs/Web/API/Window) object when declared globally (in the top-most scope).\n\n[An explanation of why the name let was chosen](https://stackoverflow.com/questions/37916940/why-was-the-name-let-chosen-for-block-scoped-variable-declarations-in-javascri) can be found in the linked StackOverflow answer.\n\nMany issues with `let` variables can be avoided by declaring them at the top of the scope in which they are used (doing so may impact readability).\n\nUnlike `var`, `let` begins [_declarations_, not _statements_](/en-US/docs/Web/JavaScript/Reference/Statements#difference%5Fbetween%5Fstatements%5Fand%5Fdeclarations). That means you cannot use a lone `let` declaration as the body of a block (which makes sense, since there's no way to access the variable).\n\n```\nif (true) let a = 1; // SyntaxError: Lexical declaration cannot appear in a single-statement context\n\n```\n\n## [Examples](#examples)\n\n### [Scoping rules](#scoping%5Frules)\n\nVariables declared by `let` have their scope in the block for which they are declared, as well as in any contained sub-blocks. In this way, `let` works very much like `var`. The main difference is that the scope of a `var` variable is the entire enclosing function:\n\n```\nfunction varTest() {\n  var x = 1;\n  {\n    var x = 2; // same variable!\n    console.log(x); // 2\n  }\n  console.log(x); // 2\n}\n\nfunction letTest() {\n  let x = 1;\n  {\n    let x = 2; // different variable\n    console.log(x); // 2\n  }\n  console.log(x); // 1\n}\n\n```\n\nAt the top level of programs and functions, `let`, unlike `var`, does not create a property on the global object. For example:\n\n```\nvar x = \"global\";\nlet y = \"global\";\nconsole.log(this.x); // \"global\"\nconsole.log(this.y); // undefined\n\n```\n\n### [Redeclarations](#redeclarations)\n\nRedeclaring the same variable within the same function or block scope raises a [SyntaxError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/SyntaxError).\n\n```\nif (x) {\n  let foo;\n  let foo; // SyntaxError thrown.\n}\n\n```\n\nYou may encounter errors in [switch](/en-US/docs/Web/JavaScript/Reference/Statements/switch) statements because there is only one block.\n\n```\nlet x = 1;\n\nswitch (x) {\n  case 0:\n    let foo;\n    break;\n  case 1:\n    let foo; // SyntaxError for redeclaration.\n    break;\n}\n\n```\n\nA block nested inside a case clause will create a new block scoped lexical environment, avoiding the redeclaration errors shown above.\n\n```\nlet x = 1;\n\nswitch (x) {\n  case 0: {\n    let foo;\n    break;\n  }\n  case 1: {\n    let foo;\n    break;\n  }\n}\n\n```\n\nIf you're experimenting in a REPL, such as the Firefox web console (**Tools** \\> **Web Developer** \\> **Web Console**), and you run two `let` declarations with the same name in two separate inputs, you may get the same re-declaration error. See further discussion of this issue in [Firefox bug 1580891](https://bugzil.la/1580891). The Chrome console allows `let` re-declarations between different REPL inputs.\n\n### [Temporal dead zone (TDZ)](#temporal%5Fdead%5Fzone%5Ftdz)\n\nA `let` or `const` variable is said to be in a \"temporal dead zone\" (TDZ) from the start of the block until code execution reaches the line where the variable is declared and initialized.\n\nWhile inside the TDZ, the variable has not been initialized with a value, and any attempt to access it will result in a [ReferenceError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/ReferenceError). The variable is initialized with a value when execution reaches the line of code where it was declared. If no initial value was specified with the variable declaration, it will be initialized with a value of `undefined`.\n\nThis differs from [var](/en-US/docs/Web/JavaScript/Reference/Statements/var#var%5Fhoisting) variables, which will return a value of `undefined` if they are accessed before they are declared. The code below demonstrates the different result when `let` and `var` are accessed in code before the line in which they are declared.\n\n```\n{\n  // TDZ starts at beginning of scope\n  console.log(bar); // undefined\n  console.log(foo); // ReferenceError\n  var bar = 1;\n  let foo = 2; // End of TDZ (for foo)\n}\n\n```\n\nThe term \"temporal\" is used because the zone depends on the order of execution (time) rather than the order in which the code is written (position). For example, the code below works because, even though the function that uses the `let` variable appears before the variable is declared, the function is _called_ outside the TDZ.\n\n```\n{\n  // TDZ starts at beginning of scope\n  const func = () => console.log(letVar); // OK\n\n  // Within the TDZ letVar access throws `ReferenceError`\n\n  let letVar = 3; // End of TDZ (for letVar)\n  func(); // Called outside TDZ!\n}\n\n```\n\n#### The TDZ and typeof\n\nUsing the `typeof` operator for a `let` variable in its TDZ will throw a [ReferenceError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/ReferenceError):\n\n```\n// results in a 'ReferenceError'\nconsole.log(typeof i);\nlet i = 10;\n\n```\n\nThis differs from using `typeof` for undeclared variables, and variables that hold a value of `undefined`:\n\n```\n// prints out 'undefined'\nconsole.log(typeof undeclaredVariable);\n\n```\n\n#### TDZ combined with lexical scoping\n\nThe following code results in a `ReferenceError` at the line shown:\n\n```\nfunction test() {\n  var foo = 33;\n  if (foo) {\n    let foo = foo + 55; // ReferenceError\n  }\n}\ntest();\n\n```\n\nThe `if` block is evaluated because the outer `var foo` has a value. However due to lexical scoping this value is not available inside the block: the identifier `foo` _inside_ the `if` block is the `let foo`. The expression `foo + 55` throws a `ReferenceError` because initialization of `let foo` has not completed — it is still in the temporal dead zone.\n\nThis phenomenon can be confusing in a situation like the following. The instruction `let n of n.a` is already inside the private scope of the `for...of` loop's block. So, the identifier `n.a` is resolved to the property `a` of the `n` object located in the first part of the instruction itself (`let n`). This is still in the temporal dead zone as its declaration statement has not been reached and terminated.\n\n```\nfunction go(n) {\n  // n here is defined!\n  console.log(n); // { a: [1, 2, 3] }\n\n  for (let n of n.a) {\n    //          ^ ReferenceError\n    console.log(n);\n  }\n}\n\ngo({ a: [1, 2, 3] });\n\n```\n\n### [Other situations](#other%5Fsituations)\n\nWhen used inside a block, `let` limits the variable's scope to that block. Note the difference between `var`, whose scope is inside the function where it is declared.\n\n```\nvar a = 1;\nvar b = 2;\n\n{\n  var a = 11; // the scope is global\n  let b = 22; // the scope is inside the block\n\n  console.log(a); // 11\n  console.log(b); // 22\n}\n\nconsole.log(a); // 11\nconsole.log(b); // 2\n\n```\n\nHowever, this combination of `var` and `let` declarations below is a [SyntaxError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/SyntaxError) because `var` not being block-scoped, leading to them being in the same scope. This results in an implicit re-declaration of the variable.\n\n```\nlet x = 1;\n\n{\n  var x = 2; // SyntaxError for re-declaration\n}\n\n```\n\n## [Specifications](#specifications)\n\n| Specification                                                                                                                                                                                 |\n| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [ECMAScript Language Specification  \\# sec-let-and-const-declarations](https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-let-and-const-declarations) |\n\n## [Browser compatibility](#browser%5Fcompatibility)\n\nBCD tables only load in the browser\n\n## [See also](#see%5Falso)\n\n* [var](/en-US/docs/Web/JavaScript/Reference/Statements/var)\n* [const](/en-US/docs/Web/JavaScript/Reference/Statements/const)\n* [Hoisting](/en-US/docs/Glossary/Hoisting)\n* [ES6 In Depth: let and const](https://hacks.mozilla.org/2015/07/es6-in-depth-let-and-const/)\n* [Breaking changes in let and const in Firefox 44](https://blog.mozilla.org/addons/2015/10/14/breaking-changes-let-const-firefox-nightly-44/)\n* [You Don't Know JS: Scope & Closures: Chapter 3: Function vs. Block Scope](https://github.com/getify/You-Dont-Know-JS/blob/1st-ed/scope%20%26%20closures/ch3.md)\n* [StackOverflow: What is the Temporal Dead Zone](https://stackoverflow.com/questions/33198849/what-is-the-temporal-dead-zone/33198850)?\n* [StackOverflow: What is the difference between using let and var?](https://stackoverflow.com/questions/762011/whats-the-difference-between-using-let-and-var)\n\n### Found a content problem with this page?\n\n* [Edit the page on GitHub](https://github.com/mdn/content/edit/main/files/en-us/web/javascript/reference/statements/let/index.md \"This will take you to GitHub, where you'll need to sign in first.\").\n* [Report the content issue](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Flet&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A%2A+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Fstatements%2Flet%60%0A%2A+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Flet%0A%2A+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Fstatements%2Flet%2Findex.md%0A%2A+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2Fdca6a5a6d2b20cc7529da4746a0c15e99a252579%0A%2A+Document+last+modified%3A+2023-04-04T20%3A38%3A53.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\").\n* [View the source on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/statements/let/index.md?plain=1 \"Folder: en-us/web/javascript/reference/statements/let (Opens in a new tab)\").\nWant to get more involved? [Learn how to contribute](https://github.com/mdn/content/blob/main/CONTRIBUTING.md \"This will take you to our contribution guidelines on GitHub.\").\n\nThis page was last modified on Apr 4, 2023 by [MDN contributors](/en-US/docs/Web/JavaScript/Reference/Statements/let/contributors.txt)."}