{"lang":"Javascript","fullPath":"/Statements/var","category":"Statements","title":"var","url":"/en-US/docs/Web/JavaScript/Reference/Statements/var","markdown":"# var\n\n The **`var`** statement declares a function-scoped or globally-scoped variable, optionally initializing it to a value.\n\n## [Try it](#try%5Fit)\n\n## [Syntax](#syntax)\n\n```\nvar name1;\nvar name1 = value1;\nvar name1 = value1, name2 = value2;\nvar name1, name2 = value2;\nvar name1 = value1, name2, /* â€¦, */ nameN = valueN;\n\n```\n\n`nameN`\n\nVariable name. It can be any legal identifier.\n\n`valueN` Optional\n\n Initial value of the variable. It can be any legal expression. Default value is`undefined`.\n\n Alternatively, the [Destructuring Assignment](/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring%5Fassignment) syntax can also be used to declare variables.\n\n```\nvar { bar } = foo; // where foo = { bar:10, baz:12 };\n/* This creates a variable with the name 'bar', which has a value of 10 */\n\n```\n\n## [Description](#description)\n\n`var` declarations, wherever they occur, are processed before any code is executed. This is called [hoisting](/en-US/docs/Glossary/Hoisting) and is discussed further below.\n\n The scope of a variable declared with `var` is its current _execution context and closures thereof_, which is either the enclosing function and functions declared within it, or, for variables declared outside any function, global. Duplicate variable declarations using `var` will not trigger an error, even in strict mode, and the variable will not lose its value, unless another assignment is performed.\n\n```\nfunction foo() {\n  var x = 1;\n  function bar() {\n    var y = 2;\n    console.log(x); // 1 (function `bar` closes over `x`)\n    console.log(y); // 2 (`y` is in scope)\n  }\n  bar();\n  console.log(x); // 1 (`x` is in scope)\n  console.log(y); // ReferenceError, `y` is scoped to `bar`\n}\n\nfoo();\n\n```\n\n Variables declared using `var` are created before any code is executed in a process known as [hoisting](/en-US/docs/Glossary/Hoisting). Their initial value is `undefined`.\n\n```\nconsole.log(x); // undefined (note: not ReferenceError)\nconsole.log(\"still going...\"); // still going...\nvar x = 1;\nconsole.log(x); // 1\nconsole.log(\"still going...\"); // still going...\n\n```\n\n In the global context, a variable declared using `var` is added as a non-configurable property of the global object. This means its property descriptor cannot be changed and it cannot be deleted using [delete](/en-US/docs/Web/JavaScript/Reference/Operators/delete). The corresponding name is also added to a list on the internal `[[VarNames]]` slot on the[global environment record](https://tc39.es/ecma262/#sec-global-environment-records) (which forms part of the global lexical environment). The list of names in `[[VarNames]]` enables the runtime to distinguish between global variables and straightforward properties on the global object.\n\n The property created on the global object for global variables, is set to be non-configurable because the identifier is to be treated as a variable, rather than a straightforward property of the global object. JavaScript has automatic memory management, and it would make no sense to be able to use the `delete` operator on a global variable.\n\n```\n\"use strict\";\nvar x = 1;\nObject.hasOwn(globalThis, \"x\"); // true\ndelete globalThis.x; // TypeError in strict mode. Fails silently otherwise.\ndelete x; // SyntaxError in strict mode. Fails silently otherwise.\n\n```\n\n Note that in both NodeJS [CommonJS](https://www.commonjs.org/) modules and native [ECMAScript modules](/en-US/docs/Web/JavaScript/Guide/Modules), top-level variable declarations are scoped to the module, and are not, therefore added as properties to the global object.\n\n### [Unqualified identifier assignments](#unqualified%5Fidentifier%5Fassignments)\n\n The global object sits at the top of the scope chain. When attempting to resolve a name to a value, the scope chain is searched. This means that properties on the global object are conveniently visible from every scope, without having to qualify the names with`globalThis.` or `window.` or `global.`.\n\nBecause the global object has a `String` property (`Object.hasOwn(globalThis, 'String')`), you can use the following code:\n\n```\nfunction foo() {\n  String(\"s\"); // Note the function `String` is implicitly visible\n}\n\n```\n\n So the global object will ultimately be searched for unqualified identifiers. You don't have to type `globalThis.String`, you can just type the unqualified`String`. The corollary, in non-strict mode, is that assignment to unqualified identifiers will, if there is no variable of the same name declared in the scope chain, assume you want to create a property with that name on the global object.\n\n```\nfoo = \"f\"; // In non-strict mode, assumes you want to create a property named `foo` on the global object\nObject.hasOwn(globalThis, \"foo\"); // true\n\n```\n\nIn [strict mode](/en-US/docs/Web/JavaScript/Reference/Strict%5Fmode), assignment to an unqualified identifier in strict mode will result in a `ReferenceError`, to avoid the accidental creation of properties on the global object.\n\n Note that the implication of the above, is that, contrary to popular misinformation, JavaScript does not have implicit or undeclared variables, it merely has a syntax that looks like it does.\n\n### [var hoisting](#var%5Fhoisting)\n\n Because `var` declarations are processed before any code is executed, declaring a variable anywhere in the code is equivalent to declaring it at the top. This also means that a variable can appear to be used before it's declared. This behavior is called [_hoisting_](/en-US/docs/Glossary/Hoisting), as it appears that the variable declaration is moved to the top of the function or global code.\n\n```\nbla = 2;\nvar bla;\n\n```\n\nThis is implicitly understood as:\n\n```\nvar bla;\nbla = 2;\n\n```\n\n For that reason, it is recommended to always declare variables at the top of their scope (the top of global code and the top of function code) so it's clear which variables are function scoped (local) and which are resolved on the scope chain.\n\n It's important to point out that only a variable's declaration is hoisted, not its initialization. The initialization happens only when the assignment statement is reached. Until then the variable remains `undefined` (but declared):\n\n```\nfunction do_something() {\n  console.log(bar); // undefined\n  var bar = 111;\n  console.log(bar); // 111\n}\n\n```\n\nThis is implicitly understood as:\n\n```\nfunction do_something() {\n  var bar;\n  console.log(bar); // undefined\n  bar = 111;\n  console.log(bar); // 111\n}\n\n```\n\n## [Examples](#examples)\n\n### [Declaring and initializing two variables](#declaring%5Fand%5Finitializing%5Ftwo%5Fvariables)\n\n```\nvar a = 0,\n  b = 0;\n\n```\n\n### [Assigning two variables with single string value](#assigning%5Ftwo%5Fvariables%5Fwith%5Fsingle%5Fstring%5Fvalue)\n\n```\nvar a = \"A\";\nvar b = a;\n\n```\n\nThis is equivalent to:\n\n```\nvar a, b = a = 'A';\n\n```\n\nBe mindful of the order:\n\n```\nvar x = y,\n  y = \"A\";\nconsole.log(x + y); // undefinedA\n\n```\n\n Here, `x` and `y` are declared before any code is executed, but the assignments occur later. At the time `x = y` is evaluated,`y` exists so no `ReferenceError` is thrown and its value is`undefined`. So, `x` is assigned the undefined value. Then,`y` is assigned the value `'A'`. Consequently, after the first line, `x === undefined && y === 'A'`, hence the result.\n\n### [Initialization of several variables](#initialization%5Fof%5Fseveral%5Fvariables)\n\n```\nvar x = 0;\nfunction f() {\n  var x = y = 1; // Declares x locally; declares y globally.\n}\nf();\n\nconsole.log(x, y); // 0 1\n\n// In non-strict mode:\n// x is the global one as expected;\n// y is leaked outside of the function, though!\n\n```\n\nThe same example as above but with a strict mode:\n\n```\n\"use strict\";\n\nvar x = 0;\nfunction f() {\n  var x = y = 1; // Throws a ReferenceError in strict mode.\n}\nf();\n\nconsole.log(x, y);\n\n```\n\n### [Implicit globals and outer function scope](#implicit%5Fglobals%5Fand%5Fouter%5Ffunction%5Fscope)\n\n Variables that appear to be implicit globals may be references to variables in an outer function scope:\n\n```\nvar x = 0; // Declares x within file scope, then assigns it a value of 0.\n\nconsole.log(typeof z); // \"undefined\", since z doesn't exist yet\n\nfunction a() {\n  var y = 2; // Declares y within scope of function a, then assigns it a value of 2.\n\n  console.log(x, y); // 0 2\n\n  function b() {\n    x = 3; // Assigns 3 to existing file scoped x.\n    y = 4; // Assigns 4 to existing outer y.\n    z = 5; // Creates a new global variable z, and assigns it a value of 5.\n    // (Throws a ReferenceError in strict mode.)\n  }\n\n  b(); // Creates z as a global variable.\n  console.log(x, y, z); // 3 4 5\n}\n\na(); // Also calls b.\nconsole.log(x, z); // 3 5\nconsole.log(typeof y); // \"undefined\", as y is local to function a\n\n```\n\n## [Specifications](#specifications)\n\n| Specification                                                                                                                                                                 |\n| ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [ECMAScript Language Specification  \\# sec-variable-statement](https://tc39.es/ecma262/multipage/ecmascript-language-statements-and-declarations.html#sec-variable-statement) |\n\n## [Browser compatibility](#browser%5Fcompatibility)\n\nBCD tables only load in the browser\n\n## [See also](#see%5Falso)\n\n* [let](/en-US/docs/Web/JavaScript/Reference/Statements/let)\n* [const](/en-US/docs/Web/JavaScript/Reference/Statements/const)\n\n### Found a content problem with this page?\n\n* [Edit the page on GitHub](https://github.com/mdn/content/edit/main/files/en-us/web/javascript/reference/statements/var/index.md \"This will take you to GitHub, where you'll need to sign in first.\").\n* [Report the content issue](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Fvar&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A%2A+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Fstatements%2Fvar%60%0A%2A+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FStatements%2Fvar%0A%2A+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Fstatements%2Fvar%2Findex.md%0A%2A+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2F568f6f7fa0b5ccef3981758fde4e233e4aa10c09%0A%2A+Document+last+modified%3A+2023-03-14T09%3A24%3A54.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\").\n* [View the source on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/statements/var/index.md?plain=1 \"Folder: en-us/web/javascript/reference/statements/var (Opens in a new tab)\").\nWant to get more involved? [Learn how to contribute](https://github.com/mdn/content/blob/main/CONTRIBUTING.md \"This will take you to our contribution guidelines on GitHub.\").\n\nThis page was last modified on Mar 14, 2023 by [MDN contributors](/en-US/docs/Web/JavaScript/Reference/Statements/var/contributors.txt)."}