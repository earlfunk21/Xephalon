{"lang":"Javascript","fullPath":"/en-US/docs/Web/JavaScript/Data_structures","category":"JavaScript","title":"Data_structures","url":"/en-US/docs/Web/JavaScript/Data_structures","markdown":"# JavaScript data types and data structures\n\nProgramming languages all have built-in data structures, but these often differ from one language to another. This article attempts to list the built-in data structures available in JavaScript and what properties they have. These can be used to build other data structures.\n\nThe [language overview](/en-US/docs/Web/JavaScript/Language%5Foverview) offers a similar summary of the common data types, but with more comparisons to other languages.\n\n## [Dynamic and weak typing](#dynamic%5Fand%5Fweak%5Ftyping)\n\nJavaScript is a [dynamic](https://en.wikipedia.org/wiki/Dynamic%5Fprogramming%5Flanguage) language with [dynamic types](https://en.wikipedia.org/wiki/Type%5Fsystem#DYNAMIC). Variables in JavaScript are not directly associated with any particular value type, and any variable can be assigned (and re-assigned) values of all types:\n\n```\nlet foo = 42; // foo is now a number\nfoo = \"bar\"; // foo is now a string\nfoo = true; // foo is now a boolean\n\n```\n\nJavaScript is also a [weakly typed](https://en.wikipedia.org/wiki/Strong%5Fand%5Fweak%5Ftyping) language, which means it allows implicit type conversion when an operation involves mismatched types, instead of throwing type errors.\n\n```\nconst foo = 42; // foo is a number\nconst result = foo + \"1\"; // JavaScript coerces foo to a string, so it can be concatenated with the other operand\nconsole.log(result); // 421\n\n```\n\nImplicit coercions is very convenient, but can be a potential footgun if developers didn't intend to do the conversion, or intend to convert in the other direction (for example, string to number instead of number to string). For [symbols](#symbol%5Ftype) and [BigInts](#bigint%5Ftype), JavaScript has intentionally disallowed certain implicit type conversions.\n\n## [Primitive values](#primitive%5Fvalues)\n\nAll types except [Object](#objects) define [immutable](/en-US/docs/Glossary/Immutable) values represented directly at the lowest level of the language. We refer to values of these types as _primitive values_.\n\nAll primitive types, except [null](/en-US/docs/Web/JavaScript/Reference/Operators/null), can be tested by the [typeof](/en-US/docs/Web/JavaScript/Reference/Operators/typeof) operator. `typeof null` returns `\"object\"`, so one has to use `=== null` to test for `null`.\n\nAll primitive types, except [null](/en-US/docs/Web/JavaScript/Reference/Operators/null) and [undefined](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/undefined), have their corresponding object wrapper types, which provide useful methods for working with the primitive values. For example, the [Number](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number) object provides methods like [toExponential()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number/toExponential). When a property is accessed on a primitive value, JavaScript automatically wraps the value into the corresponding wrapper object and accesses the property on the object instead. However, accessing a property on `null` or `undefined` throws a `TypeError` exception, which necessitates the introduction of the [optional chaining](/en-US/docs/Web/JavaScript/Reference/Operators/Optional%5Fchaining) operator.\n\n| Type                           | typeof return value | Object wrapper                                                           |\n| ------------------------------ | ------------------- | ------------------------------------------------------------------------ |\n| [Null](#null%5Ftype)           | \"object\"            | N/A                                                                      |\n| [Undefined](#undefined%5Ftype) | \"undefined\"         | N/A                                                                      |\n| [Boolean](#boolean%5Ftype)     | \"boolean\"           | [Boolean](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Boolean) |\n| [Number](#number%5Ftype)       | \"number\"            | [Number](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number)   |\n| [BigInt](#bigint%5Ftype)       | \"bigint\"            | [BigInt](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/BigInt)   |\n| [String](#string%5Ftype)       | \"string\"            | [String](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String)   |\n| [Symbol](#symbol%5Ftype)       | \"symbol\"            | [Symbol](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Symbol)   |\n\nThe object wrapper classes' reference pages contain more information about the methods and properties available for each type, as well as detailed descriptions for the semantics of the primitive types themselves.\n\n### [Null type](#null%5Ftype)\n\nThe Null type is inhabited by exactly one value: [null](/en-US/docs/Web/JavaScript/Reference/Operators/null).\n\n### [Undefined type](#undefined%5Ftype)\n\nThe Undefined type is inhabited by exactly one value: [undefined](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/undefined).\n\nConceptually, `undefined` indicates the absence of a _value_, while `null` indicates the absence of an _object_ (which could also make up an excuse for [typeof null === \"object\"](/en-US/docs/Web/JavaScript/Reference/Operators/typeof#typeof%5Fnull)). The language usually defaults to `undefined` when something is devoid of a value:\n\n* A [return](/en-US/docs/Web/JavaScript/Reference/Statements/return) statement with no value (`return;`) implicitly returns `undefined`.\n* Accessing a nonexistent [object](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object) property (`obj.iDontExist`) returns `undefined`.\n* A variable declaration without initialization (`let x;`) implicitly initializes the variable to `undefined`.\n* Many methods, such as [Array.prototype.find()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Array/find) and [Map.prototype.get()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Map/get), return `undefined` when no element is found.\n\n`null` is used much less often in the core language. The most important place is the end of the [prototype chain](/en-US/docs/Web/JavaScript/Inheritance%5Fand%5Fthe%5Fprototype%5Fchain) — subsequently, methods that interact with prototypes, such as [Object.getPrototypeOf()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/getPrototypeOf), [Object.create()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/create), etc., accept or return `null` instead of `undefined`.\n\n`null` is a [keyword](/en-US/docs/Web/JavaScript/Reference/Lexical%5Fgrammar#keywords), but `undefined` is a normal [identifier](/en-US/docs/Web/JavaScript/Reference/Lexical%5Fgrammar#identifiers) that happens to be a global property. In practice, the difference is minor, since `undefined` should not be redefined or shadowed.\n\n### [Boolean type](#boolean%5Ftype)\n\nThe [Boolean](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Boolean) type represents a logical entity and is inhabited by two values: `true` and `false`.\n\nBoolean values are usually used for conditional operations, including [ternary operators](/en-US/docs/Web/JavaScript/Reference/Operators/Conditional%5Foperator), [if...else](/en-US/docs/Web/JavaScript/Reference/Statements/if...else), [while](/en-US/docs/Web/JavaScript/Reference/Statements/while), etc.\n\n### [Number type](#number%5Ftype)\n\nThe [Number](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number) type is a [double-precision 64-bit binary format IEEE 754 value](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number#number%5Fencoding). It is capable of storing positive floating-point numbers between 2\\-1074 ([Number.MIN\\_VALUE](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number/MIN%5FVALUE)) and 21024 ([Number.MAX\\_VALUE](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number/MAX%5FVALUE)) as well as negative floating-point numbers between -2\\-1074 and -21024, but it can only safely store integers in the range -(253 − 1) ([Number.MIN\\_SAFE\\_INTEGER](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number/MIN%5FSAFE%5FINTEGER)) to 253 − 1 ([Number.MAX\\_SAFE\\_INTEGER](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number/MAX%5FSAFE%5FINTEGER)). Outside this range, JavaScript can no longer safely represent integers; they will instead be represented by a double-precision floating point approximation. You can check if a number is within the range of safe integers using [Number.isSafeInteger()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number/isSafeInteger).\n\nValues outside the range ±(2\\-1074 to 21024) are automatically converted:\n\n* Positive values greater than [Number.MAX\\_VALUE](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number/MAX%5FVALUE) are converted to `+Infinity`.\n* Positive values smaller than [Number.MIN\\_VALUE](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number/MIN%5FVALUE) are converted to `+0`.\n* Negative values smaller than -[Number.MAX\\_VALUE](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number/MAX%5FVALUE) are converted to `-Infinity`.\n* Negative values greater than -[Number.MIN\\_VALUE](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number/MIN%5FVALUE) are converted to `-0`.\n\n`+Infinity` and `-Infinity` behave similarly to mathematical infinity, but with some slight differences; see [Number.POSITIVE\\_INFINITY](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number/POSITIVE%5FINFINITY) and [Number.NEGATIVE\\_INFINITY](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number/NEGATIVE%5FINFINITY) for details.\n\nThe Number type has only one value with multiple representations: `0` is represented as both `-0` and `+0` (where `0` is an alias for `+0`). In practice, there is almost no difference between the different representations; for example, `+0 === -0` is `true`. However, you are able to notice this when you divide by zero:\n\n```\nconsole.log(42 / +0); // Infinity\nconsole.log(42 / -0); // -Infinity\n\n```\n\n[NaN](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/NaN) (\"**N**ot **a** **N**umber\") is a special kind of number value that's typically encountered when the result of an arithmetic operation cannot be expressed as a number. It is also the only value in JavaScript that is not equal to itself.\n\nAlthough a number is conceptually a \"mathematical value\" and is always implicitly floating-point-encoded, JavaScript provides [bitwise operators](/en-US/docs/Web/JavaScript/Guide/Expressions%5Fand%5Foperators#bitwise%5Foperators). When applying bitwise operators, the number is first converted to a 32-bit integer.\n\n**Note:** Although bitwise operators _can_ be used to represent several Boolean values within a single number using [bit masking](https://en.wikipedia.org/wiki/Mask%5F%28computing%29), this is usually considered a bad practice. JavaScript offers other means to represent a set of Booleans (like an array of Booleans, or an object with Boolean values assigned to named properties). Bit masking also tends to make the code more difficult to read, understand, and maintain.\n\nIt may be necessary to use such techniques in very constrained environments, like when trying to cope with the limitations of local storage, or in extreme cases (such as when each bit over the network counts). This technique should only be considered when it is the last measure that can be taken to optimize size.\n\n### [BigInt type](#bigint%5Ftype)\n\nThe [BigInt](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/BigInt) type is a numeric primitive in JavaScript that can represent integers with arbitrary magnitude. With BigInts, you can safely store and operate on large integers even beyond the safe integer limit ([Number.MAX\\_SAFE\\_INTEGER](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number/MAX%5FSAFE%5FINTEGER)) for Numbers.\n\nA BigInt is created by appending `n` to the end of an integer or by calling the [BigInt()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/BigInt/BigInt) function.\n\nThis example demonstrates where incrementing the [Number.MAX\\_SAFE\\_INTEGER](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number/MAX%5FSAFE%5FINTEGER) returns the expected result:\n\n```\n// BigInt\nconst x = BigInt(Number.MAX_SAFE_INTEGER); // 9007199254740991n\nx + 1n === x + 2n; // false because 9007199254740992n and 9007199254740993n are unequal\n\n// Number\nNumber.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2; // true because both are 9007199254740992\n\n```\n\nYou can use most operators to work with BigInts, including `+`, `*`, `-`, `**`, and `%` — the only forbidden one is [\\>>>](/en-US/docs/Web/JavaScript/Reference/Operators/Unsigned%5Fright%5Fshift). A BigInt is not [strictly equal](/en-US/docs/Web/JavaScript/Reference/Operators/Strict%5Fequality) to a Number with the same mathematical value, but it is [loosely](/en-US/docs/Web/JavaScript/Reference/Operators/Equality) so.\n\nBigInt values are neither always more precise nor always less precise than numbers, since BigInts cannot represent fractional numbers, but can represent big integers more accurately. Neither type entails the other, and they are not mutually substitutable. A [TypeError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/TypeError) is thrown if BigInt values are mixed with regular numbers in arithmetic expressions, or if they are [implicitly converted](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number#number%5Fcoercion) to each other.\n\n### [String type](#string%5Ftype)\n\nThe [String](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String) type represents textual data and is encoded as a sequence of 16-bit unsigned integer values representing [UTF-16 code units](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String#utf-16%5Fcharacters%5Funicode%5Fcode%5Fpoints%5Fand%5Fgrapheme%5Fclusters). Each element in the string occupies a position in the string. The first element is at index `0`, the next at index `1`, and so on. The [length](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String/length) of a string is the number of UTF-16 code units in it, which may not correspond to the actual number of Unicode characters; see the [String](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String#utf-16%5Fcharacters%5Funicode%5Fcode%5Fpoints%5Fand%5Fgrapheme%5Fclusters) reference page for more details.\n\nJavaScript strings are immutable. This means that once a string is created, it is not possible to modify it. String methods create new strings based on the content of the current string — for example:\n\n* A substring of the original using [substring()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String/substring).\n* A concatenation of two strings using the concatenation operator (`+`) or [concat()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String/concat).\n\n#### Beware of \"stringly-typing\" your code!\n\nIt can be tempting to use strings to represent complex data. Doing this comes with short-term benefits:\n\n* It is easy to build complex strings with concatenation.\n* Strings are easy to debug (what you see printed is always what is in the string).\n* Strings are the common denominator of a lot of APIs ([input fields](/en-US/docs/Web/API/HTMLInputElement), [local storage](/en-US/docs/Web/API/Web%5FStorage%5FAPI) values, [XMLHttpRequest](/en-US/docs/Web/API/XMLHttpRequest) responses when using `responseText`, etc.) and it can be tempting to only work with strings.\n\nWith conventions, it is possible to represent any data structure in a string. This does not make it a good idea. For instance, with a separator, one could emulate a list (while a JavaScript array would be more suitable). Unfortunately, when the separator is used in one of the \"list\" elements, then, the list is broken. An escape character can be chosen, etc. All of this requires conventions and creates an unnecessary maintenance burden.\n\nUse strings for textual data. When representing complex data, _parse_ strings, and use the appropriate abstraction.\n\n### [Symbol type](#symbol%5Ftype)\n\nA [Symbol](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Symbol) is a **unique** and **immutable** primitive value and may be used as the key of an Object property (see below). In some programming languages, Symbols are called \"atoms\". The purpose of symbols is to create unique property keys that are guaranteed not to clash with keys from other code.\n\n## [Objects](#objects)\n\nIn computer science, an object is a value in memory which is possibly referenced by an [identifier](/en-US/docs/Glossary/Identifier). In JavaScript, objects are the only [mutable](/en-US/docs/Glossary/Mutable) values. [Functions](/en-US/docs/Web/JavaScript/Reference/Functions) are, in fact, also objects with the additional capability of being _callable_.\n\n### [Properties](#properties)\n\nIn JavaScript, objects can be seen as a collection of properties. With the [object literal syntax](/en-US/docs/Web/JavaScript/Guide/Grammar%5Fand%5Ftypes#object%5Fliterals), a limited set of properties are initialized; then properties can be added and removed. Object properties are equivalent to key-value pairs. Property keys are either [strings](#string%5Ftype) or [symbols](#symbol%5Ftype). Property values can be values of any type, including other objects, which enables building complex data structures.\n\nThere are two types of object properties: The [_data_ property](#data%5Fproperty) and the [_accessor_ property](#accessor%5Fproperty). Each property has corresponding _attributes_. Each attribute is accessed internally by the JavaScript engine, but you can set them through [Object.defineProperty()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/defineProperty), or read them through [Object.getOwnPropertyDescriptor()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/getOwnPropertyDescriptor). You can read more about the various nuances on the [Object.defineProperty()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/defineProperty) page.\n\n#### Data property\n\nData properties associate a key with a value. It can be described by the following attributes:\n\n`value`\n\nThe value retrieved by a get access of the property. Can be any JavaScript value.\n\n`writable`\n\nA boolean value indicating if the property can be changed with an assignment.\n\n`enumerable`\n\nA boolean value indicating if the property can be enumerated by a [for...in](/en-US/docs/Web/JavaScript/Reference/Statements/for...in) loop. See also [Enumerability and ownership of properties](/en-US/docs/Web/JavaScript/Enumerability%5Fand%5Fownership%5Fof%5Fproperties) for how enumerability interacts with other functions and syntaxes.\n\n`configurable`\n\nA boolean value indicating if the property can be deleted, can be changed to an accessor property, and can have its attributes changed.\n\n#### Accessor property\n\nAssociates a key with one of two accessor functions (`get` and `set`) to retrieve or store a value.\n\n**Note:** It's important to recognize it's accessor _property_ — not accessor _method_. We can give a JavaScript object class-like accessors by using a function as a value — but that doesn't make the object a class.\n\nAn accessor property has the following attributes:\n\n`get`\n\nA function called with an empty argument list to retrieve the property value whenever a get access to the value is performed. See also [getters](/en-US/docs/Web/JavaScript/Reference/Functions/get). May be `undefined`.\n\n`set`\n\nA function called with an argument that contains the assigned value. Executed whenever a specified property is attempted to be changed. See also [setters](/en-US/docs/Web/JavaScript/Reference/Functions/set). May be `undefined`.\n\n`enumerable`\n\nA boolean value indicating if the property can be enumerated by a [for...in](/en-US/docs/Web/JavaScript/Reference/Statements/for...in) loop. See also [Enumerability and ownership of properties](/en-US/docs/Web/JavaScript/Enumerability%5Fand%5Fownership%5Fof%5Fproperties) for how enumerability interacts with other functions and syntaxes.\n\n`configurable`\n\nA boolean value indicating if the property can be deleted, can be changed to a data property, and can have its attributes changed.\n\nThe [prototype](/en-US/docs/Web/JavaScript/Inheritance%5Fand%5Fthe%5Fprototype%5Fchain) of an object points to another object or to `null` — it's conceptually a hidden property of the object, commonly represented as `[[Prototype]]`. Properties of the object's `[[Prototype]]` can also be accessed on the object itself.\n\nObjects are ad-hoc key-value pairs, so they are often used as maps. However, there can be ergonomics, security, and performance issues. Use a [Map](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Map) for storing arbitrary data instead. The [Map reference](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Map#objects%5Fvs.%5Fmaps) contains a more detailed discussion of the pros & cons between plain objects and maps for storing key-value associations.\n\n### [Dates](#dates)\n\nWhen representing dates, the best choice is to use the built-in [Date](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Date) utility in JavaScript.\n\n### [Indexed collections: Arrays and typed Arrays](#indexed%5Fcollections%5Farrays%5Fand%5Ftyped%5Farrays)\n\n[Arrays](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Array) are regular objects for which there is a particular relationship between integer-keyed properties and the `length` property.\n\nAdditionally, arrays inherit from `Array.prototype`, which provides a handful of convenient methods to manipulate arrays. For example, [indexOf()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Array/indexOf) searches a value in the array and [push()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Array/push) appends an element to the array. This makes Arrays a perfect candidate to represent ordered lists.\n\n[Typed Arrays](/en-US/docs/Web/JavaScript/Guide/Typed%5Farrays) present an array-like view of an underlying binary data buffer, and offer many methods that have similar semantics to the array counterparts. \"Typed array\" is an umbrella term for a range of data structures, including `Int8Array`, `Float32Array`, etc. Check the [typed array](/en-US/docs/Web/JavaScript/Guide/Typed%5Farrays) page for more information. Typed arrays are often used in conjunction with [ArrayBuffer](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/ArrayBuffer) and [DataView](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/DataView).\n\n### [Keyed collections: Maps, Sets, WeakMaps, WeakSets](#keyed%5Fcollections%5Fmaps%5Fsets%5Fweakmaps%5Fweaksets)\n\nThese data structures take object references as keys. [Set](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Set) and [WeakSet](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/WeakSet) represent a collection of unique values, while [Map](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Map) and [WeakMap](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/WeakMap) represent a collection of key-value associations.\n\nYou could implement `Map`s and `Set`s yourself. However, since objects cannot be compared (in the sense of `<` \"less than\", for instance), neither does the engine expose its hash function for objects, look-up performance would necessarily be linear. Native implementations of them (including `WeakMap`s) can have look-up performance that is approximately logarithmic to constant time.\n\nUsually, to bind data to a DOM node, one could set properties directly on the object, or use `data-*` attributes. This has the downside that the data is available to any script running in the same context. `Map`s and `WeakMap`s make it easy to _privately_ bind data to an object.\n\n`WeakMap` and `WeakSet` only allow garbage-collectable values as keys, which are either objects or [non-registered symbols](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Symbol#shared%5Fsymbols%5Fin%5Fthe%5Fglobal%5Fsymbol%5Fregistry), and the keys may be collected even when they remain in the collection. They are specifically used for [memory usage optimization](/en-US/docs/Web/JavaScript/Memory%5Fmanagement#data%5Fstructures%5Faiding%5Fmemory%5Fmanagement).\n\n### [Structured data: JSON](#structured%5Fdata%5Fjson)\n\nJSON (**J**ava**S**cript **O**bject **N**otation) is a lightweight data-interchange format, derived from JavaScript, but used by many programming languages. JSON builds universal data structures that can be transferred between different environments and even across languages. See [JSON](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/JSON) for more details.\n\n### [More objects in the standard library](#more%5Fobjects%5Fin%5Fthe%5Fstandard%5Flibrary)\n\nJavaScript has a standard library of built-in objects. Read the [reference](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects) to find out more about the built-in objects.\n\n## [Type coercion](#type%5Fcoercion)\n\nAs mentioned above, JavaScript is a [weakly typed](#dynamic%5Fand%5Fweak%5Ftyping) language. This means that you can often use a value of one type where another type is expected, and the language will convert it to the right type for you. To do so, JavaScript defines a handful of coercion rules.\n\n### [Primitive coercion](#primitive%5Fcoercion)\n\nThe [primitive coercion](https://tc39.es/ecma262/#sec-toprimitive) process is used where a primitive value is expected, but there's no strong preference for what the actual type should be. This is usually when a [string](#string%5Ftype), a [number](#number%5Ftype), or a [BigInt](#bigint%5Ftype) are equally acceptable. For example:\n\n* The [Date()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Date/Date) constructor, when it receives one argument that's not a `Date` instance — strings represent date strings, while numbers represent timestamps.\n* The [+](/en-US/docs/Web/JavaScript/Reference/Operators/Addition) operator — if one operand is a string, string concatenation is performed; otherwise, numeric addition is performed.\n* The [\\==](/en-US/docs/Web/JavaScript/Reference/Operators/Equality) operator — if one operand is a primitive while the other is an object, the object is converted to a primitive value with no preferred type.\n\nThis operation does not do any conversion if the value is already a primitive. Objects are converted to primitives by calling its [\\[@@toPrimitive\\]()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Symbol/toPrimitive) (with `\"default\"` as hint), `valueOf()`, and `toString()` methods, in that order. Note that primitive conversion calls `valueOf()` before `toString()`, which is similar to the behavior of [number coercion](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number#number%5Fcoercion) but different from [string coercion](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String#string%5Fcoercion).\n\nThe `[@@toPrimitive]()` method, if present, must return a primitive — returning an object results in a [TypeError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/TypeError). For `valueOf()` and `toString()`, if one returns an object, the return value is ignored and the other's return value is used instead; if neither is present, or neither returns a primitive, a [TypeError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/TypeError) is thrown. For example, in the following code:\n\n```\nconsole.log({} + []); // \"[object Object]\"\n\n```\n\nNeither `{}` nor `[]` have a `[@@toPrimitive]()` method. Both `{}` and `[]` inherit `valueOf()` from [Object.prototype.valueOf](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/valueOf), which returns the object itself. Since the return value is an object, it is ignored. Therefore, `toString()` is called instead. [{}.toString()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/toString) returns `\"[object Object]\"`, while [\\[\\].toString()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Array/toString) returns `\"\"`, so the result is their concatenation: `\"[object Object]\"`.\n\nThe `[@@toPrimitive]()` method always takes precedence when doing conversion to any primitive type. Primitive conversion generally behaves like number conversion, because `valueOf()` is called in priority; however, objects with custom `[@@toPrimitive]()` methods can choose to return any primitive. [Date](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Date) and [Symbol](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Symbol) objects are the only built-in objects that override the `[@@toPrimitive]()` method. [Date.prototype\\[@@toPrimitive\\]()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Date/@@toPrimitive) treats the `\"default\"` hint as if it's `\"string\"`, while [Symbol.prototype\\[@@toPrimitive\\]()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Symbol/@@toPrimitive) ignores the hint and always returns a symbol.\n\n### [Numeric coercion](#numeric%5Fcoercion)\n\nThere are two numeric types: [Number](#number%5Ftype) and [BigInt](#bigint%5Ftype). Sometimes the language specifically expects a number or a BigInt (such as [Array.prototype.slice()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Array/slice), where the index must be a number); other times, it may tolerate either and perform different operations depending on the operand's type. For strict coercion processes that do not allow implicit conversion from the other type, see [number coercion](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number#number%5Fcoercion) and [BigInt coercion](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/BigInt#bigint%5Fcoercion).\n\nNumeric coercion is nearly the same as [number coercion](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number#number%5Fcoercion), except that BigInts are returned as-is instead of causing a [TypeError](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/TypeError). Numeric coercion is used by all arithmetic operators, since they are overloaded for both numbers and BigInts. The only exception is [unary plus](/en-US/docs/Web/JavaScript/Reference/Operators/Unary%5Fplus), which always does number coercion.\n\n### [Other coercions](#other%5Fcoercions)\n\nAll data types, except Null, Undefined, and Symbol, have their respective coercion process. See [string coercion](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String#string%5Fcoercion), [boolean coercion](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Boolean#boolean%5Fcoercion), and [object coercion](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object#object%5Fcoercion) for more details.\n\nAs you may have noticed, there are three distinct paths through which objects may be converted to primitives:\n\n* [Primitive coercion](#primitive%5Fcoercion): `[@@toPrimitive](\"default\")` → `valueOf()` → `toString()`\n* [Numeric coercion](#numeric%5Fcoercion), [number coercion](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Number#number%5Fcoercion), [BigInt coercion](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/BigInt#bigint%5Fcoercion): `[@@toPrimitive](\"number\")` → `valueOf()` → `toString()`\n* [String coercion](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/String#string%5Fcoercion): `[@@toPrimitive](\"string\")` → `toString()` → `valueOf()`\n\nIn all cases, `[@@toPrimitive]()`, if present, must be callable and return a primitive, while `valueOf` or `toString` will be ignored if they are not callable or return an object. At the end of the process, if successful, the result is guaranteed to be a primitive. The resulting primitive is then subject to further coercions depending on the context.\n\n## [See also](#see%5Falso)\n\n* [JavaScript Data Structures and Algorithms by Oleksii Trekhleb](https://github.com/trekhleb/javascript-algorithms)\n* [Nicholas Zakas collection of common data structure and common algorithms in JavaScript.](https://github.com/humanwhocodes/computer-science-in-javascript)\n* [Search Tre(i)es implemented in JavaScript](https://github.com/monmohan/dsjslib)\n* [Data Types and Values in the ECMAScript specification](https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values)\n\n### Found a content problem with this page?\n\n* [Edit the page on GitHub](https://github.com/mdn/content/edit/main/files/en-us/web/javascript/data%5Fstructures/index.md \"This will take you to GitHub, where you'll need to sign in first.\").\n* [Report the content issue](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FData%5Fstructures&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A%2A+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Fdata%5Fstructures%60%0A%2A+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FData%5Fstructures%0A%2A+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Fdata%5Fstructures%2Findex.md%0A%2A+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2F5635446aa0127d686183ddd4fd5adcc34be567da%0A%2A+Document+last+modified%3A+2023-05-03T23%3A25%3A19.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\").\n* [View the source on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/javascript/data%5Fstructures/index.md?plain=1 \"Folder: en-us/web/javascript/data_structures (Opens in a new tab)\").\nWant to get more involved? [Learn how to contribute](https://github.com/mdn/content/blob/main/CONTRIBUTING.md \"This will take you to our contribution guidelines on GitHub.\").\n\nThis page was last modified on May 3, 2023 by [MDN contributors](/en-US/docs/Web/JavaScript/Data%5Fstructures/contributors.txt)."}