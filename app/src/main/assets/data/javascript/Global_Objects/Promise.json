{"lang":"Javascript","fullPath":"/Global_Objects/Promise","category":"Global_Objects","title":"Promise","url":"/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise","markdown":"# Promise\n\nThe **`Promise`** object represents the eventual completion (or failure) of an asynchronous operation and its resulting value.\n\nTo learn about the way promises work and how you can use them, we advise you to read [Using promises](/en-US/docs/Web/JavaScript/Guide/Using%5Fpromises) first.\n\n## [Description](#description)\n\nA **`Promise`** is a proxy for a value not necessarily known when the promise is created. It allows you to associate handlers with an asynchronous action's eventual success value or failure reason. This lets asynchronous methods return values like synchronous methods: instead of immediately returning the final value, the asynchronous method returns a _promise_ to supply the value at some point in the future.\n\nA `Promise` is in one of these states:\n\n* _pending_: initial state, neither fulfilled nor rejected.\n* _fulfilled_: meaning that the operation was completed successfully.\n* _rejected_: meaning that the operation failed.\n\n The _eventual state_ of a pending promise can either be _fulfilled_ with a value or _rejected_ with a reason (error). When either of these options occur, the associated handlers queued up by a promise's `then` method are called. If the promise has already been fulfilled or rejected when a corresponding handler is attached, the handler will be called, so there is no race condition between an asynchronous operation completing and its handlers being attached.\n\nA promise is said to be _settled_ if it is either fulfilled or rejected, but not pending.\n\n![Flowchart showing how the Promise state transitions between pending, fulfilled, and rejected via then/catch handlers. A pending promise can become either fulfilled or rejected. If fulfilled, the \"on fulfillment\" handler, or first parameter of the then() method, is executed and carries out further asynchronous actions. If rejected, the error handler, either passed as the second parameter of the then() method or as the sole parameter of the catch() method, gets executed.](/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/promises.png) \n\nYou will also hear the term _resolved_ used with promises â€” this means that the promise is settled or \"locked-in\" to match the eventual state of another promise, and further resolving or rejecting it has no effect. The [States and fates](https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md) document from the original Promise proposal contains more details about promise terminology. Colloquially, \"resolved\" promises are often equivalent to \"fulfilled\" promises, but as illustrated in \"States and fates\", resolved promises can be pending or rejected as well. For example:\n\n```\nnew Promise((resolveOuter) => {\n  resolveOuter(\n    new Promise((resolveInner) => {\n      setTimeout(resolveInner, 1000);\n    }),\n  );\n});\n\n```\n\nThis promise is already _resolved_ at the time when it's created (because the `resolveOuter` is called synchronously), but it is resolved with another promise, and therefore won't be _fulfilled_ until 1 second later, when the inner promise fulfills. In practice, the \"resolution\" is often done behind the scenes and not observable, and only its fulfillment or rejection are.\n\n**Note:** Several other languages have mechanisms for lazy evaluation and deferring a computation, which they also call \"promises\", e.g. Scheme. Promises in JavaScript represent processes that are already happening, which can be chained with callback functions. If you are looking to lazily evaluate an expression, consider using a function with no arguments e.g. `f = () => expression` to create the lazily-evaluated expression, and `f()` to evaluate the expression immediately.\n\n### [Chained Promises](#chained%5Fpromises)\n\nThe methods [Promise.prototype.then()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/then), [Promise.prototype.catch()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/catch), and [Promise.prototype.finally()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/finally) are used to associate further action with a promise that becomes settled. As these methods return promises, they can be chained.\n\nThe `.then()` method takes up to two arguments; the first argument is a callback function for the fulfilled case of the promise, and the second argument is a callback function for the rejected case. Each `.then()` returns a newly generated promise object, which can optionally be used for chaining; for example:\n\n```\nconst myPromise = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(\"foo\");\n  }, 300);\n});\n\nmyPromise\n  .then(handleFulfilledA, handleRejectedA)\n  .then(handleFulfilledB, handleRejectedB)\n  .then(handleFulfilledC, handleRejectedC);\n\n```\n\nProcessing continues to the next link of the chain even when a `.then()` lacks a callback function that returns a Promise object. Therefore, a chain can safely omit every _rejection_ callback function until the final `.catch()`.\n\nHandling a rejected promise in each `.then()` has consequences further down the promise chain. Sometimes there is no choice, because an error must be handled immediately. In such cases we must throw an error of some type to maintain error state down the chain. On the other hand, in the absence of an immediate need, it is simpler to leave out error handling until a final `.catch()` statement. A `.catch()` is really just a `.then()` without a slot for a callback function for the case when the promise is fulfilled.\n\n```\nmyPromise\n  .then(handleFulfilledA)\n  .then(handleFulfilledB)\n  .then(handleFulfilledC)\n  .catch(handleRejectedAny);\n\n```\n\nUsing [arrow functions](/en-US/docs/Web/JavaScript/Reference/Functions/Arrow%5Ffunctions) for the callback functions, implementation of the promise chain might look something like this:\n\n```\nmyPromise\n  .then((value) => `${value} and bar`)\n  .then((value) => `${value} and bar again`)\n  .then((value) => `${value} and again`)\n  .then((value) => `${value} and again`)\n  .then((value) => {\n    console.log(value);\n  })\n  .catch((err) => {\n    console.error(err);\n  });\n\n```\n\n**Note:** For faster execution, all synchronous actions should preferably be done within one handler, otherwise it would take several ticks to execute all handlers in sequence.\n\nThe termination condition of a promise determines the \"settled\" state of the next promise in the chain. A \"fulfilled\" state indicates a successful completion of the promise, while a \"rejected\" state indicates a lack of success. The return value of each fulfilled promise in the chain is passed along to the next `.then()`, while the reason for rejection is passed along to the next rejection-handler function in the chain.\n\nThe promises of a chain are nested in one another, but get popped like the top of a stack. The first promise in the chain is most deeply nested and is the first to pop.\n\n(promise D, (promise C, (promise B, (promise A) ) ) )\n\nWhen a `nextValue` is a promise, the effect is a dynamic replacement. The `return` causes a promise to be popped, but the `nextValue` promise is pushed into its place. For the nesting shown above, suppose the `.then()` associated with \"promise B\" returns a `nextValue` of \"promise X\". The resulting nesting would look like this:\n\n(promise D, (promise C, (promise X) ) )\n\nA promise can participate in more than one nesting. For the following code, the transition of `promiseA` into a \"settled\" state will cause both instances of `.then()` to be invoked.\n\n```\nconst promiseA = new Promise(myExecutorFunc);\nconst promiseB = promiseA.then(handleFulfilled1, handleRejected1);\nconst promiseC = promiseA.then(handleFulfilled2, handleRejected2);\n\n```\n\nAn action can be assigned to an already \"settled\" promise. In that case, the action (if appropriate) will be performed at the first asynchronous opportunity. Note that promises are guaranteed to be asynchronous. Therefore, an action for an already \"settled\" promise will occur only after the stack has cleared and a clock-tick has passed. The effect is much like that of `setTimeout(action,10)`.\n\n```\nconst promiseA = new Promise((resolve, reject) => {\n  resolve(777);\n});\n// At this point, \"promiseA\" is already settled.\npromiseA.then((val) => console.log(\"asynchronous logging has val:\", val));\nconsole.log(\"immediate logging\");\n\n// produces output in this order:\n// immediate logging\n// asynchronous logging has val: 777\n\n```\n\n### [Thenables](#thenables)\n\nThe JavaScript ecosystem had made multiple Promise implementations long before it became part of the language. Despite being represented differently internally, at the minimum, all Promise-like objects implement the _Thenable_ interface. A thenable implements the [.then()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/then) method, which is called with two callbacks: one for when the promise is fulfilled, one for when it's rejected. Promises are thenables as well.\n\nTo interoperate with the existing Promise implementations, the language allows using thenables in place of promises. For example, [Promise.resolve](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/resolve) will not only resolve promises, but also trace thenables.\n\n```\nconst aThenable = {\n  then(onFulfilled, onRejected) {\n    onFulfilled({\n      // The thenable is fulfilled with another thenable\n      then(onFulfilled, onRejected) {\n        onFulfilled(42);\n      },\n    });\n  },\n};\n\nPromise.resolve(aThenable); // A promise fulfilled with 42\n\n```\n\n### [Promise concurrency](#promise%5Fconcurrency)\n\nThe `Promise` class offers four static methods to facilitate async task [concurrency](https://en.wikipedia.org/wiki/Concurrent%5Fcomputing):\n\n[Promise.all()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/all)\n\nFulfills when **all** of the promises fulfill; rejects when **any** of the promises rejects.\n\n[Promise.allSettled()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/allSettled)\n\nFulfills when **all** promises settle.\n\n[Promise.any()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/any)\n\nFulfills when **any** of the promises fulfills; rejects when **all** of the promises reject.\n\n[Promise.race()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/race)\n\nSettles when **any** of the promises settles. In other words, fulfills when any of the promises fulfills; rejects when any of the promises rejects.\n\nAll these methods take an [iterable](/en-US/docs/Web/JavaScript/Reference/Iteration%5Fprotocols#the%5Fiterable%5Fprotocol) of promises ([thenables](#thenables), to be exact) and return a new promise. They all support subclassing, which means they can be called on subclasses of `Promise`, and the result will be a promise of the subclass type. To do so, the subclass's constructor must implement the same signature as the [Promise()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/Promise) constructor â€” accepting a single `executor` function that can be called with the `resolve` and `reject` callbacks as parameters. The subclass must also have a `resolve` static method that can be called like [Promise.resolve()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/resolve) to resolve values to promises.\n\nNote that JavaScript is [single-threaded](/en-US/docs/Glossary/Thread) by nature, so at a given instant, only one task will be executing, although control can shift between different promises, making execution of the promises appear concurrent. [Parallel execution](https://en.wikipedia.org/wiki/Parallel%5Fcomputing) in JavaScript can only be achieved through [worker threads](/en-US/docs/Web/API/Web%5FWorkers%5FAPI).\n\n## [Constructor](#constructor)\n\n[Promise()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/Promise)\n\nCreates a new `Promise` object. The constructor is primarily used to wrap functions that do not already support promises.\n\n## [Static properties](#static%5Fproperties)\n\n[Promise\\[@@species\\]](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/@@species)\n\nReturns the constructor used to construct return values from promise methods.\n\n## [Static methods](#static%5Fmethods)\n\n[Promise.all()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/all)\n\nWait for all promises to be fulfilled, or for any to be rejected.\n\nIf the returned promise fulfills, it is fulfilled with an aggregating array of the values from the fulfilled promises, in the same order as defined in the iterable of multiple promises.\n\nIf it rejects, it is rejected with the reason from the first promise in the iterable that was rejected.\n\n[Promise.allSettled()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/allSettled)\n\nWait until all promises have settled (each may fulfill or reject).\n\nReturns a Promise that fulfills after all of the given promises is either fulfilled or rejected, with an array of objects that each describe the outcome of each promise.\n\n[Promise.any()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/any)\n\nTakes an iterable of Promise objects and, as soon as one of the promises in the iterable fulfills, returns a single promise that fulfills with the value from that promise.\n\n[Promise.race()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/race)\n\nWait until any of the promises is fulfilled or rejected.\n\nIf the returned promise fulfills, it is fulfilled with the value of the first promise in the iterable that fulfilled.\n\nIf it rejects, it is rejected with the reason from the first promise that was rejected.\n\n[Promise.reject()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/reject)\n\nReturns a new `Promise` object that is rejected with the given reason.\n\n[Promise.resolve()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/resolve)\n\nReturns a new `Promise` object that is resolved with the given value. If the value is a thenable (i.e. has a `then` method), the returned promise will \"follow\" that thenable, adopting its eventual state; otherwise, the returned promise will be fulfilled with the value.\n\nGenerally, if you don't know if a value is a promise or not, [Promise.resolve(value)](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/resolve) it instead and work with the return value as a promise.\n\n## [Instance properties](#instance%5Fproperties)\n\nThese properties are defined on `Promise.prototype` and shared by all `Promise` instances.\n\n[Promise.prototype.constructor](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/constructor)\n\nThe constructor function that created the instance object. For `Promise` instances, the initial value is the [Promise](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/Promise) constructor.\n\n`Promise.prototype[@@toStringTag]`\n\nThe initial value of the [@@toStringTag](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Symbol/toStringTag) property is the string `\"Promise\"`. This property is used in [Object.prototype.toString()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Object/toString).\n\n## [Instance methods](#instance%5Fmethods)\n\n[Promise.prototype.catch()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/catch)\n\nAppends a rejection handler callback to the promise, and returns a new promise resolving to the return value of the callback if it is called, or to its original fulfillment value if the promise is instead fulfilled.\n\n[Promise.prototype.finally()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/finally)\n\nAppends a handler to the promise, and returns a new promise that is resolved when the original promise is resolved. The handler is called when the promise is settled, whether fulfilled or rejected.\n\n[Promise.prototype.then()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/then)\n\nAppends fulfillment and rejection handlers to the promise, and returns a new promise resolving to the return value of the called handler, or to its original settled value if the promise was not handled (i.e. if the relevant handler `onFulfilled` or `onRejected` is not a function).\n\n## [Examples](#examples)\n\n### [Basic Example](#basic%5Fexample)\n\n```\nconst myFirstPromise = new Promise((resolve, reject) => {\n  // We call resolve(...) when what we were doing asynchronously was successful, and reject(...) when it failed.\n  // In this example, we use setTimeout(...) to simulate async code.\n  // In reality, you will probably be using something like XHR or an HTML API.\n  setTimeout(() => {\n    resolve(\"Success!\"); // Yay! Everything went well!\n  }, 250);\n});\n\nmyFirstPromise.then((successMessage) => {\n  // successMessage is whatever we passed in the resolve(...) function above.\n  // It doesn't have to be a string, but if it is only a succeed message, it probably will be.\n  console.log(`Yay! ${successMessage}`);\n});\n\n```\n\n### [Example with diverse situations](#example%5Fwith%5Fdiverse%5Fsituations)\n\nThis example shows diverse techniques for using Promise capabilities and diverse situations that can occur. To understand this, start by scrolling to the bottom of the code block, and examine the promise chain. Upon provision of an initial promise, a chain of promises can follow. The chain is composed of `.then()` calls, and typically (but not necessarily) has a single `.catch()` at the end, optionally followed by `.finally()`. In this example, the promise chain is initiated by a custom-written `new Promise()` construct; but in actual practice, promise chains more typically start with an API function (written by someone else) that returns a promise.\n\nThe example function `tetheredGetNumber()` shows that a promise generator will utilize `reject()` while setting up an asynchronous call, or within the call-back, or both. The function `promiseGetWord()` illustrates how an API function might generate and return a promise in a self-contained manner.\n\nNote that the function `troubleWithGetNumber()` ends with a `throw`. That is forced because a promise chain goes through all the `.then()` promises, even after an error, and without the `throw`, the error would seem \"fixed\". This is a hassle, and for this reason, it is common to omit `onRejected` throughout the chain of `.then()` promises, and just have a single `onRejected` in the final `catch()`.\n\nThis code can be run under NodeJS. Comprehension is enhanced by seeing the errors actually occur. To force more errors, change the `threshold` values.\n\n```\n// To experiment with error handling, \"threshold\" values cause errors randomly\nconst THRESHOLD_A = 8; // can use zero 0 to guarantee error\n\nfunction tetheredGetNumber(resolve, reject) {\n  setTimeout(() => {\n    const randomInt = Date.now();\n    const value = randomInt % 10;\n    if (value < THRESHOLD_A) {\n      resolve(value);\n    } else {\n      reject(`Too large: ${value}`);\n    }\n  }, 500);\n}\n\nfunction determineParity(value) {\n  const isOdd = value % 2 === 1;\n  return { value, isOdd };\n}\n\nfunction troubleWithGetNumber(reason) {\n  const err = new Error(\"Trouble getting number\", { cause: reason });\n  console.error(err);\n  throw err;\n}\n\nfunction promiseGetWord(parityInfo) {\n  return new Promise((resolve, reject) => {\n    const { value, isOdd } = parityInfo;\n    if (value >= THRESHOLD_A - 1) {\n      reject(`Still too large: ${value}`);\n    } else {\n      parityInfo.wordEvenOdd = isOdd ? \"odd\" : \"even\";\n      resolve(parityInfo);\n    }\n  });\n}\n\nnew Promise(tetheredGetNumber)\n  .then(determineParity, troubleWithGetNumber)\n  .then(promiseGetWord)\n  .then((info) => {\n    console.log(`Got: ${info.value}, ${info.wordEvenOdd}`);\n    return info;\n  })\n  .catch((reason) => {\n    if (reason.cause) {\n      console.error(\"Had previously handled error\");\n    } else {\n      console.error(`Trouble with promiseGetWord(): ${reason}`);\n    }\n  })\n  .finally((info) => console.log(\"All done\"));\n\n```\n\n### [Advanced Example](#advanced%5Fexample)\n\nThis small example shows the mechanism of a `Promise`. The `testPromise()` method is called each time the [<button>](/en-US/docs/Web/HTML/Element/button) is clicked. It creates a promise that will be fulfilled, using [setTimeout()](/en-US/docs/Web/API/setTimeout), to the promise count (number starting from 1) every 1-3 seconds, at random. The `Promise()` constructor is used to create the promise.\n\nThe fulfillment of the promise is logged, via a fulfill callback set using [p1.then()](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/then). A few logs show how the synchronous part of the method is decoupled from the asynchronous completion of the promise.\n\nBy clicking the button several times in a short amount of time, you'll even see the different promises being fulfilled one after another.\n\n#### HTML\n\n```\n<button id=\"make-promise\">Make a promise!</button>\n<div id=\"log\"></div>\n\n```\n\n#### JavaScript\n\n```\n\"use strict\";\n\nlet promiseCount = 0;\n\nfunction testPromise() {\n  const thisPromiseCount = ++promiseCount;\n  const log = document.getElementById(\"log\");\n  // begin\n  log.insertAdjacentHTML(\"beforeend\", `${thisPromiseCount}) Started<br>`);\n  // We make a new promise: we promise a numeric count of this promise,\n  // starting from 1 (after waiting 3s)\n  const p1 = new Promise((resolve, reject) => {\n    // The executor function is called with the ability\n    // to resolve or reject the promise\n    log.insertAdjacentHTML(\n      \"beforeend\",\n      `${thisPromiseCount}) Promise constructor<br>`,\n    );\n    // This is only an example to create asynchronism\n    setTimeout(() => {\n      // We fulfill the promise\n      resolve(thisPromiseCount);\n    }, Math.random() * 2000 + 1000);\n  });\n\n  // We define what to do when the promise is resolved with the then() call,\n  // and what to do when the promise is rejected with the catch() call\n  p1.then((val) => {\n    // Log the fulfillment value\n    log.insertAdjacentHTML(\"beforeend\", `${val}) Promise fulfilled<br>`);\n  }).catch((reason) => {\n    // Log the rejection reason\n    console.log(`Handle rejected promise (${reason}) here.`);\n  });\n  // end\n  log.insertAdjacentHTML(\"beforeend\", `${thisPromiseCount}) Promise made<br>`);\n}\n\nconst btn = document.getElementById(\"make-promise\");\nbtn.addEventListener(\"click\", testPromise);\n\n```\n\n#### Result\n\n### [Loading an image with XHR](#loading%5Fan%5Fimage%5Fwith%5Fxhr)\n\nAnother simple example using `Promise` and [XMLHttpRequest](/en-US/docs/Web/API/XMLHttpRequest) to load an image is available at the MDN GitHub [js-examples](https://github.com/mdn/js-examples/tree/master/promises-test) repository. You can also [see it in action](https://mdn.github.io/js-examples/promises-test/). Each step is commented on and allows you to follow the Promise and XHR architecture closely.\n\n### [Incumbent settings object tracking](#incumbent%5Fsettings%5Fobject%5Ftracking)\n\nA settings object is an [environment](https://html.spec.whatwg.org/multipage/webappapis.html#environment-settings-object) that provides additional information when JavaScript code is running. This includes the realm and module map, as well as HTML specific information such as the origin. The incumbent settings object is tracked in order to ensure that the browser knows which one to use for a given piece of user code.\n\nTo better picture this, we can take a closer look at how the realm might be an issue. A **realm** can be roughly thought of as the global object. What is unique about realms is that they hold all of the necessary information to run JavaScript code. This includes objects like [Array](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Array) and [Error](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Error). Each settings object has its own \"copy\" of these and they are not shared. That can cause some unexpected behavior in relation to promises. In order to get around this, we track something called the **incumbent settings object**. This represents information specific to the context of the user code responsible for a certain function call.\n\nTo illustrate this a bit further we can take a look at how an [<iframe>](/en-US/docs/Web/HTML/Element/iframe) embedded in a document communicates with its host. Since all web APIs are aware of the incumbent settings object, the following will work in all browsers:\n\n```\n<!DOCTYPE html> <iframe></iframe>\n<!-- we have a realm here -->\n<script>\n  // we have a realm here as well\n  const bound = frames[0].postMessage.bind(frames[0], \"some data\", \"*\");\n  // bound is a built-in function â€” there is no user\n  // code on the stack, so which realm do we use?\n  setTimeout(bound);\n  // this still works, because we use the youngest\n  // realm (the incumbent) on the stack\n</script>\n\n```\n\nThe same concept applies to promises. If we modify the above example a little bit, we get this:\n\n```\n<!DOCTYPE html> <iframe></iframe>\n<!-- we have a realm here -->\n<script>\n  // we have a realm here as well\n  const bound = frames[0].postMessage.bind(frames[0], \"some data\", \"*\");\n  // bound is a built in function â€” there is no user\n  // code on the stack â€” which realm do we use?\n  Promise.resolve(undefined).then(bound);\n  // this still works, because we use the youngest\n  // realm (the incumbent) on the stack\n</script>\n\n```\n\nIf we change this so that the `<iframe>` in the document is listening to post messages, we can observe the effect of the incumbent settings object:\n\n```\n<!-- y.html -->\n<!DOCTYPE html>\n<iframe src=\"x.html\"></iframe>\n<script>\n  const bound = frames[0].postMessage.bind(frames[0], \"some data\", \"*\");\n  Promise.resolve(undefined).then(bound);\n</script>\n\n```\n\n```\n<!-- x.html -->\n<!DOCTYPE html>\n<script>\n  window.addEventListener(\n    \"message\",\n    (event) => {\n      document.querySelector(\"#text\").textContent = \"hello\";\n      // this code will only run in browsers that track the incumbent settings object\n      console.log(event);\n    },\n    false,\n  );\n</script>\n\n```\n\nIn the above example, the inner text of the `<iframe>` will be updated only if the incumbent settings object is tracked. This is because without tracking the incumbent, we may end up using the wrong environment to send the message.\n\n**Note:** Currently, incumbent realm tracking is fully implemented in Firefox, and has partial implementations in Chrome and Safari.\n\n## [Specifications](#specifications)\n\n| Specification                                                                                                                                       |\n| --------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [ECMAScript Language Specification  \\# sec-promise-objects](https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-promise-objects) |\n\n## [Browser compatibility](#browser%5Fcompatibility)\n\nBCD tables only load in the browser\n\n## [See also](#see%5Falso)\n\n* [Polyfill of Promise in core-js](https://github.com/zloirock/core-js#ecmascript-promise)\n* [Using promises](/en-US/docs/Web/JavaScript/Guide/Using%5Fpromises)\n* [Promises/A+ specification](https://promisesaplus.com/)\n* [JavaScript Promises: an introduction](https://web.dev/promises/)\n* [Domenic Denicola: Callbacks, Promises, and Coroutines â€“ Asynchronous Programming Patterns in JavaScript](https://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript)\n\n### Found a content problem with this page?\n\n* [Edit the page on GitHub](https://github.com/mdn/content/edit/main/files/en-us/web/javascript/reference/global%5Fobjects/promise/index.md \"This will take you to GitHub, where you'll need to sign in first.\").\n* [Report the content issue](https://github.com/mdn/content/issues/new?template=page-report.yml&mdn-url=https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal%5FObjects%2FPromise&metadata=%3C%21--+Do+not+make+changes+below+this+line+--%3E%0A%3Cdetails%3E%0A%3Csummary%3EPage+report+details%3C%2Fsummary%3E%0A%0A%2A+Folder%3A+%60en-us%2Fweb%2Fjavascript%2Freference%2Fglobal%5Fobjects%2Fpromise%60%0A%2A+MDN+URL%3A+https%3A%2F%2Fdeveloper.mozilla.org%2Fen-US%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal%5FObjects%2FPromise%0A%2A+GitHub+URL%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fblob%2Fmain%2Ffiles%2Fen-us%2Fweb%2Fjavascript%2Freference%2Fglobal%5Fobjects%2Fpromise%2Findex.md%0A%2A+Last+commit%3A+https%3A%2F%2Fgithub.com%2Fmdn%2Fcontent%2Fcommit%2F01bf58c144237c1fc75cf7135491346778591f09%0A%2A+Document+last+modified%3A+2023-04-08T17%3A33%3A52.000Z%0A%0A%3C%2Fdetails%3E \"This will take you to GitHub to file a new issue.\").\n* [View the source on GitHub](https://github.com/mdn/content/blob/main/files/en-us/web/javascript/reference/global%5Fobjects/promise/index.md?plain=1 \"Folder: en-us/web/javascript/reference/global_objects/promise (Opens in a new tab)\").\nWant to get more involved? [Learn how to contribute](https://github.com/mdn/content/blob/main/CONTRIBUTING.md \"This will take you to our contribution guidelines on GitHub.\").\n\nThis page was last modified on Apr 8, 2023 by [MDN contributors](/en-US/docs/Web/JavaScript/Reference/Global%5FObjects/Promise/contributors.txt)."}